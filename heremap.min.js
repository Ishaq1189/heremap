(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.heremap = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/heremap.js":[function(require,module,exports){
(function (process){
"use strict";

/*
 * @module HEREMAP
 * @typicalname hm
 */

let modules = {};
Object.assign(modules, require("./common.js"));
Object.assign(modules, require("./geometry.js"));
Object.assign(modules, require("./routing.js"));
Object.assign(modules, require("./geocoding.js"));
Object.assign(modules, require("./place.js"));

// only added in case of browser library
if (process.browser) {
    Object.assign(modules, require("./map.js"));
    Object.assign(modules, require("./cluster.js"));
    Object.assign(modules, require("./touch.js"));
}
// export all the above
module.exports = modules;
}).call(this,require('_process'))

},{"./cluster.js":2,"./common.js":3,"./geocoding.js":4,"./geometry.js":5,"./map.js":6,"./place.js":15,"./routing.js":16,"./touch.js":17,"_process":1}],1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/* global H, document, Image */
"use strict";
const cm = require("./common.js");
const m = require("./map.js");

// map on which to add the cluster layer
let map = null;

//the cluster layer
let clusterLayer = null;
let _visible = false;

let iconNoise = null;
let clusterStyle = []; // array of {weight,pos imagedata}

let clusteredDataProvider = null;


/**
 * Creates a cluster of points
 * @alias hm:cluster
 * @param coords {Array}  array of \[lat,lng,payload\]
 * @param opt {object} options for cluster
 * @param [opt.minZoom] {number} min zoom for cluster to be visible
 * @param [opt.maxZoom] {number} max zoom for cluster to be visible
 * @param [opt.noise] {object} graphic to represent stand-alone point. {icon,size}
 * @param [opt.noise.icon] {string} png/jpg/svg file. @ as first character indicates a file from this package. Anchor will be bottom-center
 * @param [opt.noise.size] {number} optional size of icon
 * @param [opt.cluster] {object} { weight:{icon,size}, weight:{icon,size},... }
 * @param [opt.cluster.icon] {string} png/jpg/svg file to represent group of pois. @ as first character indicates a file from this package. Anchor will be middle of icon
 * @param [opt.cluster.size] {number} size of icon
 * @param {function} cb callback to be called if click on item. Format cb(event, coord, payload, weigth). 
 * `coord` is coord of icon
 * `payload` is payload associated to point. 
 * `weight` is number of points aggregated, when clicking on a cluster icon, 1 if single point
 * 
 * @return {H.map.layer.ObjectLayer}  layer created
 * 
 * @example
 * ```js
 * let pois = [[48.8,2.3,"Hello world"],[48.5,2.4,"How are you"],[45.2,2.93,"Very well"]];
 * 
 * hm.cluster(pois);
 * 
 * // with more graphic options and callback defined
 *   let opt = {
 *    noise: {
 *          icon: "mcdo.png",
 *          size: 12
 *      },
 *    cluster: {
 *       200: {
 *           icon: "@svg/cluster_red.svg",
 *           size: 64
 *       },
 *       75: {
 *           icon: "@svg/cluster_orange.svg",
 *           size: 52
 *       },
 *       2: {
 *           icon: "@svg/cluster_green.svg",
 *           size: 40
 *        }
 *    }
 *   };
 *  hm.cluster(pois, opt,
 *           (event, coordinate, data, weight) => {
 *               if (data)
 *                   console.log("click on point ", data);
 *               else
 *                   console.log("click on cluster with weight", weight);
 *           });
 * ```
 */
async function cluster(coords, opt, cb = null) {

    let dataPoints = [];
    map = m.getMap();
    let _home = cm.getHome();

    let settings = {
        eps: 64,
        minZoom: 1, // min zoom
        maxZoom: 24, // max zoom
        noise: {
            icon: _home + "svg/bluedot.svg",
            size: 16
        },
        cluster: {
            200: {
                icon: _home + "svg/cluster_red.svg",
                color: "#B50015",
                size: 64
            },
            75: {
                icon: _home + "svg/cluster_orange.svg",
                color: "#FF6900",
                size: 48
            },
            2: {
                icon: _home + "svg/cluster_green.svg",
                color: "#7BD30A",
                size: 40

            }
        }
    };
    if (opt)
        Object.assign(settings, opt);

    let useTheme = true; // do we use our own theme ?
    if (!opt || (opt && !opt.noise && !opt.cluster))
        useTheme = false;

    coords.forEach(coord => {
        // use op_weight of 1 for each coord
        // provides all coord as data
        let dp = new H.clustering.DataPoint(coord[0], coord[1], 1, coord);
        dataPoints.push(dp);

    });

    let minWeight = 2; // minimum weight by default

    if (useTheme) {

        // creating icon for noise (individual point)
        let icon = settings.noise.icon;
        if (icon[0] == "@") // to indicate local
            icon = cm.getHome() + icon.substr(1);

        let iconOpt = null;
        if (settings.noise.size)
            iconOpt = {
                size: {
                    w: settings.noise.size,
                    h: settings.noise.size
                }
            };
        iconNoise = new H.map.Icon(icon, iconOpt);

        // get list of weight
        let weightOrder = Object.keys(settings.cluster).sort(function (a, b) {
            return b - a;
        });
        // minweight is the smallest weight
        minWeight = weightOrder[weightOrder.length - 1];

        let promises = [];
        clusterStyle = weightOrder.map((weight) => {
            let size = settings.cluster[weight].size;
            let icon = settings.cluster[weight].icon;
            if (icon[0] == "@") // to indicate local
                icon = cm.getHome() + icon.substr(1);

            let p = loadIconFile(icon, size, size);
            promises.push(p);
            let entry = {
                weight: parseInt(weight),
                icon: icon
            };
            return entry;
        });

        // wait for all promises to be resolved
        const result = await Promise.all(promises);
        // associated to each entry of clusterstyle
        result.forEach((imageData, i) => {
            clusterStyle[i].imageData = imageData;
        });

    }


    let optProvider = {
        clusteringOptions: {
            // Maximum radius of the neighborhood
            eps: settings.eps,
            // minimum weight of points required to form a cluster
            minWeight: minWeight
        },
        min: settings.minZoom, // min zoom
        max: settings.maxZoom // max zoom
    };

    // if we use our own theme
    if (useTheme)
        optProvider.theme = {
            getClusterPresentation: getClusterPresentation,
            getNoisePresentation: getNoisePresentation
        };

    // create cluster provider
    clusteredDataProvider = new H.clustering.Provider(dataPoints, optProvider);

    // Create a layer that includes the data provider and its data points:
    clusterLayer = new H.map.layer.ObjectLayer(clusteredDataProvider);
    // Add the layer to the map:
    map.addLayer(clusterLayer);

    // layer is visible by default
    _visible = true;

    // if a callback is defined, add event listener
    if (cb) {
        clusteredDataProvider.addEventListener("tap", function (ev) {
            // Log data bound to the marker that has been tapped:
            let data = ev.target.getData();
            let coord = map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            let isCluster = data.isCluster();

            if (isCluster) {
                let weigth = data.getWeight();
                cb(ev, m.coordO2A(coord), null, weigth);
            } else {
                let userData = data.getData(); // lat,lng, payload
                cb(ev, m.coordO2A(coord), userData[2], 1);
            }
        });
    }

    return clusterLayer;
}



// this function  creates the icon for a cluster
function getClusterPresentation(cluster) {

    // building data object which will be returned when clicking on the icon
    let data = {};
    data.isCluster = () => {
        return true;
    }; // so we know it is a cluster
    let weight = cluster.getWeight();

    data.getWeight = () => {
        return weight;
    }; // number of individual item clustered together

    // let's find the relevant color and size
    let entry = clusterStyle.find(elt => (weight >= elt.weight));
    let imageData = entry.imageData;

    let icon = buildClusterIcon(imageData, "" + weight);
    // create a marker for the Cluster
    let min = cluster.getMinZoom();
    let max = cluster.getMaxZoom();
    let clusterMarker = new H.map.Marker(cluster.getPosition(), {
        // to show it correctly at certain zoom levels:
        min: min,
        max: max,
        icon: icon,
    });

    // Link data from the from the cluster to the marker,
    // to make it accessible on callback
    clusterMarker.setData(data);

    return clusterMarker;
}

// function to represent a single item
function getNoisePresentation(noisePoint) {

    // data to be sent on callback
    const data = {
        getData: () => {
            return noisePoint.getData();
        },
        isCluster: () => {
            return false;
        },
        getWeight: () => {
            return 1;
        }
    };

    // Create a marker for the noisePoint
    var noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
        // Use min zoom from a noise point
        // to show it correctly at certain zoom levels:
        min: noisePoint.getMinZoom(),
        icon: iconNoise
    });

    // Link a data from the point to the marker
    // to make it accessible on callback
    noiseMarker.setData(data);

    return noiseMarker;
}



/**
 * load a file into a canvas
 * @ignore
 * @param {String} url of png,jpg,svg file 
 * @param {Number} width for svg, define width
 * @param {number} height for svg, define height
 */
function loadIconFile(file, width = null, height = null) {
    return new Promise(
        (resolve) => {
            var newImg = new Image;
            newImg.onload = function () {
                let width = newImg.width;
                let height = newImg.height;
                // copy icon into a canvas
                let src = document.createElement("canvas");
                src.width = width;
                src.height = height;
                let ctx = src.getContext("2d");

                // copy image into canvas cluster
                ctx.drawImage(newImg, 0, 0, width, height);
                let imageData = ctx.getImageData(0, 0, width, height);

                resolve(imageData);
            };

            newImg.crossOrigin = "Anonymous"; // useful.. ?
            if (width) newImg.width = width;
            if (height) newImg.height = height;

            newImg.src = file;

        }
    );
}

/**
 * Build an icon by copying imageData and adding text
 * @ignore
 * @param {ImageData} imgData  from canvas.getImageData
 * @param {String} text  text to write
 */
function buildClusterIcon(imgData, text) {
    const canvas = document.createElement("canvas");
    canvas.width = imgData.width;
    canvas.height = imgData.height;
    let ctx = canvas.getContext("2d");
    const fontSize = 12;

    ctx.font = "bold " + fontSize + "px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";

    ctx.putImageData(imgData, 0, 0);
    ctx.fillText(text, canvas.width / 2, (canvas.height + fontSize) / 2 - 2);

    return new H.map.Icon(canvas, {
        anchor: {
            x: canvas.width / 2,
            y: canvas.height / 2
        }
    });
}



/**
 * Hide cluster layer
 *  @alias hm:clusterHide
 */
function clusterHide() {
    if (!_visible || !clusterLayer)
        return;

    map.removeLayer(clusterLayer);
    _visible = false;
}

/**
 * Show Cluster layer
 * @alias hm:clusterShow
 */
function clusterShow() {
    if (_visible || !clusterLayer)
        return;

    map.addLayer(clusterLayer);
    _visible = true;

}



module.exports = {
    cluster: cluster,
    clusterShow: clusterShow,
    clusterHide: clusterHide
};
},{"./common.js":3,"./map.js":6}],3:[function(require,module,exports){
(function (process){
"use strict";
/* global document */

/**
 * @file generic function of heremap
 * @author devbab
 */

const request = require("superagent");

// by default, unless specified fby calling config
// environment usable with node
let APP_ID = process.env.APP_ID;
let APP_CODE = process.env.APP_CODE;
let CIT = ""; // production by default
let PROTOCOL = "https:"; // by default
let _useHTTPS = true; // by default
let _home = ".";


// find out where we are and relative position for png/svg files
// pay attention if library is build in ./dist
if (process.browser) {
    let _script = document.getElementsByTagName("script");
    let _file = _script[_script.length - 1].src;
    let _path = _file.substring(0, _file.lastIndexOf("/"));
    let pos = _path.indexOf("heremap");
    _home = _path.substring(0, pos + "heremap".length) + "/";

}

/**
 * To configure app_id, app_code and optionally use CIT and http
 * @alias hm:config
 *
 * @param opt {Object}  - `opt` with parameters.
 * @param [opt.app_id] {string} - the app_id from developer.here.com
 * @param [opt.app_code] {string} - the app_code from developer.here.com
 * @param [opt.useCIT=false] {boolean} - true to use CIT environment. 
 * @param [opt.useHTTP=false] {string} - true to use HTTP. 
 * @param [opt.useHTTPS=true] {string} - true to use HTTPS. 
 *
 * @example
 * ```js
 *  hm.config({
 *      app_id: "YOUR APP_ID",
 *      app_code: "YOUR APP_CODE",
 *   });
 *  ```
 */
function config(opt) {
    if (opt.app_id) APP_ID = opt.app_id;
    if (opt.app_code) APP_CODE = opt.app_code;
    if (opt.useCIT) CIT = ".cit";
    if (opt.useHTTP) {
        PROTOCOL = "http:";
        _useHTTPS = false;
    }
    if (opt.useHTTPS) {
        PROTOCOL = "https:";
        _useHTTPS = true;
    }
}

/**
 * return URL of module home directory. 
 * svg icons are under getHome()+"/svg/"
 * images are under getHome()+"/img/"
 * @ignore
 *  @alias hm:getHome
 * @return {string} url of home directory including http or https. 
 */
function getHome() {
    return _home;
}

/**
 * returns app_id
 * @ignore
 *  @alias hm:getAppId
 * @return {string} app_id
 */
function getAppId() {
    return APP_ID;
}

/**
 * return app_code
 *  @ignore
 *  @alias hm:getHome
 *  @alias hm:getAppCode
 * @return {string} app_code
 */
function getAppCode() {
    return APP_CODE;
}

/**
 * return true if using CIT
 * @ignore
 * @alias hm:getCIT
 * @return {booolean} true if using CIT
 */
function getCIT() {
    return CIT;
}

/**
 * return protocol used, http:// or https://
 * @ignore
 * @alias hm:getProtocol
 * @return {string} - protocol
 */
function getProtocol() {
    return PROTOCOL;
}

/**
 * return true is https is used
 * @ignore
 *  @alias hm:useHTTPS
 * @return {boolean} - true if https is used
 */
function useHTTPS() {
    return _useHTTPS;
}

/**
 * add credentials to object provided
 * @ignore
 *  @alias hm:addCredentials
 * @param  {...objects} list of `objects` 
 * @return {object} object with all input objectconcatenated, and app_id/app_code inserted
 */
function addCredentials(...obj) {
    return Object.assign({
        app_id: APP_ID,
        app_code: APP_CODE
    }, ...obj);
}

/**
 * build HERE REST full url, taking in account protocol and cit. for instance  cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json"
 * @ignore
 * @alias hm:buildUrl
 * @param {string} base - base name
 * @param {string} endpoint - end point
 * @return {string} full url
 */
function buildUrl(base, endpoint) {
    return PROTOCOL + "//" + base + CIT + "." + endpoint;
}

/**
 * does get/post request to HERE RESDT backend and manage main errors
 * @ignore
 * @alias hm:hereRest
 * @param {string} url  - url to call , for instance from buildUrl
 * @param {object} settings - settings to add in request
 * @param  {string} mode=get - mode "get" or "post"
 * @return {promise} - promise to resolve/reject
 */
async function hereRest(url, settings, mode = "get", needresp = "true") {

    let p = request.get(url);
    if (mode == "post")
        p = request.post(url);

    return p
        .query(settings)
        .then(res => {
            // res.body, res.headers, res.status
            if (res.status != "200") {
                let e = new Error("Error " + res.status + ":" + res.body); // e.message
                throw (e);
            }

            if (needresp && !res.body.Response && !res.body.response) { // one of the two should be in the answer
                console.error(res.body);
                let e = new Error("Query error:" + res.body); // e.message
                throw (e);
            }

            if (res.body.response && res.body.response.type == "ApplicationError") {
                console.error(res.body);
                let e = new Error("Error" + res.body.response.details); // e.message
                throw (e);
            }

            return res;
        });
}




module.exports = {
    config: config,
    buildUrl: buildUrl,
    getAppId: getAppId,
    getAppCode: getAppCode,
    getCIT: getCIT,
    getProtocol: getProtocol,
    getHome: getHome,
    useHTTPS: useHTTPS,
    addCredentials: addCredentials,
    hereRest: hereRest
};
}).call(this,require('_process'))

},{"_process":1,"superagent":10}],4:[function(require,module,exports){
/**
 * @file Geocoding functions : addresses <--> [lat,lng]
 * @author Devbab 
 */

"use strict";
const cm = require("./common.js");

/**
 * geocode an address
 * @alias hm:geocode
 * @param address {string}  address as string
 * @returns  {Promise}   {coord,body}. coord is geocode as \[lat,lng\]. body is full json answer
 * 
 * @example
 * ```js
 * const res = await hm.geocode("avenue des chaps elysees, paris");
 * console.log (res.coord);
 * ```
 */
function geocode(address) {

    const settings = cm.addCredentials({
        searchText: address
    });

    const url = cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json");
    return cm.hereRest(url, settings)
        .then(res => {

            if (res.body.Response.View.length == 0) {
                let e = new Error("Geocode Address not found: " + address); // e.message
                throw (e);
            }

            var location = res.body.Response.View[0].Result[0].Location;
            var coord = [location.NavigationPosition[0].Latitude, location.NavigationPosition[0].Longitude];
            return { coord: coord, body: res.body };
        });
}


/**
 * reverse geocode a coordinate
 * @alias hm:reverseGeocode
 * @param coord {Coord}  - coord \[lat,lng\] to reverse-geocode
 * @returns  {Promise} returns { location:object, address:object, body:object}. 
 */
function reverseGeocode(coord) {

    const settings = cm.addCredentials({
        mode: "retrieveAddresses",
        prox: coord[0] + "," + coord[1]
    });

    const url = cm.buildUrl("reverse.geocoder", "api.here.com/6.2/reversegeocode.json");

    return cm.hereRest(url, settings)
        .then(res => {
            // res.body, res.headers, res.status
            var location = res.body.Response.View[0].Result[0].Location;
            return ({ location: location, address: location.Address, body: res.body });
        });
}


module.exports = {
    geocode: geocode,
    reverseGeocode: reverseGeocode
};


},{"./common.js":3}],5:[function(require,module,exports){
const simplifyJs = require("simplify-js");

/**
 * Convert array of [lat,lng] to array of {x,y}
 * @alias hm:coords2XY
 * @param {array} coords array of [lat,lng]
 * @return {array}array of {x,y}
 */
function coords2XY(coords) {
    return coords.map(coord => {
        return {
            x: coord[1],
            y: coord[0]
        };
    });
}
/**
 * Convert array of {x,y} to array of [lat,lng]
 * @alias hm:xy2Coords
 * @param {array} coords array of {x,y} 
 * @return {array}array of [lat,lng]
 */
function xy2Coords(xys) {
    return xys.map(xy => [xy.y, xy.x]);
}



/**
 * Convert an object {lat,lng} to [lat,lng]
 * @alias hm:coordO2A
 * @param {object} obj {lat,lng}
 * @return {array} [lat,lng]
 */
function coordO2A(obj) {
    return [obj.lat, obj.lng];
}

/**
 * Convert an array [lat,lng] to {lat,lng}
 * @alias hm:coordA2O
 * @param {object} arr [lat,lng]
 * @return {array} {lat,lng}
 */
function coordA2O(arr) {
    return {
        lat: arr[0],
        lng: arr[1]
    };
}


/**
 * Convert [lat,lng] to {lat,lng}
 * @alias hm:coord2Point
 * @param {array} [lat,lng]
 * @return {array}{lat,lng}
 */
function coord2Point(coord) {
    return {
        lat: coord[0],
        lng: coord[1]
    };
}
/**
 * Convert {lat,lng} to [lat,lng]
 * @alias hm:point2Coord
 * @param {array} {lat,lng} 
 * @return {array}[lat,lng]
 */
function point2Coord(point) {
    return [point.lat, point.lng];
}




/**
 * Simplify a polyline by using the Ramer-Douglas-Peucker algorithm
 * @alias hm:simplify
 * @param {array} coords array of [lat,lng]
 * @param {number} tolerance 
 * @return {array} simplified polyline
 */
function simplify(coords, tolerance, highacc = false) {

    // convert to xy
    let xy = coords2XY(coords);
    let simplified = simplifyJs(xy, tolerance, highacc);

    if (simplified.length < 1) // not enough points
        return coords;

    // convert back to [lat,lng]
    return xy2Coords(simplified);
}



module.exports = {
    coordO2A: coordO2A,
    coordA2O: coordA2O,
    coords2XY: coords2XY,
    xy2Coords: xy2Coords,
    coord2Point: coord2Point,
    point2Coord: point2Coord,
    simplify: simplify
};
},{"simplify-js":8}],6:[function(require,module,exports){
/* global H, fetch, window, document, navigator, mapsjs, window APP_ID_JAPAN,APP_CODE_JAPAN,APP_ID_KOREA,APP_CODE_KOREA*/


"use strict";
const cm = require("./common.js");
const g = require("./geometry.js");

let _platform = null;
let _provider = null;
let _defaultLayers = null;
let _ui = null;
let _map = null;
let _behavior = null;
let group = null;
let _layers = []; // list all layers
let _key = {}; // keys  
let _bubbleMarker = null; // bubble de mamrker
let _scheme = "normal.day.grey";
let _locateMe = null; // id when locate is active
let _htmlItem = null; //the html item on which to put the map
let _htmlItemId = null; //the id of html item on which to put the map




/**
 * create a map area within the specified item
  * @alias hm:map

 * @param htmlItem {string}  - identifier of html div item on which to insert map
 * @param opt {object}  - options
 * @param [opt.zoom=10] {number}  - zoom factor
 * @param [opt.center=[48.86, 2.3]] {Coord}  - Coord of the center
 * @param [opt.scheme=normal.day.grey] {string}  - any scheme defined by HERE, plus "japan", "korea", "black", "white", "transparent". For japan/korea, one needs special credentials as APP_ID_JAPAN APP_KOREA APP_CODE_JAPAN APP_CODE_KOREA
 * @param [opt.click=null] {function()}  - callback on mouse click: callback(coord,button,key)
 * @param [opt.dbClick=null] {function()}  - callback on mouse double click: callback(coord,button,key)
 * @param [opt.clickLeft=null] {function}  - callback on mouse click left: callback(coord,button,key)
 * @param [opt.clickRight=null] {function()}  - callback on mouse click right.: callback(coord,button,key)
 * @param [opt.keyDown=null] {function}  - callback on key down : callback(key)
 * @param [opt.viewChange=null] {function}  - callback if map is panned or zoomed : callback(zoom,coordCenter)
 * @param [opt.loadTile=null] {function}  - callback when a tile is loaded : callback(z,x,y,url)
 * @param [opt.rendered=null] {function}  - callback when render is completed : callback(event)
 *
 * @example
 * ```js
 * const hm = window.heremap;
 * 
 * hm.config({
 *    app_id: "YOUR APP_ID",
 *    app_code: "YOUR APP_CODE",
 * });
 *
 * hm.map("map", {
 *    zoom:5,
 *    center: [48.8,2.3],
 *    click: function(coord,button,key) {console.log("clicked on",coord,"with button",button);}
 * });
*  ```
*/
function map(htmlItem, opt) {

    _htmlItem = htmlItem;
    _htmlItemId = document.getElementById(htmlItem);

    let settings = {
        zoom: 10,
        center: [48.86, 2.3],
        clickLeft: null,
        clickRight: null,
        keyDown: null, // keyboard event
        click: null,
        dbClick: null,
        viewChange: null, // (zoom,coord)
        render: null, // ()
        loadTile: null // quand une tile est affichée
    };

    let mps = 1;

    let app_id = cm.getAppId();
    let app_code = cm.getAppCode();

    if (!app_id || !app_code) {
        // console.log("app_id/app_code not initialised");
        _htmlItemId.innerHTML = "app_id/app_code not initialised";
        return;
    }

    _platform = new H.service.Platform({
        app_id: app_id,
        app_code: app_code,
        useCIT: cm.getCIT(),
        useHTTPS: cm.useHTTPS()
    });

    Object.assign(settings, opt);
    if (settings.scheme)
        _scheme = settings.scheme; // store scheme if defined

    // white background for test
    let searchParams = new URLSearchParams(window.location.search);
    if (searchParams.get("demotest") == 1) _scheme = "white";


    _defaultLayers = _platform.createDefaultLayers();

    // http://heremaps.github.io/examples/explorer.html#map-tiles__base-map-styles-and-modes
    _provider = new H.map.provider.ImageTileProvider({
        label: "Base Provider",
        descr: "",
        min: 0,
        max: 20,
        crossOrigin: "anonymous",
        getURL: function (col, row, level) {
            mps++;
            if (mps > 4) mps = 1;
            let url = [cm.getProtocol(), "//", mps, ".base.maps" + cm.getCIT() + ".api.here.com/maptile/", "2.1",
                "/", "maptile", "/", "newest", "/",
                _scheme, "/", level, "/", col, "/", row, "/", "256",
                "/", "png", "?lg=", "FRE",
                "&app_code=", app_code, "&app_id=",
                app_id
            ].join("");

            if (_scheme == "japan")
                url = [cm.getProtocol(), "//", "m.lbs" + cm.getCIT() + ".api.heremaps.jp/v1/map?app_id=",
                    APP_ID_JAPAN,
                    "&app_code=",
                    APP_CODE_JAPAN,
                    "&tilematrix=EPSG:900913:",
                    level,
                    "&tilecol=",
                    col,
                    "&tilerow=",
                    row
                ].join("");

            else if (_scheme == "korea")
                url = [cm.getProtocol(), "//", "3.base.maps" + cm.getCIT() + ".api.heremaps.kr/maptile/2.1/maptile/34439348c3/normal.day/",
                    "/", level, "/", col, "/", row, "/", "256",
                    "/", "png", "?lg=", "FRE",
                    "&app_code=", APP_CODE_KOREA, "&app_id=",
                    APP_ID_KOREA
                ].join("");

            else if (_scheme == "black")
                url = cm.getHome() + "png/black.png";
            else if (_scheme == "white")
                url = cm.getHome() + "png/white.png";
            else if (_scheme == "transparent")
                url = cm.getHome() + "png/transparent.png";


            if (settings.loadTile)
                settings.loadTile(level, col, row, url);

            return url;
        }


    });

    let __layer = new H.map.layer.TileLayer(_provider);

    //console.log("normal map");
    //Step 2: initialize a HEREMap 
    _map = new H.Map(document.getElementById(htmlItem),
        __layer, {
            center: g.coordA2O(settings.center),
            zoom: settings.zoom
        });

    _behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(_map));

    // Create the default UI components
    _ui = H.ui.UI.createDefault(_map, _defaultLayers);

    // create default layer
    layerCreate("default");

    // if callback on zoom Change
    if (settings.viewChange) {
        _map.addEventListener("mapviewchangeend", function () {
            let bound = _map.getViewBounds();
            let lat = (bound.ka + bound.ja) / 2;
            let lng = (bound.ga + bound.ha) / 2;

            //console.log("viewChange center " + lat + " " + lng);
            settings.viewChange(_map.getZoom(), [lat, lng]);
        });
    }

    /***********************           to handle keyboard while mouse in map        ***********************/
    let kup = function () {
        _key.ctrl = false;
        _key.shift = false;
        _key.alt = false;
        _key.key = "";
    };

    let kdown = function (e) {
        _key.ctrl = ((e.key == "Control") || (e.keyIdentifier == "Control") || (e.ctrlKey == true));
        _key.shift = ((e.key == "Shift") || (e.keyIdentifier == "Shift") || (e.shiftKey == true));
        _key.alt = ((e.key == "Alt") || (e.keyIdentifier == "Alt") || (e.shiftKey == true));
        _key.key = e.key;
        if (settings.keyDown) settings.keyDown(_key);
    };

    _map.addEventListener("mouseenter", function () {
        // console.log("map mouse enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });

    _map.addEventListener("pointerenter", function () {
        //console.log("map pointer enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });
    _map.addEventListener("mouseleave", function () {
        // console.log("map mouse leave");
        document.removeEventListener("keydown", kdown);
        document.removeEventListener("keyup", kup);
    });

    /***********************           to handle double click         ***********************/
    _map.addEventListener("dbltap", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) return; // don't do anything if click on marker

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;
        if (settings.dbClick) {
            switch (button) {
                case 0:
                    settings.dbClick(g.coordO2A(coord), "left", _key);
                    break;
                case 2:
                    settings.dbClick(g.coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /***********************           to handle simple click         ***********************/
    _map.addEventListener("tap", function (ev) {
        let target = ev.target;

        if (target instanceof H.map.Marker) return;

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;

        if ((button == 0) && (settings.clickLeft))
            settings.clickLeft(g.coordO2A(coord), "left", _key);
        if ((button == 2) && (settings.clickRight))
            settings.clickRight(g.coordO2A(coord), "right", _key);
        if (settings.click) {
            switch (button) {
                case 0:
                    settings.click(g.coordO2A(coord), "left", _key);
                    break;
                case 2:
                    settings.click(g.coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /*********  disable the default draggability of the underlying map when starting to drag a marker object *****************/
    _map.addEventListener("dragstart", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker || target instanceof H.map.DomMarker) {
            _behavior.disable();
        }

    }, false);

    /************   re - enable the default draggability of the underlying map when dragging has completed ***********************/
    _map.addEventListener("dragend", function (ev) {

        let target = ev.target;
        if (target instanceof mapsjs.map.Marker || target instanceof mapsjs.map.DomMarker) {
            _behavior.enable();

            if (target.droppable)
                return;

            if (target.dragged) {
                let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
                (target.dragged)(target, g.coordO2A(coord));
            }
        } else if (settings.drag) {
            (settings.drag)("dragend");
        }

    }, false);

    /***********************  Listen to the drag event and move the position of the marker as necessary *******************/
    _map.addEventListener("drag", function (ev) {
        let target = ev.target,
            pointer = ev.currentPointer;

        if (target instanceof mapsjs.map.Marker || target instanceof mapsjs.map.DomMarker) {

            if (target.droppable) // don't move the marker if droppable
                return;
            target.setPosition(_map.screenToGeo(pointer.viewportX, pointer.viewportY));
        } else if (settings.drag) {
            (settings.drag)("drag");
        }

    }, false);


    /****************  detect map resize and adjust accoridngly ******************************/
    window.addEventListener("resize", function () {
        _map.getViewPort().resize();
    });

    /****************  callback for rendering ******************************/
    if (settings.rendered) {
        _map.getEngine().addEventListener("render", (ev) => {
            if (_map.getEngine() === ev.target) {
                settings.rendered(ev);
            }
        });
    }

    return _map;
}

/**
 * list of all available map styles normal.day, night.... 
 * @alias hm:getAvailableMapStyle
 * @return {json} list of map styles as json
 */
function getAvailableMapStyle() {
    // https://1.base.maps.api.here.com/maptile/2.1/info?xnlp=CL_JSMv3.0.17.0&app_id=nOSh21214JFMSEPQkqno&app_code=rX_l7YvALtNkqU2bx5FWEA&output=json

    const settings = cm.addCredentials({
        output: "json"
    });

    const url = cm.buildUrl("1.base.maps", "api.here.com/maptile/2.1/info");
    return cm.hereRest(url, settings)
        .then(res => {
            return res.body.response;
        });
}

/**
 * define the scheme. List of scheme can be obtained from hm.getAvailableMapStyle()
 * @alias hm:setScheme
 * @param {string} scheme scheme name
 */
function setScheme(scheme) {
    _scheme = scheme;
}

/**
 * create a layer
 * @alias hm:layerCreate
 * @param {string} name  - name of layer
 * @param {boolean} visible  - initial status
 * @example
 * ```js
 * hm.layerCreate("layer1");
 *  ```
 */
function layerCreate(name, visible) {
    group = new H.map.Group();
    group.name = name;
    _map.addObject(group);

    // push into list of layers
    _layers.push(group);

    // can be visible or hidden
    if (typeof visible != "undefined")
        group.setVisibility(visible);

    return group;
}

/**
 * delete a layer
 * @alias hm:layerDelete
 * @param {String} name name of layer
 */
function layerDelete(name) {
    let layer = layerFind(name);
    if (!layer)
        return;

    // remove group from map
    _map.removeObject(layer);
    //remove form list of layers
    _layers = _layers.filter(item => {
        return item.name !== name;
    });
}

/**
 * Empty a layer, or create it if not existing
 * @alias hm:layerEmpty
 * @param {string} layer 
 */
function layerEmpty(name) {
    let layer = layerFind(name);
    if (!layer) {
        layerCreate(name);
        return;
    }
    layer.removeAll();
}

/**
 * create a layer
 * @alias hm:layerSetVisibility
 * @param {string} name  - name of layer
 * @param {boolean} visible  - visible or not
 * @example
 * ```js
 * hm.layerVisible("layer1",true);
 *  ```
 */
function layerSetVisibility(name, visible) {
    let layer = layerFind(name);
    if (!layer)
        return;

    layer.setVisibility(visible);

}

/**
 * find layer by its name or return null 
 * @alias hm:layerFind
 * @param {string} name 
 */
function layerFind(name) {
    let l = _layers.find(layer => {
        return layer.name == name;
    });
    if (typeof l == "undefined") return null;
    return l;
}


/**
 * set center of the map
 * @alias hm:setCenter
 * @param {Array} - coord as [lat,lng]
 * * @example
 * ```js
 * hm.setCenter([48.8,2.3]);
 *  ```
 */
function setCenter(coord) {
    _map.setCenter(g.coordA2O(coord));
}

/**
 * return coordinate of the center of the map
 * @alias hm:getCenter
 * @returns {coord} coord of the center as \[lat,lng\]
 */
function getCenter() {
    let bound = _map.getViewBounds();
    //_HM.log("viewbound",bound);

    let lng = (bound.ga + bound.ha) / 2;
    let lat = (bound.ka + bound.ja) / 2;
    return [lat, lng];

}

/**
 * return bounding box of visible part of map
 * @alias hm:getViewBB
 * @returns {Object} bouding box of visible part of the map, as \[latm,latM,longm,lngM\]
 */
function getViewBB() {
    let bb = _map.getViewBounds();

    let bb2 = {
        latm: bb.ja,
        latM: bb.ka,
        lngm: bb.ga,
        lngM: bb.ha
    };
    return bb2;
}

/**
 * sets bouding box to be displayed
 * @alias hm:setViewBB
 * @param opt {Object| string}  either an object specifying how to set bounding box, or  a String being the name of a layer
 * @param [opt.layer] {string} bouding box aroud all objects of the layer
 * @param [opt.pois] {array} bouding box aroud all coords defined as \[coord,coord...\]
 * @example
 * ```js
 * hm.setViewBB("layer1");
 *
 * hm.setViewBB({
 *    pois: coords
 * });
 *  ```
 */
function setViewBB(opt) {

    if (typeof opt == "string")
        opt = {
            layer: opt
        };

    let settings = {
        layer: null,
        pois: null // array of [lat,lng]
    };
    Object.assign(settings, opt);

    let bbox;

    //set BB based on layer
    if (settings.layer) {
        let layer = layerFind(settings.layer);
        if (!layer) return;

        // get view bound and add a bit around, like 1/5
        let bb = layer.getBounds();
        if (!bb) // as if nothing in layer
            return;
        bb.latm = bb.ja;
        bb.latM = bb.ka;
        bb.lngm = bb.ga;
        bb.lngM = bb.ha;
        let dx = bb.lngM - bb.lngm;
        let dy = bb.latM - bb.latm;
        dx = dx / 5;
        dy = dy / 5;
        bb.latM += dy;
        bb.lngm -= dx;
        bb.latm -= dy;
        bb.lngM += dx;
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);

    } else if (settings.pois) {
        let bb = {
            latM: 0,
            lngm: 180,
            latm: 90,
            lngM: -180,
        };
        let arr = settings.pois;
        arr.forEach((poi) => {
            if (poi[0] > bb.latM) bb.latM = poi[0];
            if (poi[1] > bb.lngM) bb.lngM = poi[1];
            if (poi[0] < bb.latm) bb.latm = poi[0];
            if (poi[1] < bb.lngm) bb.lngm = poi[1];
        });
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);
    }
}


/**
 * return zoom value
 * @alias hm:getZoom
 * @returns {number} zoom level
 */
function getZoom() {
    return _map.getZoom();
}

/**
 * set zoom level
 * @alias hm:setZoom
 * @param {number} zoom 
 */
function setZoom(zoom) {
    _map.setZoom(zoom);
}


/**
 * Display a unique bubble. Associated CSS style is .H_ib_body
 * @alias hm:bubbleUnique
 * @param {Array} coord of the bubble
 * @param {String} txt html text to display
 */
function bubbleUnique(coord, txt) {

    if (!_bubbleMarker) {
        _bubbleMarker = new H.ui.InfoBubble(
            g.coordA2O(coord), {
                content: txt
            });

        _ui.addBubble(_bubbleMarker);
        _bubbleMarker.addClass("bubbleUnique");

    } else {
        _bubbleMarker.setPosition(g.coordA2O(coord));
        _bubbleMarker.setContent(txt);
        _bubbleMarker.open();
    }

}


/**
 * hide a unique bubble
 * @alias hm:bubbleUniqueHide
 */
function bubbleUniqueHide() {
    if (!_bubbleMarker)
        return;
    _bubbleMarker.close();
}



/**
 * create an icon, to be used for a marker
 * @async
 * @alias hm:buildIcon
 * @param opt {object} options to specify the icon
 * @param [opt.img] {string}  use a png/jpg image. Specify the url 
 * @param [opt.svg] {string}  url a svg. This can be an inline svg, a url, or a svg from heremap
 * @param [opt.opt] {object}   style object
 * @param [opt.opt.size] {number|string}   size of icon, as 24 or 24x32
 * @param [opt.opt.ratio] {number}   for svg files, ratio of size. 0.5 = half
 * @param [opt.opt.anchor] {number|string}   anchor of icon, as 24 or "24x32" or "center". By default, bottom-center
 * @param [opt.opt.tag] {string}  for svg, any tag like {tag} within the svg file will be replaced by its associated value
 * @return {H.map.Icon} the created icon
 * @example 
 * ```js
 * hm.buildIcon({
 *    img: "http://whatever.com/image.png",
 *    opt: {size:24}
 * });
 * 
 * hm.buildIcon({
 *    svg: "http://whatever.com/image.svg",
 *    opt: {
 *       ratio:0.5,
 *       anchor:24x32
 *    }
 * });
 *  
 * hm.buildIcon({
 *    svg: "@svg/cluster.svg",
 *    opt: {
 *       size:24,
 *       color:"red"
 *    }
 * });
 * 
 * const svg = `<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"> <ellipse stroke="null" ry="8" rx="7.618896" id="svg_1" cy="8" cx="7.837427" fill="{color}" fill-opacity="0.9"/></svg>`;
 * hm.buildIcon({
 *    svg: svg,
 *    opt: {
 *       size:24,
 *       color:"red"
 *    } 
 * });
 *  ```
 */
async function buildIcon(opt) {
    let settings = {
        img: null, //   png, jpg. if not http in the beginning, look locally
        svg: null, // svg file:  is a url or a string
        opt: null, // size, color, anchor, text...s
    };

    Object.assign(settings, opt);

    if (!settings.img && !settings.svg) {
        return null;
    }

    let icon, iconSrc;

    if (settings.img) {
        // console.log("settings.img", settings.img);

        if (settings.img[0] == "@") // to indicate local
            iconSrc = cm.getHome() + settings.img.substr(1);
        else
            iconSrc = settings.img; // local file

    } else if (settings.svg) {

        let url = null;
        iconSrc = settings.svg;
        if (settings.svg[0] == "@") // local 
            url = cm.getHome() + settings.svg.substr(1);
        else if (settings.svg.substr(0, 4) == "<svg") // url
            url = null;
        else
            url = settings.svg; // not embedded string, should be a url

        if (url) { // an url to download
            iconSrc = await fetch(url)
                .then(res => {
                    if (res.status != 200)
                        return null;
                    return res.text();
                });
        }

    }

    let iconOpt = {
        crossOrigin: true
    }; // to avoid issued with capture
    if (settings.opt && settings.opt.size) {
        let w, h;
        if (typeof settings.opt.size == "number")
            w = h = settings.opt.size;
        else
            [w, h] = settings.opt.size.split("x");

        iconOpt.size = {
            w: w,
            h: h
        };
    }

    function _getsizeSvg(iconSrc) {
        let w = null,
            h = null,
            match;
        let r = /width="(\d+)"/;
        match = iconSrc.match(r);
        if (match) w = match[1];

        r = /height="(\d+)"/;
        match = iconSrc.match(r);
        if (match) h = match[1];
        return [w, h];
    }

    if (settings.svg && settings.opt && settings.opt.ratio) {
        let w = null,
            h = null;
        [w, h] = _getsizeSvg(iconSrc);

        iconOpt.size = {
            w: Math.floor(w * settings.opt.ratio),
            h: Math.floor(h * settings.opt.ratio)
        };
    }

    if (settings.opt && settings.opt.anchor) {
        let x = null,
            y = null;
        if (typeof settings.opt.anchor == "number")
            x = y = settings.opt.anchor;
        else if (settings.opt.anchor == "center" && settings.svg) { // for svg file only center: get size of split in 2
            [x, y] = _getsizeSvg(iconSrc);
            x /= 2;
            y /= 2;
        } else
            [x, y] = settings.opt.anchor.split("x");

        if (!x || !y) {
            let e = new Error("BuildIcon: incorrect anchor"); // e.message
            throw (e);
        }
        iconOpt.anchor = {
            x: x,
            y: y
        };
    }

    // all other fields are treated as graphic enhanceent
    if (settings.opt) {
        for (let name in settings.opt) {
            if (name == "file" || name == "size" || name == "anchor") continue;
            let re = new RegExp("{" + name + "}", "g");
            iconSrc = iconSrc.replace(re, settings.opt[name]);
        }
    }

    // console.log("iconSrc", iconSrc);
    // console.log("iconOpt", iconOpt);
    icon = new H.map.Icon(iconSrc, iconOpt);

    return icon;

} //end of icon





/**
 * add a marker in a layer
 * svg files can be created with https://editor.method.ac/ 
 * @async
 * @alias hm:marker
 * @param opt {object} options to create the marker, can be a coord directly
 * @param [opt.layer] {string}   layer name
 * @param [opt.coord] {coord}   coord of the marker as \[lat,lng\]
 * @param [opt.icon] {string}   created from hm.buildIcon
 * @param [opt.svg] {string}   see hm.buildIcon
 * @param [opt.opt] {Object}   see hm.buildIcon
 * @param {function} opt.pointerenter  if enter, callback(target,coord,ev)
 * @param {function} opt.pointerClick  if click, callback(target,coord,ev)
 * @param {string} opt.data  optional data
 * @param {boolean} opt.bubble  if true, show buble on click with data
 * @param {boolean} opt.draggable  draggable marker
 * @param {function} opt.dragged  if dragged, callback(target,coord)
 * 
 * @return {H.map.Marker}  marker created
 * 
 * @example 
 * ```js
 * hm.marker([48.8,2.3]);
 *
 * hm.marker({
 *    coord: [48.8,2.3],
 * });
 * 
 * hm.marker({
 *   svg: "svg/marker.svg",
 *   color:"red",
 *   ratio:0.5
 * });
 * 
 * hm.marker({
 *    img: "http://whatever.com/image.png",
 *    coord: [48.8,2.3]
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    data:"Hello world",
 *    bubble: true
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    draggable:true,
 *    dragged: function(target,coord) {console.log("dragged to",coord);}
 * });
 *  ```
 */
async function marker(opt) {
    let settings = {
        layer: "default", //  layer in which to add marker
        coord: null, //  coord of the marker
        img: null, //  image can be url, png, jpg..
        svg: null, // svg file
        icon: null, // icon previously created
        opt: {}, // opt for icon
        pointerEnter: null, //  callback(target,coord,ev)
        pointerClick: null, //  callback(target,coord,ev)
        data: null, //  user data
        bubble: false, //  show a bubble with user data
        draggable: false, //  icon is draggalbe
        dragged: null //  callback(target,coord)
    };

    // can pass directly only the coord
    if (Array.isArray(opt))
        opt.coord = opt;

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    settings.coord = {
        lat: settings.coord[0],
        lng: settings.coord[1]
    };

    // these parameters can be in opt.opt or directly in opt
    if (settings.color) settings.opt.color = settings.color;
    if (settings.size) settings.opt.size = settings.size;
    if (settings.ratio) settings.opt.ratio = settings.ratio;
    if (settings.anchor) settings.opt.anchor = settings.anchor;

    let markerOpt = null;
    if (settings.img || settings.svg) {
        let icon = await buildIcon(settings);
        markerOpt = {
            icon: icon
        };
    } else if (settings.icon) {
        markerOpt = {
            icon: settings.icon
        };
    }

    //console.log("marker settings.coord", settings.coord);
    let marker = new H.map.Marker(settings.coord, markerOpt);

    marker.draggable = settings.draggable;
    if (settings.droppable) {
        marker.draggable = true;
        marker.droppable = true;
    }
    if (settings.dragged) marker.dragged = settings.dragged;

    if (settings.data) {
        let data = settings.data;
        if (settings.data == "__OPT__") {
            data = settings;
            delete data.coord;
            for (let p in data)
                if (!data[p]) delete data[p];
            data = JSON.stringify(data, null, 2).replace(/\n/g, "<br/>");
        }
        marker.setData(data);
    }

    // get click from mouse
    if (settings.pointerEnter) {
        marker.addEventListener("pointerenter", function (ev) {

            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, g.coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.pointerClick) {
        marker.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, g.coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.droppable) {
        marker.addEventListener("dragstart", function (ev) {
            let offset = htmlBounding();
            let screen = {
                left: ev.currentPointer.viewportX + offset.left,
                top: ev.currentPointer.viewportY + offset.top
            };
            settings.droppable(screen, ev, ev.type);
        });
        marker.addEventListener("drag", function (ev) {
            let offset = htmlBounding();
            let screen = {
                left: ev.currentPointer.viewportX + offset.left,
                top: ev.currentPointer.viewportY + offset.top
            };
            settings.droppable(screen, ev, ev.type);
        });
        marker.addEventListener("dragend", function (ev) {
            let offset = htmlBounding();
            let screen = {
                left: ev.currentPointer.viewportX + offset.left,
                top: ev.currentPointer.viewportY + offset.top
            };
            settings.droppable(screen, ev, ev.type);
        });
    }



    /************  show a bubble when clicking on marker *****************************/
    if (settings.bubble) {
        marker.addEventListener("tap", function (ev) {

            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);

            bubbleUnique(g.coordO2A(coord), data);
        });
    }

    if (settings.zIndex)
        marker.setZIndex(settings.zIndex);

    layer.addObject(marker);
    return marker;

} //end of marker


/**
 * get coordinates of a marker
 * @alias marker:getCoord
 * @return {coord}  [lat,lng]
 * @example 
 * ```js
 * let m =hm.marker([48.8,2.3]);
 *
 * let coord = m.getcoord(); // returns [48.8,2.3]
 * 
 *  ```
 */
H.map.Marker.prototype.getCoord = function () {
    let pos = this.getPosition();
    return g.point2Coord(pos);
};





/**
 * Draw a polyline. 
 * @alias hm:polyline
 * @param opt {object}   options to draw polyline
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coords] {array} array of coords, as \[\[48.8,2.3\],\[48.85,2.4\],... \]
 * @param [opt.style] {object} optional graphic style
 * @param [opt.lineWidth=4] {number} line width
 * @param [opt.style.strokeColor=rgba(0, 128, 255, 0.7)] {string} line color
 * @param [opt.arrows] {object} optional arrow
 * @param [opt.data] {String} optional user data
 * @param [opt.pointerClick] {function} optional callback if click on line. format callback(target,coord,event)
 * @param [opt.pointerenter] {function} optional callback if mouse enters on line. format callback(target,coord,event)
 * @param [opt.pointerLeave] {function} optional callback if mouse leaves the line. format callback(target,coord,event)
 * @param [opt.z] {number} optional z level
 * ```js
 * hm.polyline({
 *    coords: [[48.8,2.3],[48.85,2.4],[48.9,2.6]],
 *    layer:"layer1"
 * });
 * 
 * hm.polyline({
 *    coords: coords,
 *    style: {
 *        lineWidth: 4,
 *        strokeColor: "red"
 *    },
 * });
 * 
 * hm.polyline({
 *    coords: coords,
 *    data:"Hello World",
 * });
 *  ```
 */
function polyline(opt) {
    let settings = {
        layer: "default",
        coords: null, // coords is list of array of [lat,lng] or array of object with {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)"
        },
        arrows: null,
        data: null, // optional user data 
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };

    if (Array.isArray(opt)) // directement les coord
        opt = {
            coords: opt
        };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();

    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polyline = new H.map.Polyline(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    // Z index
    if (settings.z) polyline.setZIndex(settings.z);
    // user data
    if (settings.data) polyline.setData(settings.data);

    if (settings.pointerEnter)
        polyline.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, g.coordO2A(coord), ev);
        });
    if (settings.pointerLeave)
        polyline.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, g.coordO2A(coord), ev);
        });
    if (settings.pointerClick)
        polyline.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, g.coordO2A(coord), ev);
        });

    layer.addObject(polyline);

    return polyline;
}


/**
 * Draw a polygon
 * @alias hm:polygon
 * @param {Object} opt  options to draw a polygon. Same options as hm.polyline
 */
function polygon(opt) {
    let settings = {
        layer: "default",
        coords: "", // coords is array of [lat,lng] or array of {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)",
            fillColor: "rgba(0, 128, 255, 0.7)"
        },
        styleHover: null, // style si mouse over
        arrows: null,
        data: null, // additional data to carry
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };
    if (Array.isArray(opt)) // directement les coord
        opt = {
            coords: opt
        };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();
    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polygon = new H.map.Polygon(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    if (settings.data) polygon.setData(settings.data);
    // Z index
    if (settings.z) polyline.setZIndex(settings.z);

    // si un style de hover
    if (settings.styleHover) {
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            target.setStyle(settings.styleHover);
        });
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            target.setStyle(settings.style);
        });
    }

    if (settings.pointerEnter)
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, g.coordO2A(coord), ev, data);
        });
    if (settings.pointerLeave)
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, g.coordO2A(coord), ev, data);
        });
    if (settings.pointerClick)
        polygon.addEventListener("tap", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, g.coordO2A(coord), ev, data);
        });

    layer.addObject(polygon);

    return polygon;
} // end of polygon

/**
 * draw a circle
 * @alias hm:circle
 * @param opt {*}   option for circle
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coord] {array} center of the circle, as \[48.8,2.3\]
 * @param [opt.radius] {number} radius in meter
 * @param [opt.style] {object} optional graphic style
 * @param [opt.style.strokeColor] {string} color of perimeter
 * @param [opt.style.lineWidth] {number} line width
 * @param [opt.style.fillColor] {string} fill color
 */
function circle(opt) {
    let settings = {
        layer: "default",
        coord: null,
        radius: 100, // meters
        style: {
            strokeColor: "rgba(55, 85, 170, 0.2)", // Color of the perimeter
            lineWidth: 2,
            fillColor: "rgba(0, 128, 0, 0.1)" // Color of the circle
        }

    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }
    let circle = new H.map.Circle(
        // The central point of the circle
        g.coordA2O(settings.coord),
        // The radius of the circle in meters
        settings.radius, {
            style: settings.style
        }
    );

    layer.addObject(circle);
    return circle;
}

/**
 * provide bounding box of element hosting map, relatve to window
 * @alias hm:htmlBounding
 * @return {object} {top,left,width, height} relative to window
 */
function htmlBounding() {
    let bb = _htmlItemId.getBoundingClientRect();

    let top = bb.top + window.pageYOffset;
    let left = bb.left + window.pageXOffset;

    return {
        top: top,
        left: left,
        width: bb.width,
        height: bb.height
    };
}


/**
 * watch position on HTML5 position. This requires HTTPS. Creates layer "_gps"
 * @async
 * @alias hm:locateMe
 * @param callback {function}  callback when coord changes. Format: callback(coord,accuracy) 
 * @param opt {Object} optional graphic options
 * @param [opt.position] {object}  graphic options for center. See buildIcon
 * @param [opt.position.svg] {string}  svg file
 * @param [opt.position.color] {string}  color for  {color} tag
 * @param [opt.position.size] {number}  size of icon
 * @param [opt.position.anchor] {number}  anchor of icon
 * @param [opt.accuracy] {object}  graphic options for accuracy representation
 * @param [opt.accuracy.strokeColor] {String}  color of circle line representing accuracy area
 * @param [opt.accuracy.lineWidth] {number}  width of line of circle
 * @param [opt.accuracy.fillColor] {String}  fill color of circle representing accuracy area
 */
async function locateMe(callback, opt) {

    // if no callback, remove the watch
    if (navigator.geolocation) {
        if (!callback && _locateMe) {
            navigator.geolocation.clearWatch(_locateMe);
            _locateMe = null;
            layerDelete("_gps");
            return;
        }

        let settings = {
            position: {
                svg: "@svg/target.svg",
                color: "black",
                anchor: "center"
            },
            accuracy: {
                strokeColor: "rgba(0, 128, 0, 0.8)", // Color of the perimeter
                lineWidth: 2,
                fillColor: "rgba(0, 128, 0, 0.4)" // Color of the circle
            }
        };
        Object.assign(settings, opt);

        let iconCrossHair = await buildIcon({
            svg: settings.position.svg,
            img: settings.position.img,
            opt: settings.position
        });


        //navigator.geolocation.getCurrentPosition(function pos(position) {
        _locateMe = navigator.geolocation.watchPosition((position) => {
            let gps = [position.coords.latitude, position.coords.longitude];

            layerEmpty("_gps");

            /* circle showing the accuracy radius*/
            circle({
                layer: "_gps",
                coord: gps,
                radius: position.coords.accuracy,
                style: settings.accuracy
            });

            marker({
                layer: "_gps",
                coord: gps,
                icon: iconCrossHair
            });

            callback(gps, position.coords.accuracy);
        }, (error) => {
            let msg = "";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    msg += "timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    msg += "An unknown error occurred.";
                    break;
            }
            let e = new Error("HTML5 location error:" + msg); // e.message
            throw (e);
        }, {
            enableHighAccuracy: true
        });
    } else {
        let e = new Error("no HTML5 geolocation capabilities"); // e.message
        throw (e);
    }
}


/**
 * perform a screenshot of the map and returns a promise with the data
 * @async
 * @alias hm:screenshot
 * @param opt {object} options for screenshot
 * @param [opt.name] {string} filename for download
 * @param [opt.ui] {boolean} true to ui (scale, etc..) in screenshot
 * @param opt {object} options for screenshot
 * 
 * @returns {data} binary data of image
 * 
 */
function screenshot(opt) {
    let para = null;
    if (opt && opt.ui)
        para = [_ui];
    return new Promise(
        (resolve, reject) => {
            _map.capture(function (canvas) {
                if (!canvas)
                    return reject("Map screenshot not supported");

                let dataURL = canvas.toDataURL();
                if (opt && opt.name) {
                    let a = document.createElement("a");
                    a.href = dataURL;
                    a.target = "_blank";
                    a.download = opt.name;
                    document.body.appendChild(a);
                    a.click();
                }
                resolve(dataURL);
            }, para);
        });
}


function getMapHtmlItem() {
    return _htmlItem;
}

function getMap() {
    return _map;
}

function getBehavior() {
    return _behavior;
}


function getUI() {
    return _ui;
}

module.exports = {
    getMap: getMap,
    getUI: getUI,
    getBehavior: getBehavior,
    getMapHtmlItem: getMapHtmlItem,
    map: map,
    buildIcon: buildIcon,
    marker: marker,
    getAvailableMapStyle: getAvailableMapStyle,
    setScheme: setScheme,
    layerCreate: layerCreate,
    layerFind: layerFind,
    layerDelete: layerDelete,
    layerSetVisibility: layerSetVisibility,
    layerEmpty: layerEmpty,
    bubbleUnique: bubbleUnique,
    bubbleUniqueHide: bubbleUniqueHide,
    circle: circle,
    polyline: polyline,
    polygon: polygon,
    getCenter: getCenter,
    setCenter: setCenter,
    getZoom: getZoom,
    setZoom: setZoom,
    getViewBB: getViewBB,
    setViewBB: setViewBB,
    locateMe: locateMe,
    screenshot: screenshot,
    htmlBounding: htmlBounding

};
},{"./common.js":3,"./geometry.js":5}],7:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],8:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],9:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],10:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":9,"./is-object":11,"./request-base":12,"./response-base":13,"component-emitter":7}],11:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],12:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.on('abort', () => {
        const err = new Error('Aborted');
        err.code = "ABORTED";
        err.status = this.status;
        err.method = this.method;
        err.url = this.url;
        innerReject(err);
      });
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":11}],13:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":14}],14:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],15:[function(require,module,exports){
"use strict";
const cm = require("./common.js");


/**
 * Place AutoSuggest
 * @ async
 * @alias hm:placeAutoSuggest
 * @param opt {Object} options of autosuggest
 * @param opt.search {String} search string
 * @param opt.center {Coord} center search around this coord
 * @return  {Promise} Array of {res,title,value,coord}
 */
function placeAutoSuggest(opt) {

    const params = cm.addCredentials({
        at: opt.center[0] + "," + opt.center[1],
        q: opt.search
    });

    const url = cm.buildUrl("places", "api.here.com/places/v1/autosuggest");
    return cm.hereRest(url, params, "get", false)
        .then(res => {
            let places = res.body.results.filter(place => place.vicinity); // keep only if vicinity field is present

            return places.map(place => {
                return {
                    title: place.title,
                    //value: place.title + ', ' + place.vicinity.replace(/<br\/>/g, ", ") + ' (' + place.category + ')',
                    value: place.title + ", " + place.vicinity.replace(/<br\/>/g, ", "),
                    coord: place.position,
                    res: place,
                };
            });
        });
}


module.exports = {
    placeAutoSuggest: placeAutoSuggest
};
},{"./common.js":3}],16:[function(require,module,exports){
"use strict";
const cm = require("./common.js");

/**
 * compute a route with optional waypooints. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * @alias hm:route
 * @param {object} source - source as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param {object} dest - dest as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param opt {object} route options 
 * @param [opt.mode=fastest;car;traffic:disabled] {string}  routing mode
 * @param [opt.routeattributes=waypoints,summary,shape] {string}  route attributes
 * @param [opt.maneuverattributes=direction,action] {string}  manoeuver attributes
 * @returns {Promise} returns { summary: object, coords:array,route: object, body:object}. coords is array of coord, to be used with hm.polyline. 
 *
 * @example
  * ```js
  * const res = await hm.route([48.8,2.3],[48.7,2.5]);
  * console.log (res.summary);
  * 
  * const res = await hm.route([[48.8,2.3],[48.9,2.7]], [49.3,2.5]);
  * console.log (res.route); 
  * 
  * const res = await hm.route([48.8,2.3], [[48.9,2.7], [49.3,2.5]]);
  * console.log (res.summary); 
  * ```
 */
function route(source, dest, opt) {

    const settings = {
        mode: "fastest;car;traffic:disabled",
        representation: "linkPaging",
        routeattributes: "waypoints,summary,shape",
        maneuverattributes: "direction,action"
    };

    const params = cm.addCredentials(settings, opt);

    // 1 seul source ou array de source ?
    let id = 0;
    if (Array.isArray(source[0]))
        for (var i = 0; i < source.length; i++) {
            let coord = source[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = source[0] + "," + source[1];

    if (Array.isArray(dest[0]))

        for (let i = 0; i < dest.length; i++) {
            let coord = dest[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = dest[0] + "," + dest[1];

    const url = cm.buildUrl("route", "api.here.com/routing/7.2/calculateroute.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            const route = res.body.response.route[0];
            const summary = route.summary;
            const coords = route.shape.map((latlng => latlng.split(",")));

            return { summary: summary, coords: coords, route: route, body: res.body };

        });

}


/**
 * compute an isoline. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
  * @alias hm:isoline
 * @param opt {object} option for isoline
 * @param [opt.start] {coord} coord for starting point of isoline
 * @param [opt.destination] {coord} coord for destination point of isoline
 * @param [opt.rangeType="time"] {string} time or distance
 * @param [opt.range] {number} range in seconds or in meters
 * @param [opt.mode="fastest;car;traffic:disabled"] {String} routing mode
 * @param [opt.linkattributes=sh] {String} attributes to be returned
 * 
 * @returns {Promise}  returns { poly:array, body:object }. Poly is array of coords, body is full answer
 */
function isoline(opt) {

    const settings = {
        start: null,                            // for direct isoline
        destination: null,                      // for reverse isoline
        rangeType: "time",                      // time or distance
        range: null,                            // in seconds or meters
        linkattributes: "sh",                   // to get the shape
        mode: "fastest;car;traffic:disabled",   //shortest;car;traffic:disabled 
    };
    const params = cm.addCredentials(settings, opt);

    if (params.start)
        params.start = "geo!" + params.start[0] + "," + params.start[1];
    if (params.destination)
        params.destination = "geo!" + params.destination[0] + "," + params.destination[1];

    if (!params.start && !params.destination) {
        let e = new Error("Isoline routing : missing start or destination"); // e.message
        throw (e);
    }
    if (!params.range) {
        let e = new Error("Isoline routing : missing range"); // e.message
        throw (e);
    }

    const url = cm.buildUrl("isoline.route", "api.here.com/routing/7.2/calculateisoline.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            // array of lat,lng, to be transformed into array of [lat,lng]
            const shape = res.body.response.isoline[0].component[0].shape;
            const poly = shape.map(point => point.split(","));

            return { poly: poly, body: res.body };
        });

}


/**
 * compute a matrix. [See more info on optional parameters](http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * 
 * Matrix size is limited to 1x100, 100x1 or 15xN
  * @alias hm:matrix
 * @param source {object} source as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param dest {object} dest as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param opt {object} additional optional parameters like  mode, summaryAttributes
 * @param [opt.mode="fastest;car;traffic:enabled"] {string} routing mode to compute matrix
 * @param [opt.summaryAttributes="tt,di"] {string} attributes in the answer
 * 
 * @returns {Promise} { entries: object, body:object }. entries is the array of {start,stop} information. body is full json answer
 * @example
 * ```js
 * const res = await hm.matrix({
 *      source:[48.8,2.3]
 *      dest:[[48.7,2.5],[48.1,2.0],[44.2,2.3]]
 * });
 * console.log (res.entries); 
 * ```
 */

function matrix(source, dest, opt) {

    var settings = {
        mode: "fastest;car;traffic:enabled",
        summaryAttributes: "tt,di"
    };
    const params = cm.addCredentials(settings, opt);

    if (!Array.isArray(source[0])) // if only one coord
        source = [source];
    source.forEach((coord, i) => {
        params["start" + i] = coord[0] + "," + coord[1];
    });

    if (!Array.isArray(dest[0])) // if only one coord
        dest = [dest];
    dest.forEach((coord, i) => {
        params["destination" + i] = coord[0] + "," + coord[1];
    });

    const url = cm.buildUrl("matrix.route", "api.here.com/routing/7.2/calculatematrix.json");
    return cm.hereRest(url, params, "post")
        .then(res => {
            return { entries: res.body.response.matrixEntry, body: res.body };
        });


}



/**
 * Compute the detour for each waypoint provided, compared to normal route from A to B
 * 
 * @async
 * @alias hm:detour
 * @param start {coord}  starting point for route
 * @param stop {coord}   destination point of route
 * @param waypoints {array}  list of watypoints to test 
 * @returns {Promise} returns {reference: {start, stop, distance, distance2, time, time2} ,waypoints:[ {coord, distA, timeA, distB, timeB}]}
 */
async function detour(start, stop, waypoints) {
    // eslint-disable-next-line   no-undef
    return new Promise(
        async (resolve, reject) => {
            //let tStart = new Date();

            if (!start) return reject("missing start point");
            if (!stop) return reject("missing stop point");
            if (!waypoints) return reject("missing waypoints");
            if (!Array.isArray) return reject("waypoints should be an array");


            // initialise le resultat 
            let res = {
                reference: {},
                waypoints: []
            };

            // calcul les coords nonPostGres, creer l'array de coord des waypoints.
            let dest = [stop]; // so we have a distance/time reference, not same as from routing 1:1
            waypoints.forEach(waypoint => {
                dest.push(waypoint);
                res.waypoints.push(
                    { coord: waypoint }
                );
            });
            // inspect(dest, "dest from detour")

            // compute start to all waypoint, 1st waypoint is stop to get a reference
            let p1 = matrix(start, dest, { mode: "fastest;car;traffic:disabled" });

            // compute from all waypoint to stop, 1st waypoint is start to get another reference
            dest[0] = start;
            let p2 = matrix(dest, stop, { mode: "fastest;car;traffic:disabled" });
            // wait for both matrix to complete

            // eslint-disable-next-line   no-undef
            const result = await Promise.all([p1, p2]);

            // process first part: start => N waypoints
            let entries = result[0].entries;
            // first entry is start stop
            let dist = entries[0].summary.distance;
            let time = entries[0].summary.travelTime;
            res.reference.start = start;
            res.reference.stop = stop;
            res.reference.distance = dist;
            res.reference.time = time; // the reference sans waypoint

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixA" + i);
                    //console.log(start, "associated start");
                    //console.log(dest[i], "associated dest" + i);
                    return;
                }

                let id = entry.destinationIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distA = dist;
                res.waypoints[id - 1].timeA = time;
            });


            // process second part: N waypoints => stop
            entries = result[1].entries;
            //inspect(entries[0], "matrixB0");

            res.reference.distance2 = entries[0].summary.distance;
            res.reference.time2 = entries[0].summary.travelTime;

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixB" + i);
                    //console.log(entry, "associated start" + i);
                    //console.log(stop, "associated stop");
                    return;
                }
                let id = entry.startIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distB = dist;
                res.waypoints[id - 1].timeB = time;
            });
            return resolve(res);
        });

}


module.exports = {
    matrix: matrix,
    route: route,
    isoline: isoline,
    detour: detour
};


},{"./common.js":3}],17:[function(require,module,exports){
/* global document,H */
"use strict";
const hm = require("./map.js");
const simplify = require("simplify-js");


let _touchOffset = null;
let _touchCoords = null;
let _touchPolyline = null;
let _touchLayer = null;
let _touchCallback = null;
let _map = null;
let _behavior = null;

let _behaviorEnable = true;
function behaviorEnable(onoff) {
    if (_behaviorEnable && !onoff) {
        _behavior.disable();
        //console.log("behavior disabled");
        _behaviorEnable = false;
    }
    if (!_behaviorEnable && onoff) {
        _behavior.enable();
        //console.log("behavior enabled");
        _behaviorEnable = true;
    }
}
/**
 * activate touch, allowing hand drawing, with embedded simplification of the line
 * @alias hm:touch
 * @param onoff {boolean}  activate or deactivate
 * @param options {object} options  to control the touch behaviour
 * @param [options.callback] {function} calling callback(coords) when touch ends
 * @param [options.layer] {string} layer where to put the drawing
 * @param [options.style] {object} drawing style for the line
 * @param [options.arrow] {object} arrow style for the line
 * @param [options.tolerance=4] {number} tolerance for simplification
 * @param [options.keep=false] {boolean} keep graphic or not when calling callback
 */
function touch(onoff, options) {

    _map = hm.getMap();
    _behavior = hm.getBehavior();
    let elmt = document.getElementById(hm.getMapHtmlItem());

    let bb = elmt.getBoundingClientRect();
    _touchOffset = { left: bb.x, top: bb.y }; // offset of window to browser

    const settings = {
        callback: null,
        layer: "_touch",
        keep: false,
        style: { lineWidth: 5, strokeColor: "rgba(255, 0, 0, 0.7)" },
        arrows: { fillColor: "white", frequency: 5, width: 1, length: 2 },
        tolerance: 4, // level of simplification
    };

    Object.assign(settings, options);

    _touchLayer = hm.layerFind(settings.layer);
    if (!_touchLayer) {
        _touchLayer = hm.layerCreate(settings.layer);
        //_touchLayer = hm.layerFind(settings.layer);
    }

    // callback des event Listener
    // defini seulement sur onoff, pour ne pas creer une autre fois la fonction
    if (onoff)
        _touchCallback = function (e) {

            let touchobj = e.changedTouches[0]; // reference first touch point (ie: first finger)

            // if ((e.touches.length >= 2 && e.targetTouches.length >= 2)) {
            if ((e.touches.length >= 2)) {
                //    console.log("touch.length", e.touches.length);
                behaviorEnable(true);
                return;
            }

            if (e.type == "touchmove")
                behaviorEnable(false);

            // e.preventDefault();
            //console.log("e.type", e.type);
            let simplified;

            switch (e.type) {
                case "touchstart":
                    _touchCoords = []; // coords
                    break;

                case "touchmove":
                    //  e.preventDefault();

                    _touchCoords.push({
                        x: touchobj.clientX - _touchOffset.left,
                        y: touchobj.clientY - _touchOffset.top
                    });

                    if (_touchCoords.length < 2)
                        return;

                    var lineString = new H.geo.LineString;

                    _touchCoords.forEach(c => {
                        let coord = _map.screenToGeo(c.x, c.y);
                        lineString.pushLatLngAlt(coord.lat, coord.lng, 0);
                    });

                    // create polyline if not exists
                    if (!_touchPolyline) {
                        _touchPolyline = new H.map.Polyline(lineString, {
                            style: settings.style,
                            arrows: settings.arrows
                        });
                        _touchLayer.addObject(_touchPolyline);
                    } else  // modif geometry
                        _touchPolyline.setGeometry(lineString);
                    break;

                case "touchend": // c'est la fin, on simplifie et appelle le callback
                    if (_touchCoords.length < 2) // not enough points
                        return;

                    simplified = _touchCoords; //as array of {x,y}
                    if (settings.callback) {

                        // simplify the result
                        if (settings.tolerance > 0)
                            simplified = simplify(_touchCoords, settings.tolerance, false);

                        // not enough points, go back to initial
                        if (simplified.length < 1)
                            simplified = _touchCoords;

                        // convert from{x,y} screen to [lat,lng]
                        let coords = simplified.map(coord => {
                            let latlng = _map.screenToGeo(coord.x, coord.y);
                            return [latlng.lat, latlng.lng];
                        });

                        //let coords = geom.simplify(_touchCoords, settings.tolerance)

                        //up to callback to redraw
                        if (_touchPolyline && !settings.keep)
                            _touchLayer.removeObject(_touchPolyline);
                        _touchPolyline = null;

                        behaviorEnable(true);
                        // run callback
                        settings.callback(coords);
                    }
                    break;
            }

        }; // of _touch



    if (onoff) {
        elmt.addEventListener("touchstart", _touchCallback);
        elmt.addEventListener("touchmove", _touchCallback);
        elmt.addEventListener("touchend", _touchCallback);
        //        behaviorEnable(false);

    } else {
        elmt.removeEventListener("touchstart", _touchCallback);
        elmt.removeEventListener("touchmove", _touchCallback);
        elmt.removeEventListener("touchend", _touchCallback);

        if (_touchPolyline)
            _touchLayer.removeObject(_touchPolyline);

        _touchLayer = null;
        _touchPolyline = null;
        _touchCoords = null;
        behaviorEnable(true);
    }


} // of touch


module.exports = {
    touch: touch
};
},{"./map.js":6,"simplify-js":8}]},{},[3,5,6,16,4,2,17,15])(17)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImhlcmVtYXAuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJjbHVzdGVyLmpzIiwiY29tbW9uLmpzIiwiZ2VvY29kaW5nLmpzIiwiZ2VvbWV0cnkuanMiLCJtYXAuanMiLCJub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCJub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvaXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXNwb25zZS1iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3V0aWxzLmpzIiwicGxhY2UuanMiLCJyb3V0aW5nLmpzIiwidG91Y2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1N0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qXHJcbiAqIEBtb2R1bGUgSEVSRU1BUFxyXG4gKiBAdHlwaWNhbG5hbWUgaG1cclxuICovXHJcblxyXG5sZXQgbW9kdWxlcyA9IHt9O1xyXG5PYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vZ2VvbWV0cnkuanNcIikpO1xyXG5PYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL3JvdXRpbmcuanNcIikpO1xyXG5PYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL2dlb2NvZGluZy5qc1wiKSk7XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vcGxhY2UuanNcIikpO1xyXG5cclxuLy8gb25seSBhZGRlZCBpbiBjYXNlIG9mIGJyb3dzZXIgbGlicmFyeVxyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL21hcC5qc1wiKSk7XHJcbiAgICBPYmplY3QuYXNzaWduKG1vZHVsZXMsIHJlcXVpcmUoXCIuL2NsdXN0ZXIuanNcIikpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi90b3VjaC5qc1wiKSk7XHJcbn1cclxuLy8gZXhwb3J0IGFsbCB0aGUgYWJvdmVcclxubW9kdWxlLmV4cG9ydHMgPSBtb2R1bGVzOyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiBnbG9iYWwgSCwgZG9jdW1lbnQsIEltYWdlICovXHJcblwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcclxuY29uc3QgbSA9IHJlcXVpcmUoXCIuL21hcC5qc1wiKTtcclxuXHJcbi8vIG1hcCBvbiB3aGljaCB0byBhZGQgdGhlIGNsdXN0ZXIgbGF5ZXJcclxubGV0IG1hcCA9IG51bGw7XHJcblxyXG4vL3RoZSBjbHVzdGVyIGxheWVyXHJcbmxldCBjbHVzdGVyTGF5ZXIgPSBudWxsO1xyXG5sZXQgX3Zpc2libGUgPSBmYWxzZTtcclxuXHJcbmxldCBpY29uTm9pc2UgPSBudWxsO1xyXG5sZXQgY2x1c3RlclN0eWxlID0gW107IC8vIGFycmF5IG9mIHt3ZWlnaHQscG9zIGltYWdlZGF0YX1cclxuXHJcbmxldCBjbHVzdGVyZWREYXRhUHJvdmlkZXIgPSBudWxsO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2x1c3RlciBvZiBwb2ludHNcclxuICogQGFsaWFzIGhtOmNsdXN0ZXJcclxuICogQHBhcmFtIGNvb3JkcyB7QXJyYXl9ICBhcnJheSBvZiBcXFtsYXQsbG5nLHBheWxvYWRcXF1cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBjbHVzdGVyXHJcbiAqIEBwYXJhbSBbb3B0Lm1pblpvb21dIHtudW1iZXJ9IG1pbiB6b29tIGZvciBjbHVzdGVyIHRvIGJlIHZpc2libGVcclxuICogQHBhcmFtIFtvcHQubWF4Wm9vbV0ge251bWJlcn0gbWF4IHpvb20gZm9yIGNsdXN0ZXIgdG8gYmUgdmlzaWJsZVxyXG4gKiBAcGFyYW0gW29wdC5ub2lzZV0ge29iamVjdH0gZ3JhcGhpYyB0byByZXByZXNlbnQgc3RhbmQtYWxvbmUgcG9pbnQuIHtpY29uLHNpemV9XHJcbiAqIEBwYXJhbSBbb3B0Lm5vaXNlLmljb25dIHtzdHJpbmd9IHBuZy9qcGcvc3ZnIGZpbGUuIEAgYXMgZmlyc3QgY2hhcmFjdGVyIGluZGljYXRlcyBhIGZpbGUgZnJvbSB0aGlzIHBhY2thZ2UuIEFuY2hvciB3aWxsIGJlIGJvdHRvbS1jZW50ZXJcclxuICogQHBhcmFtIFtvcHQubm9pc2Uuc2l6ZV0ge251bWJlcn0gb3B0aW9uYWwgc2l6ZSBvZiBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LmNsdXN0ZXJdIHtvYmplY3R9IHsgd2VpZ2h0OntpY29uLHNpemV9LCB3ZWlnaHQ6e2ljb24sc2l6ZX0sLi4uIH1cclxuICogQHBhcmFtIFtvcHQuY2x1c3Rlci5pY29uXSB7c3RyaW5nfSBwbmcvanBnL3N2ZyBmaWxlIHRvIHJlcHJlc2VudCBncm91cCBvZiBwb2lzLiBAIGFzIGZpcnN0IGNoYXJhY3RlciBpbmRpY2F0ZXMgYSBmaWxlIGZyb20gdGhpcyBwYWNrYWdlLiBBbmNob3Igd2lsbCBiZSBtaWRkbGUgb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5jbHVzdGVyLnNpemVdIHtudW1iZXJ9IHNpemUgb2YgaWNvblxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBjYWxsYmFjayB0byBiZSBjYWxsZWQgaWYgY2xpY2sgb24gaXRlbS4gRm9ybWF0IGNiKGV2ZW50LCBjb29yZCwgcGF5bG9hZCwgd2VpZ3RoKS4gXHJcbiAqIGBjb29yZGAgaXMgY29vcmQgb2YgaWNvblxyXG4gKiBgcGF5bG9hZGAgaXMgcGF5bG9hZCBhc3NvY2lhdGVkIHRvIHBvaW50LiBcclxuICogYHdlaWdodGAgaXMgbnVtYmVyIG9mIHBvaW50cyBhZ2dyZWdhdGVkLCB3aGVuIGNsaWNraW5nIG9uIGEgY2x1c3RlciBpY29uLCAxIGlmIHNpbmdsZSBwb2ludFxyXG4gKiBcclxuICogQHJldHVybiB7SC5tYXAubGF5ZXIuT2JqZWN0TGF5ZXJ9ICBsYXllciBjcmVhdGVkXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBsZXQgcG9pcyA9IFtbNDguOCwyLjMsXCJIZWxsbyB3b3JsZFwiXSxbNDguNSwyLjQsXCJIb3cgYXJlIHlvdVwiXSxbNDUuMiwyLjkzLFwiVmVyeSB3ZWxsXCJdXTtcclxuICogXHJcbiAqIGhtLmNsdXN0ZXIocG9pcyk7XHJcbiAqIFxyXG4gKiAvLyB3aXRoIG1vcmUgZ3JhcGhpYyBvcHRpb25zIGFuZCBjYWxsYmFjayBkZWZpbmVkXHJcbiAqICAgbGV0IG9wdCA9IHtcclxuICogICAgbm9pc2U6IHtcclxuICogICAgICAgICAgaWNvbjogXCJtY2RvLnBuZ1wiLFxyXG4gKiAgICAgICAgICBzaXplOiAxMlxyXG4gKiAgICAgIH0sXHJcbiAqICAgIGNsdXN0ZXI6IHtcclxuICogICAgICAgMjAwOiB7XHJcbiAqICAgICAgICAgICBpY29uOiBcIkBzdmcvY2x1c3Rlcl9yZWQuc3ZnXCIsXHJcbiAqICAgICAgICAgICBzaXplOiA2NFxyXG4gKiAgICAgICB9LFxyXG4gKiAgICAgICA3NToge1xyXG4gKiAgICAgICAgICAgaWNvbjogXCJAc3ZnL2NsdXN0ZXJfb3JhbmdlLnN2Z1wiLFxyXG4gKiAgICAgICAgICAgc2l6ZTogNTJcclxuICogICAgICAgfSxcclxuICogICAgICAgMjoge1xyXG4gKiAgICAgICAgICAgaWNvbjogXCJAc3ZnL2NsdXN0ZXJfZ3JlZW4uc3ZnXCIsXHJcbiAqICAgICAgICAgICBzaXplOiA0MFxyXG4gKiAgICAgICAgfVxyXG4gKiAgICB9XHJcbiAqICAgfTtcclxuICogIGhtLmNsdXN0ZXIocG9pcywgb3B0LFxyXG4gKiAgICAgICAgICAgKGV2ZW50LCBjb29yZGluYXRlLCBkYXRhLCB3ZWlnaHQpID0+IHtcclxuICogICAgICAgICAgICAgICBpZiAoZGF0YSlcclxuICogICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGljayBvbiBwb2ludCBcIiwgZGF0YSk7XHJcbiAqICAgICAgICAgICAgICAgZWxzZVxyXG4gKiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrIG9uIGNsdXN0ZXIgd2l0aCB3ZWlnaHRcIiwgd2VpZ2h0KTtcclxuICogICAgICAgICAgIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsdXN0ZXIoY29vcmRzLCBvcHQsIGNiID0gbnVsbCkge1xyXG5cclxuICAgIGxldCBkYXRhUG9pbnRzID0gW107XHJcbiAgICBtYXAgPSBtLmdldE1hcCgpO1xyXG4gICAgbGV0IF9ob21lID0gY20uZ2V0SG9tZSgpO1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBlcHM6IDY0LFxyXG4gICAgICAgIG1pblpvb206IDEsIC8vIG1pbiB6b29tXHJcbiAgICAgICAgbWF4Wm9vbTogMjQsIC8vIG1heCB6b29tXHJcbiAgICAgICAgbm9pc2U6IHtcclxuICAgICAgICAgICAgaWNvbjogX2hvbWUgKyBcInN2Zy9ibHVlZG90LnN2Z1wiLFxyXG4gICAgICAgICAgICBzaXplOiAxNlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2x1c3Rlcjoge1xyXG4gICAgICAgICAgICAyMDA6IHtcclxuICAgICAgICAgICAgICAgIGljb246IF9ob21lICsgXCJzdmcvY2x1c3Rlcl9yZWQuc3ZnXCIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjQjUwMDE1XCIsXHJcbiAgICAgICAgICAgICAgICBzaXplOiA2NFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICA3NToge1xyXG4gICAgICAgICAgICAgICAgaWNvbjogX2hvbWUgKyBcInN2Zy9jbHVzdGVyX29yYW5nZS5zdmdcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiNGRjY5MDBcIixcclxuICAgICAgICAgICAgICAgIHNpemU6IDQ4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIDI6IHtcclxuICAgICAgICAgICAgICAgIGljb246IF9ob21lICsgXCJzdmcvY2x1c3Rlcl9ncmVlbi5zdmdcIixcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIiM3QkQzMEFcIixcclxuICAgICAgICAgICAgICAgIHNpemU6IDQwXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChvcHQpXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgdXNlVGhlbWUgPSB0cnVlOyAvLyBkbyB3ZSB1c2Ugb3VyIG93biB0aGVtZSA/XHJcbiAgICBpZiAoIW9wdCB8fCAob3B0ICYmICFvcHQubm9pc2UgJiYgIW9wdC5jbHVzdGVyKSlcclxuICAgICAgICB1c2VUaGVtZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvb3Jkcy5mb3JFYWNoKGNvb3JkID0+IHtcclxuICAgICAgICAvLyB1c2Ugb3Bfd2VpZ2h0IG9mIDEgZm9yIGVhY2ggY29vcmRcclxuICAgICAgICAvLyBwcm92aWRlcyBhbGwgY29vcmQgYXMgZGF0YVxyXG4gICAgICAgIGxldCBkcCA9IG5ldyBILmNsdXN0ZXJpbmcuRGF0YVBvaW50KGNvb3JkWzBdLCBjb29yZFsxXSwgMSwgY29vcmQpO1xyXG4gICAgICAgIGRhdGFQb2ludHMucHVzaChkcCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IG1pbldlaWdodCA9IDI7IC8vIG1pbmltdW0gd2VpZ2h0IGJ5IGRlZmF1bHRcclxuXHJcbiAgICBpZiAodXNlVGhlbWUpIHtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRpbmcgaWNvbiBmb3Igbm9pc2UgKGluZGl2aWR1YWwgcG9pbnQpXHJcbiAgICAgICAgbGV0IGljb24gPSBzZXR0aW5ncy5ub2lzZS5pY29uO1xyXG4gICAgICAgIGlmIChpY29uWzBdID09IFwiQFwiKSAvLyB0byBpbmRpY2F0ZSBsb2NhbFxyXG4gICAgICAgICAgICBpY29uID0gY20uZ2V0SG9tZSgpICsgaWNvbi5zdWJzdHIoMSk7XHJcblxyXG4gICAgICAgIGxldCBpY29uT3B0ID0gbnVsbDtcclxuICAgICAgICBpZiAoc2V0dGluZ3Mubm9pc2Uuc2l6ZSlcclxuICAgICAgICAgICAgaWNvbk9wdCA9IHtcclxuICAgICAgICAgICAgICAgIHNpemU6IHtcclxuICAgICAgICAgICAgICAgICAgICB3OiBzZXR0aW5ncy5ub2lzZS5zaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGg6IHNldHRpbmdzLm5vaXNlLnNpemVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpY29uTm9pc2UgPSBuZXcgSC5tYXAuSWNvbihpY29uLCBpY29uT3B0KTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2Ygd2VpZ2h0XHJcbiAgICAgICAgbGV0IHdlaWdodE9yZGVyID0gT2JqZWN0LmtleXMoc2V0dGluZ3MuY2x1c3Rlcikuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYiAtIGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gbWlud2VpZ2h0IGlzIHRoZSBzbWFsbGVzdCB3ZWlnaHRcclxuICAgICAgICBtaW5XZWlnaHQgPSB3ZWlnaHRPcmRlclt3ZWlnaHRPcmRlci5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY2x1c3RlclN0eWxlID0gd2VpZ2h0T3JkZXIubWFwKCh3ZWlnaHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNpemUgPSBzZXR0aW5ncy5jbHVzdGVyW3dlaWdodF0uc2l6ZTtcclxuICAgICAgICAgICAgbGV0IGljb24gPSBzZXR0aW5ncy5jbHVzdGVyW3dlaWdodF0uaWNvbjtcclxuICAgICAgICAgICAgaWYgKGljb25bMF0gPT0gXCJAXCIpIC8vIHRvIGluZGljYXRlIGxvY2FsXHJcbiAgICAgICAgICAgICAgICBpY29uID0gY20uZ2V0SG9tZSgpICsgaWNvbi5zdWJzdHIoMSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcCA9IGxvYWRJY29uRmlsZShpY29uLCBzaXplLCBzaXplKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwKTtcclxuICAgICAgICAgICAgbGV0IGVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgd2VpZ2h0OiBwYXJzZUludCh3ZWlnaHQpLFxyXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHdhaXQgZm9yIGFsbCBwcm9taXNlcyB0byBiZSByZXNvbHZlZFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcclxuICAgICAgICAvLyBhc3NvY2lhdGVkIHRvIGVhY2ggZW50cnkgb2YgY2x1c3RlcnN0eWxlXHJcbiAgICAgICAgcmVzdWx0LmZvckVhY2goKGltYWdlRGF0YSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBjbHVzdGVyU3R5bGVbaV0uaW1hZ2VEYXRhID0gaW1hZ2VEYXRhO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgbGV0IG9wdFByb3ZpZGVyID0ge1xyXG4gICAgICAgIGNsdXN0ZXJpbmdPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIC8vIE1heGltdW0gcmFkaXVzIG9mIHRoZSBuZWlnaGJvcmhvb2RcclxuICAgICAgICAgICAgZXBzOiBzZXR0aW5ncy5lcHMsXHJcbiAgICAgICAgICAgIC8vIG1pbmltdW0gd2VpZ2h0IG9mIHBvaW50cyByZXF1aXJlZCB0byBmb3JtIGEgY2x1c3RlclxyXG4gICAgICAgICAgICBtaW5XZWlnaHQ6IG1pbldlaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWluOiBzZXR0aW5ncy5taW5ab29tLCAvLyBtaW4gem9vbVxyXG4gICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbSAvLyBtYXggem9vbVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpZiB3ZSB1c2Ugb3VyIG93biB0aGVtZVxyXG4gICAgaWYgKHVzZVRoZW1lKVxyXG4gICAgICAgIG9wdFByb3ZpZGVyLnRoZW1lID0ge1xyXG4gICAgICAgICAgICBnZXRDbHVzdGVyUHJlc2VudGF0aW9uOiBnZXRDbHVzdGVyUHJlc2VudGF0aW9uLFxyXG4gICAgICAgICAgICBnZXROb2lzZVByZXNlbnRhdGlvbjogZ2V0Tm9pc2VQcmVzZW50YXRpb25cclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vIGNyZWF0ZSBjbHVzdGVyIHByb3ZpZGVyXHJcbiAgICBjbHVzdGVyZWREYXRhUHJvdmlkZXIgPSBuZXcgSC5jbHVzdGVyaW5nLlByb3ZpZGVyKGRhdGFQb2ludHMsIG9wdFByb3ZpZGVyKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBsYXllciB0aGF0IGluY2x1ZGVzIHRoZSBkYXRhIHByb3ZpZGVyIGFuZCBpdHMgZGF0YSBwb2ludHM6XHJcbiAgICBjbHVzdGVyTGF5ZXIgPSBuZXcgSC5tYXAubGF5ZXIuT2JqZWN0TGF5ZXIoY2x1c3RlcmVkRGF0YVByb3ZpZGVyKTtcclxuICAgIC8vIEFkZCB0aGUgbGF5ZXIgdG8gdGhlIG1hcDpcclxuICAgIG1hcC5hZGRMYXllcihjbHVzdGVyTGF5ZXIpO1xyXG5cclxuICAgIC8vIGxheWVyIGlzIHZpc2libGUgYnkgZGVmYXVsdFxyXG4gICAgX3Zpc2libGUgPSB0cnVlO1xyXG5cclxuICAgIC8vIGlmIGEgY2FsbGJhY2sgaXMgZGVmaW5lZCwgYWRkIGV2ZW50IGxpc3RlbmVyXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBjbHVzdGVyZWREYXRhUHJvdmlkZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgLy8gTG9nIGRhdGEgYm91bmQgdG8gdGhlIG1hcmtlciB0aGF0IGhhcyBiZWVuIHRhcHBlZDpcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBldi50YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBtYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBsZXQgaXNDbHVzdGVyID0gZGF0YS5pc0NsdXN0ZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpc0NsdXN0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3ZWlndGggPSBkYXRhLmdldFdlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgY2IoZXYsIG0uY29vcmRPMkEoY29vcmQpLCBudWxsLCB3ZWlndGgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJEYXRhID0gZGF0YS5nZXREYXRhKCk7IC8vIGxhdCxsbmcsIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIGNiKGV2LCBtLmNvb3JkTzJBKGNvb3JkKSwgdXNlckRhdGFbMl0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsdXN0ZXJMYXllcjtcclxufVxyXG5cclxuXHJcblxyXG4vLyB0aGlzIGZ1bmN0aW9uICBjcmVhdGVzIHRoZSBpY29uIGZvciBhIGNsdXN0ZXJcclxuZnVuY3Rpb24gZ2V0Q2x1c3RlclByZXNlbnRhdGlvbihjbHVzdGVyKSB7XHJcblxyXG4gICAgLy8gYnVpbGRpbmcgZGF0YSBvYmplY3Qgd2hpY2ggd2lsbCBiZSByZXR1cm5lZCB3aGVuIGNsaWNraW5nIG9uIHRoZSBpY29uXHJcbiAgICBsZXQgZGF0YSA9IHt9O1xyXG4gICAgZGF0YS5pc0NsdXN0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9OyAvLyBzbyB3ZSBrbm93IGl0IGlzIGEgY2x1c3RlclxyXG4gICAgbGV0IHdlaWdodCA9IGNsdXN0ZXIuZ2V0V2VpZ2h0KCk7XHJcblxyXG4gICAgZGF0YS5nZXRXZWlnaHQgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHdlaWdodDtcclxuICAgIH07IC8vIG51bWJlciBvZiBpbmRpdmlkdWFsIGl0ZW0gY2x1c3RlcmVkIHRvZ2V0aGVyXHJcblxyXG4gICAgLy8gbGV0J3MgZmluZCB0aGUgcmVsZXZhbnQgY29sb3IgYW5kIHNpemVcclxuICAgIGxldCBlbnRyeSA9IGNsdXN0ZXJTdHlsZS5maW5kKGVsdCA9PiAod2VpZ2h0ID49IGVsdC53ZWlnaHQpKTtcclxuICAgIGxldCBpbWFnZURhdGEgPSBlbnRyeS5pbWFnZURhdGE7XHJcblxyXG4gICAgbGV0IGljb24gPSBidWlsZENsdXN0ZXJJY29uKGltYWdlRGF0YSwgXCJcIiArIHdlaWdodCk7XHJcbiAgICAvLyBjcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBDbHVzdGVyXHJcbiAgICBsZXQgbWluID0gY2x1c3Rlci5nZXRNaW5ab29tKCk7XHJcbiAgICBsZXQgbWF4ID0gY2x1c3Rlci5nZXRNYXhab29tKCk7XHJcbiAgICBsZXQgY2x1c3Rlck1hcmtlciA9IG5ldyBILm1hcC5NYXJrZXIoY2x1c3Rlci5nZXRQb3NpdGlvbigpLCB7XHJcbiAgICAgICAgLy8gdG8gc2hvdyBpdCBjb3JyZWN0bHkgYXQgY2VydGFpbiB6b29tIGxldmVsczpcclxuICAgICAgICBtaW46IG1pbixcclxuICAgICAgICBtYXg6IG1heCxcclxuICAgICAgICBpY29uOiBpY29uLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTGluayBkYXRhIGZyb20gdGhlIGZyb20gdGhlIGNsdXN0ZXIgdG8gdGhlIG1hcmtlcixcclxuICAgIC8vIHRvIG1ha2UgaXQgYWNjZXNzaWJsZSBvbiBjYWxsYmFja1xyXG4gICAgY2x1c3Rlck1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG5cclxuICAgIHJldHVybiBjbHVzdGVyTWFya2VyO1xyXG59XHJcblxyXG4vLyBmdW5jdGlvbiB0byByZXByZXNlbnQgYSBzaW5nbGUgaXRlbVxyXG5mdW5jdGlvbiBnZXROb2lzZVByZXNlbnRhdGlvbihub2lzZVBvaW50KSB7XHJcblxyXG4gICAgLy8gZGF0YSB0byBiZSBzZW50IG9uIGNhbGxiYWNrXHJcbiAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgIGdldERhdGE6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vaXNlUG9pbnQuZ2V0RGF0YSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNDbHVzdGVyOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFdlaWdodDogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcmtlciBmb3IgdGhlIG5vaXNlUG9pbnRcclxuICAgIHZhciBub2lzZU1hcmtlciA9IG5ldyBILm1hcC5NYXJrZXIobm9pc2VQb2ludC5nZXRQb3NpdGlvbigpLCB7XHJcbiAgICAgICAgLy8gVXNlIG1pbiB6b29tIGZyb20gYSBub2lzZSBwb2ludFxyXG4gICAgICAgIC8vIHRvIHNob3cgaXQgY29ycmVjdGx5IGF0IGNlcnRhaW4gem9vbSBsZXZlbHM6XHJcbiAgICAgICAgbWluOiBub2lzZVBvaW50LmdldE1pblpvb20oKSxcclxuICAgICAgICBpY29uOiBpY29uTm9pc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIExpbmsgYSBkYXRhIGZyb20gdGhlIHBvaW50IHRvIHRoZSBtYXJrZXJcclxuICAgIC8vIHRvIG1ha2UgaXQgYWNjZXNzaWJsZSBvbiBjYWxsYmFja1xyXG4gICAgbm9pc2VNYXJrZXIuc2V0RGF0YShkYXRhKTtcclxuXHJcbiAgICByZXR1cm4gbm9pc2VNYXJrZXI7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGxvYWQgYSBmaWxlIGludG8gYSBjYW52YXNcclxuICogQGlnbm9yZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIG9mIHBuZyxqcGcsc3ZnIGZpbGUgXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBmb3Igc3ZnLCBkZWZpbmUgd2lkdGhcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBmb3Igc3ZnLCBkZWZpbmUgaGVpZ2h0XHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkSWNvbkZpbGUoZmlsZSwgd2lkdGggPSBudWxsLCBoZWlnaHQgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdmFyIG5ld0ltZyA9IG5ldyBJbWFnZTtcclxuICAgICAgICAgICAgbmV3SW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IG5ld0ltZy53aWR0aDtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBuZXdJbWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgLy8gY29weSBpY29uIGludG8gYSBjYW52YXNcclxuICAgICAgICAgICAgICAgIGxldCBzcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICAgICAgICAgc3JjLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzcmMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGN0eCA9IHNyYy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29weSBpbWFnZSBpbnRvIGNhbnZhcyBjbHVzdGVyXHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKG5ld0ltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltYWdlRGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBuZXdJbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiOyAvLyB1c2VmdWwuLiA/XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCkgbmV3SW1nLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQpIG5ld0ltZy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBuZXdJbWcuc3JjID0gZmlsZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGFuIGljb24gYnkgY29weWluZyBpbWFnZURhdGEgYW5kIGFkZGluZyB0ZXh0XHJcbiAqIEBpZ25vcmVcclxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltZ0RhdGEgIGZyb20gY2FudmFzLmdldEltYWdlRGF0YVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAgdGV4dCB0byB3cml0ZVxyXG4gKi9cclxuZnVuY3Rpb24gYnVpbGRDbHVzdGVySWNvbihpbWdEYXRhLCB0ZXh0KSB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1nRGF0YS53aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcclxuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgY29uc3QgZm9udFNpemUgPSAxMjtcclxuXHJcbiAgICBjdHguZm9udCA9IFwiYm9sZCBcIiArIGZvbnRTaXplICsgXCJweCBBcmlhbFwiO1xyXG4gICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcclxuICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xyXG5cclxuICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XHJcbiAgICBjdHguZmlsbFRleHQodGV4dCwgY2FudmFzLndpZHRoIC8gMiwgKGNhbnZhcy5oZWlnaHQgKyBmb250U2l6ZSkgLyAyIC0gMik7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBILm1hcC5JY29uKGNhbnZhcywge1xyXG4gICAgICAgIGFuY2hvcjoge1xyXG4gICAgICAgICAgICB4OiBjYW52YXMud2lkdGggLyAyLFxyXG4gICAgICAgICAgICB5OiBjYW52YXMuaGVpZ2h0IC8gMlxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBIaWRlIGNsdXN0ZXIgbGF5ZXJcclxuICogIEBhbGlhcyBobTpjbHVzdGVySGlkZVxyXG4gKi9cclxuZnVuY3Rpb24gY2x1c3RlckhpZGUoKSB7XHJcbiAgICBpZiAoIV92aXNpYmxlIHx8ICFjbHVzdGVyTGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIG1hcC5yZW1vdmVMYXllcihjbHVzdGVyTGF5ZXIpO1xyXG4gICAgX3Zpc2libGUgPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3cgQ2x1c3RlciBsYXllclxyXG4gKiBAYWxpYXMgaG06Y2x1c3RlclNob3dcclxuICovXHJcbmZ1bmN0aW9uIGNsdXN0ZXJTaG93KCkge1xyXG4gICAgaWYgKF92aXNpYmxlIHx8ICFjbHVzdGVyTGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIG1hcC5hZGRMYXllcihjbHVzdGVyTGF5ZXIpO1xyXG4gICAgX3Zpc2libGUgPSB0cnVlO1xyXG5cclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNsdXN0ZXI6IGNsdXN0ZXIsXHJcbiAgICBjbHVzdGVyU2hvdzogY2x1c3RlclNob3csXHJcbiAgICBjbHVzdGVySGlkZTogY2x1c3RlckhpZGVcclxufTsiLCJcInVzZSBzdHJpY3RcIjtcclxuLyogZ2xvYmFsIGRvY3VtZW50ICovXHJcblxyXG4vKipcclxuICogQGZpbGUgZ2VuZXJpYyBmdW5jdGlvbiBvZiBoZXJlbWFwXHJcbiAqIEBhdXRob3IgZGV2YmFiXHJcbiAqL1xyXG5cclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoXCJzdXBlcmFnZW50XCIpO1xyXG5cclxuLy8gYnkgZGVmYXVsdCwgdW5sZXNzIHNwZWNpZmllZCBmYnkgY2FsbGluZyBjb25maWdcclxuLy8gZW52aXJvbm1lbnQgdXNhYmxlIHdpdGggbm9kZVxyXG5sZXQgQVBQX0lEID0gcHJvY2Vzcy5lbnYuQVBQX0lEO1xyXG5sZXQgQVBQX0NPREUgPSBwcm9jZXNzLmVudi5BUFBfQ09ERTtcclxubGV0IENJVCA9IFwiXCI7IC8vIHByb2R1Y3Rpb24gYnkgZGVmYXVsdFxyXG5sZXQgUFJPVE9DT0wgPSBcImh0dHBzOlwiOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfdXNlSFRUUFMgPSB0cnVlOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfaG9tZSA9IFwiLlwiO1xyXG5cclxuXHJcbi8vIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSBhbmQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIHBuZy9zdmcgZmlsZXNcclxuLy8gcGF5IGF0dGVudGlvbiBpZiBsaWJyYXJ5IGlzIGJ1aWxkIGluIC4vZGlzdFxyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XHJcbiAgICBsZXQgX3NjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xyXG4gICAgbGV0IF9maWxlID0gX3NjcmlwdFtfc2NyaXB0Lmxlbmd0aCAtIDFdLnNyYztcclxuICAgIGxldCBfcGF0aCA9IF9maWxlLnN1YnN0cmluZygwLCBfZmlsZS5sYXN0SW5kZXhPZihcIi9cIikpO1xyXG4gICAgbGV0IHBvcyA9IF9wYXRoLmluZGV4T2YoXCJoZXJlbWFwXCIpO1xyXG4gICAgX2hvbWUgPSBfcGF0aC5zdWJzdHJpbmcoMCwgcG9zICsgXCJoZXJlbWFwXCIubGVuZ3RoKSArIFwiL1wiO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRvIGNvbmZpZ3VyZSBhcHBfaWQsIGFwcF9jb2RlIGFuZCBvcHRpb25hbGx5IHVzZSBDSVQgYW5kIGh0dHBcclxuICogQGFsaWFzIGhtOmNvbmZpZ1xyXG4gKlxyXG4gKiBAcGFyYW0gb3B0IHtPYmplY3R9ICAtIGBvcHRgIHdpdGggcGFyYW1ldGVycy5cclxuICogQHBhcmFtIFtvcHQuYXBwX2lkXSB7c3RyaW5nfSAtIHRoZSBhcHBfaWQgZnJvbSBkZXZlbG9wZXIuaGVyZS5jb21cclxuICogQHBhcmFtIFtvcHQuYXBwX2NvZGVdIHtzdHJpbmd9IC0gdGhlIGFwcF9jb2RlIGZyb20gZGV2ZWxvcGVyLmhlcmUuY29tXHJcbiAqIEBwYXJhbSBbb3B0LnVzZUNJVD1mYWxzZV0ge2Jvb2xlYW59IC0gdHJ1ZSB0byB1c2UgQ0lUIGVudmlyb25tZW50LiBcclxuICogQHBhcmFtIFtvcHQudXNlSFRUUD1mYWxzZV0ge3N0cmluZ30gLSB0cnVlIHRvIHVzZSBIVFRQLiBcclxuICogQHBhcmFtIFtvcHQudXNlSFRUUFM9dHJ1ZV0ge3N0cmluZ30gLSB0cnVlIHRvIHVzZSBIVFRQUy4gXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqICBobS5jb25maWcoe1xyXG4gKiAgICAgIGFwcF9pZDogXCJZT1VSIEFQUF9JRFwiLFxyXG4gKiAgICAgIGFwcF9jb2RlOiBcIllPVVIgQVBQX0NPREVcIixcclxuICogICB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlnKG9wdCkge1xyXG4gICAgaWYgKG9wdC5hcHBfaWQpIEFQUF9JRCA9IG9wdC5hcHBfaWQ7XHJcbiAgICBpZiAob3B0LmFwcF9jb2RlKSBBUFBfQ09ERSA9IG9wdC5hcHBfY29kZTtcclxuICAgIGlmIChvcHQudXNlQ0lUKSBDSVQgPSBcIi5jaXRcIjtcclxuICAgIGlmIChvcHQudXNlSFRUUCkge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwOlwiO1xyXG4gICAgICAgIF91c2VIVFRQUyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdC51c2VIVFRQUykge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwczpcIjtcclxuICAgICAgICBfdXNlSFRUUFMgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIFVSTCBvZiBtb2R1bGUgaG9tZSBkaXJlY3RvcnkuIFxyXG4gKiBzdmcgaWNvbnMgYXJlIHVuZGVyIGdldEhvbWUoKStcIi9zdmcvXCJcclxuICogaW1hZ2VzIGFyZSB1bmRlciBnZXRIb21lKCkrXCIvaW1nL1wiXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTpnZXRIb21lXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gdXJsIG9mIGhvbWUgZGlyZWN0b3J5IGluY2x1ZGluZyBodHRwIG9yIGh0dHBzLiBcclxuICovXHJcbmZ1bmN0aW9uIGdldEhvbWUoKSB7XHJcbiAgICByZXR1cm4gX2hvbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGFwcF9pZFxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0QXBwSWRcclxuICogQHJldHVybiB7c3RyaW5nfSBhcHBfaWRcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcElkKCkge1xyXG4gICAgcmV0dXJuIEFQUF9JRDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiBhcHBfY29kZVxyXG4gKiAgQGlnbm9yZVxyXG4gKiAgQGFsaWFzIGhtOmdldEhvbWVcclxuICogIEBhbGlhcyBobTpnZXRBcHBDb2RlXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gYXBwX2NvZGVcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcENvZGUoKSB7XHJcbiAgICByZXR1cm4gQVBQX0NPREU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdHJ1ZSBpZiB1c2luZyBDSVRcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06Z2V0Q0lUXHJcbiAqIEByZXR1cm4ge2Jvb29sZWFufSB0cnVlIGlmIHVzaW5nIENJVFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q0lUKCkge1xyXG4gICAgcmV0dXJuIENJVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiBwcm90b2NvbCB1c2VkLCBodHRwOi8vIG9yIGh0dHBzOi8vXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmdldFByb3RvY29sXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBwcm90b2NvbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gUFJPVE9DT0w7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdHJ1ZSBpcyBodHRwcyBpcyB1c2VkXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTp1c2VIVFRQU1xyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgaHR0cHMgaXMgdXNlZFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlSFRUUFMoKSB7XHJcbiAgICByZXR1cm4gX3VzZUhUVFBTO1xyXG59XHJcblxyXG4vKipcclxuICogYWRkIGNyZWRlbnRpYWxzIHRvIG9iamVjdCBwcm92aWRlZFxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06YWRkQ3JlZGVudGlhbHNcclxuICogQHBhcmFtICB7Li4ub2JqZWN0c30gbGlzdCBvZiBgb2JqZWN0c2AgXHJcbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGlucHV0IG9iamVjdGNvbmNhdGVuYXRlZCwgYW5kIGFwcF9pZC9hcHBfY29kZSBpbnNlcnRlZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ3JlZGVudGlhbHMoLi4ub2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgYXBwX2lkOiBBUFBfSUQsXHJcbiAgICAgICAgYXBwX2NvZGU6IEFQUF9DT0RFXHJcbiAgICB9LCAuLi5vYmopO1xyXG59XHJcblxyXG4vKipcclxuICogYnVpbGQgSEVSRSBSRVNUIGZ1bGwgdXJsLCB0YWtpbmcgaW4gYWNjb3VudCBwcm90b2NvbCBhbmQgY2l0LiBmb3IgaW5zdGFuY2UgIGNtLmJ1aWxkVXJsKFwiZ2VvY29kZXJcIiwgXCJhcGkuaGVyZS5jb20vNi4yL2dlb2NvZGUuanNvblwiXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIC0gYmFzZSBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIGVuZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGwgdXJsXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZFVybChiYXNlLCBlbmRwb2ludCkge1xyXG4gICAgcmV0dXJuIFBST1RPQ09MICsgXCIvL1wiICsgYmFzZSArIENJVCArIFwiLlwiICsgZW5kcG9pbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkb2VzIGdldC9wb3N0IHJlcXVlc3QgdG8gSEVSRSBSRVNEVCBiYWNrZW5kIGFuZCBtYW5hZ2UgbWFpbiBlcnJvcnNcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06aGVyZVJlc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAgLSB1cmwgdG8gY2FsbCAsIGZvciBpbnN0YW5jZSBmcm9tIGJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyAtIHNldHRpbmdzIHRvIGFkZCBpbiByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbW9kZT1nZXQgLSBtb2RlIFwiZ2V0XCIgb3IgXCJwb3N0XCJcclxuICogQHJldHVybiB7cHJvbWlzZX0gLSBwcm9taXNlIHRvIHJlc29sdmUvcmVqZWN0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBoZXJlUmVzdCh1cmwsIHNldHRpbmdzLCBtb2RlID0gXCJnZXRcIiwgbmVlZHJlc3AgPSBcInRydWVcIikge1xyXG5cclxuICAgIGxldCBwID0gcmVxdWVzdC5nZXQodXJsKTtcclxuICAgIGlmIChtb2RlID09IFwicG9zdFwiKVxyXG4gICAgICAgIHAgPSByZXF1ZXN0LnBvc3QodXJsKTtcclxuXHJcbiAgICByZXR1cm4gcFxyXG4gICAgICAgIC5xdWVyeShzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gXCIyMDBcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJFcnJvciBcIiArIHJlcy5zdGF0dXMgKyBcIjpcIiArIHJlcy5ib2R5KTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZWVkcmVzcCAmJiAhcmVzLmJvZHkuUmVzcG9uc2UgJiYgIXJlcy5ib2R5LnJlc3BvbnNlKSB7IC8vIG9uZSBvZiB0aGUgdHdvIHNob3VsZCBiZSBpbiB0aGUgYW5zd2VyXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5ib2R5KTtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUXVlcnkgZXJyb3I6XCIgKyByZXMuYm9keSk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLmJvZHkucmVzcG9uc2UgJiYgcmVzLmJvZHkucmVzcG9uc2UudHlwZSA9PSBcIkFwcGxpY2F0aW9uRXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkVycm9yXCIgKyByZXMuYm9keS5yZXNwb25zZS5kZXRhaWxzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29uZmlnOiBjb25maWcsXHJcbiAgICBidWlsZFVybDogYnVpbGRVcmwsXHJcbiAgICBnZXRBcHBJZDogZ2V0QXBwSWQsXHJcbiAgICBnZXRBcHBDb2RlOiBnZXRBcHBDb2RlLFxyXG4gICAgZ2V0Q0lUOiBnZXRDSVQsXHJcbiAgICBnZXRQcm90b2NvbDogZ2V0UHJvdG9jb2wsXHJcbiAgICBnZXRIb21lOiBnZXRIb21lLFxyXG4gICAgdXNlSFRUUFM6IHVzZUhUVFBTLFxyXG4gICAgYWRkQ3JlZGVudGlhbHM6IGFkZENyZWRlbnRpYWxzLFxyXG4gICAgaGVyZVJlc3Q6IGhlcmVSZXN0XHJcbn07IiwiLyoqXHJcbiAqIEBmaWxlIEdlb2NvZGluZyBmdW5jdGlvbnMgOiBhZGRyZXNzZXMgPC0tPiBbbGF0LGxuZ11cclxuICogQGF1dGhvciBEZXZiYWIgXHJcbiAqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIGdlb2NvZGUgYW4gYWRkcmVzc1xyXG4gKiBAYWxpYXMgaG06Z2VvY29kZVxyXG4gKiBAcGFyYW0gYWRkcmVzcyB7c3RyaW5nfSAgYWRkcmVzcyBhcyBzdHJpbmdcclxuICogQHJldHVybnMgIHtQcm9taXNlfSAgIHtjb29yZCxib2R5fS4gY29vcmQgaXMgZ2VvY29kZSBhcyBcXFtsYXQsbG5nXFxdLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHJlcyA9IGF3YWl0IGhtLmdlb2NvZGUoXCJhdmVudWUgZGVzIGNoYXBzIGVseXNlZXMsIHBhcmlzXCIpO1xyXG4gKiBjb25zb2xlLmxvZyAocmVzLmNvb3JkKTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW9jb2RlKGFkZHJlc3MpIHtcclxuXHJcbiAgICBjb25zdCBzZXR0aW5ncyA9IGNtLmFkZENyZWRlbnRpYWxzKHtcclxuICAgICAgICBzZWFyY2hUZXh0OiBhZGRyZXNzXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1cmwgPSBjbS5idWlsZFVybChcImdlb2NvZGVyXCIsIFwiYXBpLmhlcmUuY29tLzYuMi9nZW9jb2RlLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlcy5ib2R5LlJlc3BvbnNlLlZpZXcubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiR2VvY29kZSBBZGRyZXNzIG5vdCBmb3VuZDogXCIgKyBhZGRyZXNzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5ib2R5LlJlc3BvbnNlLlZpZXdbMF0uUmVzdWx0WzBdLkxvY2F0aW9uO1xyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBbbG9jYXRpb24uTmF2aWdhdGlvblBvc2l0aW9uWzBdLkxhdGl0dWRlLCBsb2NhdGlvbi5OYXZpZ2F0aW9uUG9zaXRpb25bMF0uTG9uZ2l0dWRlXTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgY29vcmQ6IGNvb3JkLCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHJldmVyc2UgZ2VvY29kZSBhIGNvb3JkaW5hdGVcclxuICogQGFsaWFzIGhtOnJldmVyc2VHZW9jb2RlXHJcbiAqIEBwYXJhbSBjb29yZCB7Q29vcmR9ICAtIGNvb3JkIFxcW2xhdCxsbmdcXF0gdG8gcmV2ZXJzZS1nZW9jb2RlXHJcbiAqIEByZXR1cm5zICB7UHJvbWlzZX0gcmV0dXJucyB7IGxvY2F0aW9uOm9iamVjdCwgYWRkcmVzczpvYmplY3QsIGJvZHk6b2JqZWN0fS4gXHJcbiAqL1xyXG5mdW5jdGlvbiByZXZlcnNlR2VvY29kZShjb29yZCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG1vZGU6IFwicmV0cmlldmVBZGRyZXNzZXNcIixcclxuICAgICAgICBwcm94OiBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicmV2ZXJzZS5nZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvcmV2ZXJzZWdlb2NvZGUuanNvblwiKTtcclxuXHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmJvZHkuUmVzcG9uc2UuVmlld1swXS5SZXN1bHRbMF0uTG9jYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiAoeyBsb2NhdGlvbjogbG9jYXRpb24sIGFkZHJlc3M6IGxvY2F0aW9uLkFkZHJlc3MsIGJvZHk6IHJlcy5ib2R5IH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZW9jb2RlOiBnZW9jb2RlLFxyXG4gICAgcmV2ZXJzZUdlb2NvZGU6IHJldmVyc2VHZW9jb2RlXHJcbn07XHJcblxyXG4iLCJjb25zdCBzaW1wbGlmeUpzID0gcmVxdWlyZShcInNpbXBsaWZ5LWpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYXJyYXkgb2YgW2xhdCxsbmddIHRvIGFycmF5IG9mIHt4LHl9XHJcbiAqIEBhbGlhcyBobTpjb29yZHMyWFlcclxuICogQHBhcmFtIHthcnJheX0gY29vcmRzIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gKiBAcmV0dXJuIHthcnJheX1hcnJheSBvZiB7eCx5fVxyXG4gKi9cclxuZnVuY3Rpb24gY29vcmRzMlhZKGNvb3Jkcykge1xyXG4gICAgcmV0dXJuIGNvb3Jkcy5tYXAoY29vcmQgPT4ge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IGNvb3JkWzFdLFxyXG4gICAgICAgICAgICB5OiBjb29yZFswXVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBhcnJheSBvZiB7eCx5fSB0byBhcnJheSBvZiBbbGF0LGxuZ11cclxuICogQGFsaWFzIGhtOnh5MkNvb3Jkc1xyXG4gKiBAcGFyYW0ge2FycmF5fSBjb29yZHMgYXJyYXkgb2Yge3gseX0gXHJcbiAqIEByZXR1cm4ge2FycmF5fWFycmF5IG9mIFtsYXQsbG5nXVxyXG4gKi9cclxuZnVuY3Rpb24geHkyQ29vcmRzKHh5cykge1xyXG4gICAgcmV0dXJuIHh5cy5tYXAoeHkgPT4gW3h5LnksIHh5LnhdKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBvYmplY3Qge2xhdCxsbmd9IHRvIFtsYXQsbG5nXVxyXG4gKiBAYWxpYXMgaG06Y29vcmRPMkFcclxuICogQHBhcmFtIHtvYmplY3R9IG9iaiB7bGF0LGxuZ31cclxuICogQHJldHVybiB7YXJyYXl9IFtsYXQsbG5nXVxyXG4gKi9cclxuZnVuY3Rpb24gY29vcmRPMkEob2JqKSB7XHJcbiAgICByZXR1cm4gW29iai5sYXQsIG9iai5sbmddO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydCBhbiBhcnJheSBbbGF0LGxuZ10gdG8ge2xhdCxsbmd9XHJcbiAqIEBhbGlhcyBobTpjb29yZEEyT1xyXG4gKiBAcGFyYW0ge29iamVjdH0gYXJyIFtsYXQsbG5nXVxyXG4gKiBAcmV0dXJuIHthcnJheX0ge2xhdCxsbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjb29yZEEyTyhhcnIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGF0OiBhcnJbMF0sXHJcbiAgICAgICAgbG5nOiBhcnJbMV1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ29udmVydCBbbGF0LGxuZ10gdG8ge2xhdCxsbmd9XHJcbiAqIEBhbGlhcyBobTpjb29yZDJQb2ludFxyXG4gKiBAcGFyYW0ge2FycmF5fSBbbGF0LGxuZ11cclxuICogQHJldHVybiB7YXJyYXl9e2xhdCxsbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBjb29yZDJQb2ludChjb29yZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsYXQ6IGNvb3JkWzBdLFxyXG4gICAgICAgIGxuZzogY29vcmRbMV1cclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQge2xhdCxsbmd9IHRvIFtsYXQsbG5nXVxyXG4gKiBAYWxpYXMgaG06cG9pbnQyQ29vcmRcclxuICogQHBhcmFtIHthcnJheX0ge2xhdCxsbmd9IFxyXG4gKiBAcmV0dXJuIHthcnJheX1bbGF0LGxuZ11cclxuICovXHJcbmZ1bmN0aW9uIHBvaW50MkNvb3JkKHBvaW50KSB7XHJcbiAgICByZXR1cm4gW3BvaW50LmxhdCwgcG9pbnQubG5nXTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNpbXBsaWZ5IGEgcG9seWxpbmUgYnkgdXNpbmcgdGhlIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cclxuICogQGFsaWFzIGhtOnNpbXBsaWZ5XHJcbiAqIEBwYXJhbSB7YXJyYXl9IGNvb3JkcyBhcnJheSBvZiBbbGF0LGxuZ11cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBcclxuICogQHJldHVybiB7YXJyYXl9IHNpbXBsaWZpZWQgcG9seWxpbmVcclxuICovXHJcbmZ1bmN0aW9uIHNpbXBsaWZ5KGNvb3JkcywgdG9sZXJhbmNlLCBoaWdoYWNjID0gZmFsc2UpIHtcclxuXHJcbiAgICAvLyBjb252ZXJ0IHRvIHh5XHJcbiAgICBsZXQgeHkgPSBjb29yZHMyWFkoY29vcmRzKTtcclxuICAgIGxldCBzaW1wbGlmaWVkID0gc2ltcGxpZnlKcyh4eSwgdG9sZXJhbmNlLCBoaWdoYWNjKTtcclxuXHJcbiAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGggPCAxKSAvLyBub3QgZW5vdWdoIHBvaW50c1xyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcblxyXG4gICAgLy8gY29udmVydCBiYWNrIHRvIFtsYXQsbG5nXVxyXG4gICAgcmV0dXJuIHh5MkNvb3JkcyhzaW1wbGlmaWVkKTtcclxufVxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNvb3JkTzJBOiBjb29yZE8yQSxcclxuICAgIGNvb3JkQTJPOiBjb29yZEEyTyxcclxuICAgIGNvb3JkczJYWTogY29vcmRzMlhZLFxyXG4gICAgeHkyQ29vcmRzOiB4eTJDb29yZHMsXHJcbiAgICBjb29yZDJQb2ludDogY29vcmQyUG9pbnQsXHJcbiAgICBwb2ludDJDb29yZDogcG9pbnQyQ29vcmQsXHJcbiAgICBzaW1wbGlmeTogc2ltcGxpZnlcclxufTsiLCIvKiBnbG9iYWwgSCwgZmV0Y2gsIHdpbmRvdywgZG9jdW1lbnQsIG5hdmlnYXRvciwgbWFwc2pzLCB3aW5kb3cgQVBQX0lEX0pBUEFOLEFQUF9DT0RFX0pBUEFOLEFQUF9JRF9LT1JFQSxBUFBfQ09ERV9LT1JFQSovXHJcblxyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5jb25zdCBnID0gcmVxdWlyZShcIi4vZ2VvbWV0cnkuanNcIik7XHJcblxyXG5sZXQgX3BsYXRmb3JtID0gbnVsbDtcclxubGV0IF9wcm92aWRlciA9IG51bGw7XHJcbmxldCBfZGVmYXVsdExheWVycyA9IG51bGw7XHJcbmxldCBfdWkgPSBudWxsO1xyXG5sZXQgX21hcCA9IG51bGw7XHJcbmxldCBfYmVoYXZpb3IgPSBudWxsO1xyXG5sZXQgZ3JvdXAgPSBudWxsO1xyXG5sZXQgX2xheWVycyA9IFtdOyAvLyBsaXN0IGFsbCBsYXllcnNcclxubGV0IF9rZXkgPSB7fTsgLy8ga2V5cyAgXHJcbmxldCBfYnViYmxlTWFya2VyID0gbnVsbDsgLy8gYnViYmxlIGRlIG1hbXJrZXJcclxubGV0IF9zY2hlbWUgPSBcIm5vcm1hbC5kYXkuZ3JleVwiO1xyXG5sZXQgX2xvY2F0ZU1lID0gbnVsbDsgLy8gaWQgd2hlbiBsb2NhdGUgaXMgYWN0aXZlXHJcbmxldCBfaHRtbEl0ZW0gPSBudWxsOyAvL3RoZSBodG1sIGl0ZW0gb24gd2hpY2ggdG8gcHV0IHRoZSBtYXBcclxubGV0IF9odG1sSXRlbUlkID0gbnVsbDsgLy90aGUgaWQgb2YgaHRtbCBpdGVtIG9uIHdoaWNoIHRvIHB1dCB0aGUgbWFwXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlIGEgbWFwIGFyZWEgd2l0aGluIHRoZSBzcGVjaWZpZWQgaXRlbVxyXG4gICogQGFsaWFzIGhtOm1hcFxyXG5cclxuICogQHBhcmFtIGh0bWxJdGVtIHtzdHJpbmd9ICAtIGlkZW50aWZpZXIgb2YgaHRtbCBkaXYgaXRlbSBvbiB3aGljaCB0byBpbnNlcnQgbWFwXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gIC0gb3B0aW9uc1xyXG4gKiBAcGFyYW0gW29wdC56b29tPTEwXSB7bnVtYmVyfSAgLSB6b29tIGZhY3RvclxyXG4gKiBAcGFyYW0gW29wdC5jZW50ZXI9WzQ4Ljg2LCAyLjNdXSB7Q29vcmR9ICAtIENvb3JkIG9mIHRoZSBjZW50ZXJcclxuICogQHBhcmFtIFtvcHQuc2NoZW1lPW5vcm1hbC5kYXkuZ3JleV0ge3N0cmluZ30gIC0gYW55IHNjaGVtZSBkZWZpbmVkIGJ5IEhFUkUsIHBsdXMgXCJqYXBhblwiLCBcImtvcmVhXCIsIFwiYmxhY2tcIiwgXCJ3aGl0ZVwiLCBcInRyYW5zcGFyZW50XCIuIEZvciBqYXBhbi9rb3JlYSwgb25lIG5lZWRzIHNwZWNpYWwgY3JlZGVudGlhbHMgYXMgQVBQX0lEX0pBUEFOIEFQUF9LT1JFQSBBUFBfQ09ERV9KQVBBTiBBUFBfQ09ERV9LT1JFQVxyXG4gKiBAcGFyYW0gW29wdC5jbGljaz1udWxsXSB7ZnVuY3Rpb24oKX0gIC0gY2FsbGJhY2sgb24gbW91c2UgY2xpY2s6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmRiQ2xpY2s9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGRvdWJsZSBjbGljazogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQuY2xpY2tMZWZ0PW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgb24gbW91c2UgY2xpY2sgbGVmdDogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQuY2xpY2tSaWdodD1udWxsXSB7ZnVuY3Rpb24oKX0gIC0gY2FsbGJhY2sgb24gbW91c2UgY2xpY2sgcmlnaHQuOiBjYWxsYmFjayhjb29yZCxidXR0b24sa2V5KVxyXG4gKiBAcGFyYW0gW29wdC5rZXlEb3duPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgb24ga2V5IGRvd24gOiBjYWxsYmFjayhrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LnZpZXdDaGFuZ2U9bnVsbF0ge2Z1bmN0aW9ufSAgLSBjYWxsYmFjayBpZiBtYXAgaXMgcGFubmVkIG9yIHpvb21lZCA6IGNhbGxiYWNrKHpvb20sY29vcmRDZW50ZXIpXHJcbiAqIEBwYXJhbSBbb3B0LmxvYWRUaWxlPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgd2hlbiBhIHRpbGUgaXMgbG9hZGVkIDogY2FsbGJhY2soeix4LHksdXJsKVxyXG4gKiBAcGFyYW0gW29wdC5yZW5kZXJlZD1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIHdoZW4gcmVuZGVyIGlzIGNvbXBsZXRlZCA6IGNhbGxiYWNrKGV2ZW50KVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCBobSA9IHdpbmRvdy5oZXJlbWFwO1xyXG4gKiBcclxuICogaG0uY29uZmlnKHtcclxuICogICAgYXBwX2lkOiBcIllPVVIgQVBQX0lEXCIsXHJcbiAqICAgIGFwcF9jb2RlOiBcIllPVVIgQVBQX0NPREVcIixcclxuICogfSk7XHJcbiAqXHJcbiAqIGhtLm1hcChcIm1hcFwiLCB7XHJcbiAqICAgIHpvb206NSxcclxuICogICAgY2VudGVyOiBbNDguOCwyLjNdLFxyXG4gKiAgICBjbGljazogZnVuY3Rpb24oY29vcmQsYnV0dG9uLGtleSkge2NvbnNvbGUubG9nKFwiY2xpY2tlZCBvblwiLGNvb3JkLFwid2l0aCBidXR0b25cIixidXR0b24pO31cclxuICogfSk7XHJcbiogIGBgYFxyXG4qL1xyXG5mdW5jdGlvbiBtYXAoaHRtbEl0ZW0sIG9wdCkge1xyXG5cclxuICAgIF9odG1sSXRlbSA9IGh0bWxJdGVtO1xyXG4gICAgX2h0bWxJdGVtSWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sSXRlbSk7XHJcblxyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIHpvb206IDEwLFxyXG4gICAgICAgIGNlbnRlcjogWzQ4Ljg2LCAyLjNdLFxyXG4gICAgICAgIGNsaWNrTGVmdDogbnVsbCxcclxuICAgICAgICBjbGlja1JpZ2h0OiBudWxsLFxyXG4gICAgICAgIGtleURvd246IG51bGwsIC8vIGtleWJvYXJkIGV2ZW50XHJcbiAgICAgICAgY2xpY2s6IG51bGwsXHJcbiAgICAgICAgZGJDbGljazogbnVsbCxcclxuICAgICAgICB2aWV3Q2hhbmdlOiBudWxsLCAvLyAoem9vbSxjb29yZClcclxuICAgICAgICByZW5kZXI6IG51bGwsIC8vICgpXHJcbiAgICAgICAgbG9hZFRpbGU6IG51bGwgLy8gcXVhbmQgdW5lIHRpbGUgZXN0IGFmZmljaMOpZVxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgbXBzID0gMTtcclxuXHJcbiAgICBsZXQgYXBwX2lkID0gY20uZ2V0QXBwSWQoKTtcclxuICAgIGxldCBhcHBfY29kZSA9IGNtLmdldEFwcENvZGUoKTtcclxuXHJcbiAgICBpZiAoIWFwcF9pZCB8fCAhYXBwX2NvZGUpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImFwcF9pZC9hcHBfY29kZSBub3QgaW5pdGlhbGlzZWRcIik7XHJcbiAgICAgICAgX2h0bWxJdGVtSWQuaW5uZXJIVE1MID0gXCJhcHBfaWQvYXBwX2NvZGUgbm90IGluaXRpYWxpc2VkXCI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIF9wbGF0Zm9ybSA9IG5ldyBILnNlcnZpY2UuUGxhdGZvcm0oe1xyXG4gICAgICAgIGFwcF9pZDogYXBwX2lkLFxyXG4gICAgICAgIGFwcF9jb2RlOiBhcHBfY29kZSxcclxuICAgICAgICB1c2VDSVQ6IGNtLmdldENJVCgpLFxyXG4gICAgICAgIHVzZUhUVFBTOiBjbS51c2VIVFRQUygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG4gICAgaWYgKHNldHRpbmdzLnNjaGVtZSlcclxuICAgICAgICBfc2NoZW1lID0gc2V0dGluZ3Muc2NoZW1lOyAvLyBzdG9yZSBzY2hlbWUgaWYgZGVmaW5lZFxyXG5cclxuICAgIC8vIHdoaXRlIGJhY2tncm91bmQgZm9yIHRlc3RcclxuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpO1xyXG4gICAgaWYgKHNlYXJjaFBhcmFtcy5nZXQoXCJkZW1vdGVzdFwiKSA9PSAxKSBfc2NoZW1lID0gXCJ3aGl0ZVwiO1xyXG5cclxuXHJcbiAgICBfZGVmYXVsdExheWVycyA9IF9wbGF0Zm9ybS5jcmVhdGVEZWZhdWx0TGF5ZXJzKCk7XHJcblxyXG4gICAgLy8gaHR0cDovL2hlcmVtYXBzLmdpdGh1Yi5pby9leGFtcGxlcy9leHBsb3Jlci5odG1sI21hcC10aWxlc19fYmFzZS1tYXAtc3R5bGVzLWFuZC1tb2Rlc1xyXG4gICAgX3Byb3ZpZGVyID0gbmV3IEgubWFwLnByb3ZpZGVyLkltYWdlVGlsZVByb3ZpZGVyKHtcclxuICAgICAgICBsYWJlbDogXCJCYXNlIFByb3ZpZGVyXCIsXHJcbiAgICAgICAgZGVzY3I6IFwiXCIsXHJcbiAgICAgICAgbWluOiAwLFxyXG4gICAgICAgIG1heDogMjAsXHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXHJcbiAgICAgICAgZ2V0VVJMOiBmdW5jdGlvbiAoY29sLCByb3csIGxldmVsKSB7XHJcbiAgICAgICAgICAgIG1wcysrO1xyXG4gICAgICAgICAgICBpZiAobXBzID4gNCkgbXBzID0gMTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IFtjbS5nZXRQcm90b2NvbCgpLCBcIi8vXCIsIG1wcywgXCIuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlLmNvbS9tYXB0aWxlL1wiLCBcIjIuMVwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwibWFwdGlsZVwiLCBcIi9cIiwgXCJuZXdlc3RcIiwgXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBfc2NoZW1lLCBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwicG5nXCIsIFwiP2xnPVwiLCBcIkZSRVwiLFxyXG4gICAgICAgICAgICAgICAgXCImYXBwX2NvZGU9XCIsIGFwcF9jb2RlLCBcIiZhcHBfaWQ9XCIsXHJcbiAgICAgICAgICAgICAgICBhcHBfaWRcclxuICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9zY2hlbWUgPT0gXCJqYXBhblwiKVxyXG4gICAgICAgICAgICAgICAgdXJsID0gW2NtLmdldFByb3RvY29sKCksIFwiLy9cIiwgXCJtLmxic1wiICsgY20uZ2V0Q0lUKCkgKyBcIi5hcGkuaGVyZW1hcHMuanAvdjEvbWFwP2FwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfSURfSkFQQU4sXHJcbiAgICAgICAgICAgICAgICAgICAgXCImYXBwX2NvZGU9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgQVBQX0NPREVfSkFQQU4sXHJcbiAgICAgICAgICAgICAgICAgICAgXCImdGlsZW1hdHJpeD1FUFNHOjkwMDkxMzpcIixcclxuICAgICAgICAgICAgICAgICAgICBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlY29sPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbCxcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlcm93PVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvd1xyXG4gICAgICAgICAgICAgICAgXS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcImtvcmVhXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIjMuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5rci9tYXB0aWxlLzIuMS9tYXB0aWxlLzM0NDM5MzQ4YzMvbm9ybWFsLmRheS9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiLCBcInBuZ1wiLCBcIj9sZz1cIiwgXCJGUkVcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIiwgQVBQX0NPREVfS09SRUEsIFwiJmFwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfSURfS09SRUFcclxuICAgICAgICAgICAgICAgIF0uam9pbihcIlwiKTtcclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9zY2hlbWUgPT0gXCJibGFja1wiKVxyXG4gICAgICAgICAgICAgICAgdXJsID0gY20uZ2V0SG9tZSgpICsgXCJwbmcvYmxhY2sucG5nXCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9zY2hlbWUgPT0gXCJ3aGl0ZVwiKVxyXG4gICAgICAgICAgICAgICAgdXJsID0gY20uZ2V0SG9tZSgpICsgXCJwbmcvd2hpdGUucG5nXCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9zY2hlbWUgPT0gXCJ0cmFuc3BhcmVudFwiKVxyXG4gICAgICAgICAgICAgICAgdXJsID0gY20uZ2V0SG9tZSgpICsgXCJwbmcvdHJhbnNwYXJlbnQucG5nXCI7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmxvYWRUaWxlKVxyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubG9hZFRpbGUobGV2ZWwsIGNvbCwgcm93LCB1cmwpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBfX2xheWVyID0gbmV3IEgubWFwLmxheWVyLlRpbGVMYXllcihfcHJvdmlkZXIpO1xyXG5cclxuICAgIC8vY29uc29sZS5sb2coXCJub3JtYWwgbWFwXCIpO1xyXG4gICAgLy9TdGVwIDI6IGluaXRpYWxpemUgYSBIRVJFTWFwIFxyXG4gICAgX21hcCA9IG5ldyBILk1hcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sSXRlbSksXHJcbiAgICAgICAgX19sYXllciwge1xyXG4gICAgICAgICAgICBjZW50ZXI6IGcuY29vcmRBMk8oc2V0dGluZ3MuY2VudGVyKSxcclxuICAgICAgICAgICAgem9vbTogc2V0dGluZ3Muem9vbVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIF9iZWhhdmlvciA9IG5ldyBILm1hcGV2ZW50cy5CZWhhdmlvcihuZXcgSC5tYXBldmVudHMuTWFwRXZlbnRzKF9tYXApKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgVUkgY29tcG9uZW50c1xyXG4gICAgX3VpID0gSC51aS5VSS5jcmVhdGVEZWZhdWx0KF9tYXAsIF9kZWZhdWx0TGF5ZXJzKTtcclxuXHJcbiAgICAvLyBjcmVhdGUgZGVmYXVsdCBsYXllclxyXG4gICAgbGF5ZXJDcmVhdGUoXCJkZWZhdWx0XCIpO1xyXG5cclxuICAgIC8vIGlmIGNhbGxiYWNrIG9uIHpvb20gQ2hhbmdlXHJcbiAgICBpZiAoc2V0dGluZ3Mudmlld0NoYW5nZSkge1xyXG4gICAgICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hcHZpZXdjaGFuZ2VlbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgYm91bmQgPSBfbWFwLmdldFZpZXdCb3VuZHMoKTtcclxuICAgICAgICAgICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpZXdDaGFuZ2UgY2VudGVyIFwiICsgbGF0ICsgXCIgXCIgKyBsbmcpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy52aWV3Q2hhbmdlKF9tYXAuZ2V0Wm9vbSgpLCBbbGF0LCBsbmddKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogICAgICAgICAgIHRvIGhhbmRsZSBrZXlib2FyZCB3aGlsZSBtb3VzZSBpbiBtYXAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgbGV0IGt1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfa2V5LmN0cmwgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LnNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgX2tleS5hbHQgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LmtleSA9IFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBrZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgX2tleS5jdHJsID0gKChlLmtleSA9PSBcIkNvbnRyb2xcIikgfHwgKGUua2V5SWRlbnRpZmllciA9PSBcIkNvbnRyb2xcIikgfHwgKGUuY3RybEtleSA9PSB0cnVlKSk7XHJcbiAgICAgICAgX2tleS5zaGlmdCA9ICgoZS5rZXkgPT0gXCJTaGlmdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiU2hpZnRcIikgfHwgKGUuc2hpZnRLZXkgPT0gdHJ1ZSkpO1xyXG4gICAgICAgIF9rZXkuYWx0ID0gKChlLmtleSA9PSBcIkFsdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiQWx0XCIpIHx8IChlLnNoaWZ0S2V5ID09IHRydWUpKTtcclxuICAgICAgICBfa2V5LmtleSA9IGUua2V5O1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5rZXlEb3duKSBzZXR0aW5ncy5rZXlEb3duKF9rZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1hcCBtb3VzZSBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJtYXAgcG9pbnRlciBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWFwIG1vdXNlIGxlYXZlXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIGRvdWJsZSBjbGljayAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZGJsdGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikgcmV0dXJuOyAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBjbGljayBvbiBtYXJrZXJcclxuXHJcbiAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2LmN1cnJlbnRQb2ludGVyLmJ1dHRvbjtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGJDbGljaykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRiQ2xpY2soZy5jb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kYkNsaWNrKGcuY29vcmRPMkEoY29vcmQpLCBcInJpZ2h0XCIsIF9rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqICAgICAgICAgICB0byBoYW5kbGUgc2ltcGxlIGNsaWNrICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZXYuY3VycmVudFBvaW50ZXIuYnV0dG9uO1xyXG5cclxuICAgICAgICBpZiAoKGJ1dHRvbiA9PSAwKSAmJiAoc2V0dGluZ3MuY2xpY2tMZWZ0KSlcclxuICAgICAgICAgICAgc2V0dGluZ3MuY2xpY2tMZWZ0KGcuY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgaWYgKChidXR0b24gPT0gMikgJiYgKHNldHRpbmdzLmNsaWNrUmlnaHQpKVxyXG4gICAgICAgICAgICBzZXR0aW5ncy5jbGlja1JpZ2h0KGcuY29vcmRPMkEoY29vcmQpLCBcInJpZ2h0XCIsIF9rZXkpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jbGljaykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNsaWNrKGcuY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2xpY2soZy5jb29yZE8yQShjb29yZCksIFwicmlnaHRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKioqKioqKioqICBkaXNhYmxlIHRoZSBkZWZhdWx0IGRyYWdnYWJpbGl0eSBvZiB0aGUgdW5kZXJseWluZyBtYXAgd2hlbiBzdGFydGluZyB0byBkcmFnIGEgbWFya2VyIG9iamVjdCAqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdzdGFydFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBILm1hcC5NYXJrZXIgfHwgdGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuRG9tTWFya2VyKSB7XHJcbiAgICAgICAgICAgIF9iZWhhdmlvci5kaXNhYmxlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqICAgcmUgLSBlbmFibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIGRyYWdnaW5nIGhhcyBjb21wbGV0ZWQgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uIChldikge1xyXG5cclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLk1hcmtlciB8fCB0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLkRvbU1hcmtlcikge1xyXG4gICAgICAgICAgICBfYmVoYXZpb3IuZW5hYmxlKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0LmRyb3BwYWJsZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZHJhZ2dlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgICAgICAodGFyZ2V0LmRyYWdnZWQpKHRhcmdldCwgZy5jb29yZE8yQShjb29yZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kcmFnKSB7XHJcbiAgICAgICAgICAgIChzZXR0aW5ncy5kcmFnKShcImRyYWdlbmRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogIExpc3RlbiB0byB0aGUgZHJhZyBldmVudCBhbmQgbW92ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBhcyBuZWNlc3NhcnkgKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldCxcclxuICAgICAgICAgICAgcG9pbnRlciA9IGV2LmN1cnJlbnRQb2ludGVyO1xyXG5cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgbWFwc2pzLm1hcC5NYXJrZXIgfHwgdGFyZ2V0IGluc3RhbmNlb2YgbWFwc2pzLm1hcC5Eb21NYXJrZXIpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZHJvcHBhYmxlKSAvLyBkb24ndCBtb3ZlIHRoZSBtYXJrZXIgaWYgZHJvcHBhYmxlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRQb3NpdGlvbihfbWFwLnNjcmVlblRvR2VvKHBvaW50ZXIudmlld3BvcnRYLCBwb2ludGVyLnZpZXdwb3J0WSkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZHJhZykge1xyXG4gICAgICAgICAgICAoc2V0dGluZ3MuZHJhZykoXCJkcmFnXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqICBkZXRlY3QgbWFwIHJlc2l6ZSBhbmQgYWRqdXN0IGFjY29yaWRuZ2x5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbWFwLmdldFZpZXdQb3J0KCkucmVzaXplKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKiAgY2FsbGJhY2sgZm9yIHJlbmRlcmluZyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBpZiAoc2V0dGluZ3MucmVuZGVyZWQpIHtcclxuICAgICAgICBfbWFwLmdldEVuZ2luZSgpLmFkZEV2ZW50TGlzdGVuZXIoXCJyZW5kZXJcIiwgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChfbWFwLmdldEVuZ2luZSgpID09PSBldi50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlbmRlcmVkKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfbWFwO1xyXG59XHJcblxyXG4vKipcclxuICogbGlzdCBvZiBhbGwgYXZhaWxhYmxlIG1hcCBzdHlsZXMgbm9ybWFsLmRheSwgbmlnaHQuLi4uIFxyXG4gKiBAYWxpYXMgaG06Z2V0QXZhaWxhYmxlTWFwU3R5bGVcclxuICogQHJldHVybiB7anNvbn0gbGlzdCBvZiBtYXAgc3R5bGVzIGFzIGpzb25cclxuICovXHJcbmZ1bmN0aW9uIGdldEF2YWlsYWJsZU1hcFN0eWxlKCkge1xyXG4gICAgLy8gaHR0cHM6Ly8xLmJhc2UubWFwcy5hcGkuaGVyZS5jb20vbWFwdGlsZS8yLjEvaW5mbz94bmxwPUNMX0pTTXYzLjAuMTcuMCZhcHBfaWQ9bk9TaDIxMjE0SkZNU0VQUWtxbm8mYXBwX2NvZGU9clhfbDdZdkFMdE5rcVUyYng1RldFQSZvdXRwdXQ9anNvblxyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG91dHB1dDogXCJqc29uXCJcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiMS5iYXNlLm1hcHNcIiwgXCJhcGkuaGVyZS5jb20vbWFwdGlsZS8yLjEvaW5mb1wiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHNldHRpbmdzKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuYm9keS5yZXNwb25zZTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRlZmluZSB0aGUgc2NoZW1lLiBMaXN0IG9mIHNjaGVtZSBjYW4gYmUgb2J0YWluZWQgZnJvbSBobS5nZXRBdmFpbGFibGVNYXBTdHlsZSgpXHJcbiAqIEBhbGlhcyBobTpzZXRTY2hlbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtZSBzY2hlbWUgbmFtZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0U2NoZW1lKHNjaGVtZSkge1xyXG4gICAgX3NjaGVtZSA9IHNjaGVtZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhIGxheWVyXHJcbiAqIEBhbGlhcyBobTpsYXllckNyZWF0ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgLSBuYW1lIG9mIGxheWVyXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZSAgLSBpbml0aWFsIHN0YXR1c1xyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBobS5sYXllckNyZWF0ZShcImxheWVyMVwiKTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJDcmVhdGUobmFtZSwgdmlzaWJsZSkge1xyXG4gICAgZ3JvdXAgPSBuZXcgSC5tYXAuR3JvdXAoKTtcclxuICAgIGdyb3VwLm5hbWUgPSBuYW1lO1xyXG4gICAgX21hcC5hZGRPYmplY3QoZ3JvdXApO1xyXG5cclxuICAgIC8vIHB1c2ggaW50byBsaXN0IG9mIGxheWVyc1xyXG4gICAgX2xheWVycy5wdXNoKGdyb3VwKTtcclxuXHJcbiAgICAvLyBjYW4gYmUgdmlzaWJsZSBvciBoaWRkZW5cclxuICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgIGdyb3VwLnNldFZpc2liaWxpdHkodmlzaWJsZSk7XHJcblxyXG4gICAgcmV0dXJuIGdyb3VwO1xyXG59XHJcblxyXG4vKipcclxuICogZGVsZXRlIGEgbGF5ZXJcclxuICogQGFsaWFzIGhtOmxheWVyRGVsZXRlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgbGF5ZXJcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyRGVsZXRlKG5hbWUpIHtcclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChuYW1lKTtcclxuICAgIGlmICghbGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIC8vIHJlbW92ZSBncm91cCBmcm9tIG1hcFxyXG4gICAgX21hcC5yZW1vdmVPYmplY3QobGF5ZXIpO1xyXG4gICAgLy9yZW1vdmUgZm9ybSBsaXN0IG9mIGxheWVyc1xyXG4gICAgX2xheWVycyA9IF9sYXllcnMuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgIHJldHVybiBpdGVtLm5hbWUgIT09IG5hbWU7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVtcHR5IGEgbGF5ZXIsIG9yIGNyZWF0ZSBpdCBpZiBub3QgZXhpc3RpbmdcclxuICogQGFsaWFzIGhtOmxheWVyRW1wdHlcclxuICogQHBhcmFtIHtzdHJpbmd9IGxheWVyIFxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJFbXB0eShuYW1lKSB7XHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQobmFtZSk7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGF5ZXJDcmVhdGUobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGF5ZXIucmVtb3ZlQWxsKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJTZXRWaXNpYmlsaXR5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAtIG5hbWUgb2YgbGF5ZXJcclxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlICAtIHZpc2libGUgb3Igbm90XHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLmxheWVyVmlzaWJsZShcImxheWVyMVwiLHRydWUpO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllclNldFZpc2liaWxpdHkobmFtZSwgdmlzaWJsZSkge1xyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKG5hbWUpO1xyXG4gICAgaWYgKCFsYXllcilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgbGF5ZXIuc2V0VmlzaWJpbGl0eSh2aXNpYmxlKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBmaW5kIGxheWVyIGJ5IGl0cyBuYW1lIG9yIHJldHVybiBudWxsIFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJGaW5kXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJGaW5kKG5hbWUpIHtcclxuICAgIGxldCBsID0gX2xheWVycy5maW5kKGxheWVyID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5ZXIubmFtZSA9PSBuYW1lO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIGwgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gbDtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBzZXQgY2VudGVyIG9mIHRoZSBtYXBcclxuICogQGFsaWFzIGhtOnNldENlbnRlclxyXG4gKiBAcGFyYW0ge0FycmF5fSAtIGNvb3JkIGFzIFtsYXQsbG5nXVxyXG4gKiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLnNldENlbnRlcihbNDguOCwyLjNdKTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2VudGVyKGNvb3JkKSB7XHJcbiAgICBfbWFwLnNldENlbnRlcihnLmNvb3JkQTJPKGNvb3JkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXBcclxuICogQGFsaWFzIGhtOmdldENlbnRlclxyXG4gKiBAcmV0dXJucyB7Y29vcmR9IGNvb3JkIG9mIHRoZSBjZW50ZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xyXG4gICAgbGV0IGJvdW5kID0gX21hcC5nZXRWaWV3Qm91bmRzKCk7XHJcbiAgICAvL19ITS5sb2coXCJ2aWV3Ym91bmRcIixib3VuZCk7XHJcblxyXG4gICAgbGV0IGxuZyA9IChib3VuZC5nYSArIGJvdW5kLmhhKSAvIDI7XHJcbiAgICBsZXQgbGF0ID0gKGJvdW5kLmthICsgYm91bmQuamEpIC8gMjtcclxuICAgIHJldHVybiBbbGF0LCBsbmddO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiBib3VuZGluZyBib3ggb2YgdmlzaWJsZSBwYXJ0IG9mIG1hcFxyXG4gKiBAYWxpYXMgaG06Z2V0Vmlld0JCXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdWRpbmcgYm94IG9mIHZpc2libGUgcGFydCBvZiB0aGUgbWFwLCBhcyBcXFtsYXRtLGxhdE0sbG9uZ20sbG5nTVxcXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Vmlld0JCKCkge1xyXG4gICAgbGV0IGJiID0gX21hcC5nZXRWaWV3Qm91bmRzKCk7XHJcblxyXG4gICAgbGV0IGJiMiA9IHtcclxuICAgICAgICBsYXRtOiBiYi5qYSxcclxuICAgICAgICBsYXRNOiBiYi5rYSxcclxuICAgICAgICBsbmdtOiBiYi5nYSxcclxuICAgICAgICBsbmdNOiBiYi5oYVxyXG4gICAgfTtcclxuICAgIHJldHVybiBiYjI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzZXRzIGJvdWRpbmcgYm94IHRvIGJlIGRpc3BsYXllZFxyXG4gKiBAYWxpYXMgaG06c2V0Vmlld0JCXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdHwgc3RyaW5nfSAgZWl0aGVyIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGhvdyB0byBzZXQgYm91bmRpbmcgYm94LCBvciAgYSBTdHJpbmcgYmVpbmcgdGhlIG5hbWUgb2YgYSBsYXllclxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge3N0cmluZ30gYm91ZGluZyBib3ggYXJvdWQgYWxsIG9iamVjdHMgb2YgdGhlIGxheWVyXHJcbiAqIEBwYXJhbSBbb3B0LnBvaXNdIHthcnJheX0gYm91ZGluZyBib3ggYXJvdWQgYWxsIGNvb3JkcyBkZWZpbmVkIGFzIFxcW2Nvb3JkLGNvb3JkLi4uXFxdXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLnNldFZpZXdCQihcImxheWVyMVwiKTtcclxuICpcclxuICogaG0uc2V0Vmlld0JCKHtcclxuICogICAgcG9pczogY29vcmRzXHJcbiAqIH0pO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRWaWV3QkIob3B0KSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHQgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICBvcHQgPSB7XHJcbiAgICAgICAgICAgIGxheWVyOiBvcHRcclxuICAgICAgICB9O1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogbnVsbCxcclxuICAgICAgICBwb2lzOiBudWxsIC8vIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGJib3g7XHJcblxyXG4gICAgLy9zZXQgQkIgYmFzZWQgb24gbGF5ZXJcclxuICAgIGlmIChzZXR0aW5ncy5sYXllcikge1xyXG4gICAgICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBnZXQgdmlldyBib3VuZCBhbmQgYWRkIGEgYml0IGFyb3VuZCwgbGlrZSAxLzVcclxuICAgICAgICBsZXQgYmIgPSBsYXllci5nZXRCb3VuZHMoKTtcclxuICAgICAgICBpZiAoIWJiKSAvLyBhcyBpZiBub3RoaW5nIGluIGxheWVyXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBiYi5sYXRtID0gYmIuamE7XHJcbiAgICAgICAgYmIubGF0TSA9IGJiLmthO1xyXG4gICAgICAgIGJiLmxuZ20gPSBiYi5nYTtcclxuICAgICAgICBiYi5sbmdNID0gYmIuaGE7XHJcbiAgICAgICAgbGV0IGR4ID0gYmIubG5nTSAtIGJiLmxuZ207XHJcbiAgICAgICAgbGV0IGR5ID0gYmIubGF0TSAtIGJiLmxhdG07XHJcbiAgICAgICAgZHggPSBkeCAvIDU7XHJcbiAgICAgICAgZHkgPSBkeSAvIDU7XHJcbiAgICAgICAgYmIubGF0TSArPSBkeTtcclxuICAgICAgICBiYi5sbmdtIC09IGR4O1xyXG4gICAgICAgIGJiLmxhdG0gLT0gZHk7XHJcbiAgICAgICAgYmIubG5nTSArPSBkeDtcclxuICAgICAgICBiYm94ID0gbmV3IEguZ2VvLlJlY3QoYmIubGF0TSwgYmIubG5nbSwgYmIubGF0bSwgYmIubG5nTSk7XHJcbiAgICAgICAgX21hcC5zZXRWaWV3Qm91bmRzKGJib3gsIHRydWUpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MucG9pcykge1xyXG4gICAgICAgIGxldCBiYiA9IHtcclxuICAgICAgICAgICAgbGF0TTogMCxcclxuICAgICAgICAgICAgbG5nbTogMTgwLFxyXG4gICAgICAgICAgICBsYXRtOiA5MCxcclxuICAgICAgICAgICAgbG5nTTogLTE4MCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBhcnIgPSBzZXR0aW5ncy5wb2lzO1xyXG4gICAgICAgIGFyci5mb3JFYWNoKChwb2kpID0+IHtcclxuICAgICAgICAgICAgaWYgKHBvaVswXSA+IGJiLmxhdE0pIGJiLmxhdE0gPSBwb2lbMF07XHJcbiAgICAgICAgICAgIGlmIChwb2lbMV0gPiBiYi5sbmdNKSBiYi5sbmdNID0gcG9pWzFdO1xyXG4gICAgICAgICAgICBpZiAocG9pWzBdIDwgYmIubGF0bSkgYmIubGF0bSA9IHBvaVswXTtcclxuICAgICAgICAgICAgaWYgKHBvaVsxXSA8IGJiLmxuZ20pIGJiLmxuZ20gPSBwb2lbMV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmJveCA9IG5ldyBILmdlby5SZWN0KGJiLmxhdE0sIGJiLmxuZ20sIGJiLmxhdG0sIGJiLmxuZ00pO1xyXG4gICAgICAgIF9tYXAuc2V0Vmlld0JvdW5kcyhiYm94LCB0cnVlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gem9vbSB2YWx1ZVxyXG4gKiBAYWxpYXMgaG06Z2V0Wm9vbVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIGxldmVsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRab29tKCkge1xyXG4gICAgcmV0dXJuIF9tYXAuZ2V0Wm9vbSgpO1xyXG59XHJcblxyXG4vKipcclxuICogc2V0IHpvb20gbGV2ZWxcclxuICogQGFsaWFzIGhtOnNldFpvb21cclxuICogQHBhcmFtIHtudW1iZXJ9IHpvb20gXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRab29tKHpvb20pIHtcclxuICAgIF9tYXAuc2V0Wm9vbSh6b29tKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEaXNwbGF5IGEgdW5pcXVlIGJ1YmJsZS4gQXNzb2NpYXRlZCBDU1Mgc3R5bGUgaXMgLkhfaWJfYm9keVxyXG4gKiBAYWxpYXMgaG06YnViYmxlVW5pcXVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkIG9mIHRoZSBidWJibGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHR4dCBodG1sIHRleHQgdG8gZGlzcGxheVxyXG4gKi9cclxuZnVuY3Rpb24gYnViYmxlVW5pcXVlKGNvb3JkLCB0eHQpIHtcclxuXHJcbiAgICBpZiAoIV9idWJibGVNYXJrZXIpIHtcclxuICAgICAgICBfYnViYmxlTWFya2VyID0gbmV3IEgudWkuSW5mb0J1YmJsZShcclxuICAgICAgICAgICAgZy5jb29yZEEyTyhjb29yZCksIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHR4dFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3VpLmFkZEJ1YmJsZShfYnViYmxlTWFya2VyKTtcclxuICAgICAgICBfYnViYmxlTWFya2VyLmFkZENsYXNzKFwiYnViYmxlVW5pcXVlXCIpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5zZXRQb3NpdGlvbihnLmNvb3JkQTJPKGNvb3JkKSk7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5zZXRDb250ZW50KHR4dCk7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5vcGVuKCk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIGhpZGUgYSB1bmlxdWUgYnViYmxlXHJcbiAqIEBhbGlhcyBobTpidWJibGVVbmlxdWVIaWRlXHJcbiAqL1xyXG5mdW5jdGlvbiBidWJibGVVbmlxdWVIaWRlKCkge1xyXG4gICAgaWYgKCFfYnViYmxlTWFya2VyKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIF9idWJibGVNYXJrZXIuY2xvc2UoKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlIGFuIGljb24sIHRvIGJlIHVzZWQgZm9yIGEgbWFya2VyXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06YnVpbGRJY29uXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBzcGVjaWZ5IHRoZSBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LmltZ10ge3N0cmluZ30gIHVzZSBhIHBuZy9qcGcgaW1hZ2UuIFNwZWNpZnkgdGhlIHVybCBcclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgdXJsIGEgc3ZnLiBUaGlzIGNhbiBiZSBhbiBpbmxpbmUgc3ZnLCBhIHVybCwgb3IgYSBzdmcgZnJvbSBoZXJlbWFwXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdF0ge29iamVjdH0gICBzdHlsZSBvYmplY3RcclxuICogQHBhcmFtIFtvcHQub3B0LnNpemVdIHtudW1iZXJ8c3RyaW5nfSAgIHNpemUgb2YgaWNvbiwgYXMgMjQgb3IgMjR4MzJcclxuICogQHBhcmFtIFtvcHQub3B0LnJhdGlvXSB7bnVtYmVyfSAgIGZvciBzdmcgZmlsZXMsIHJhdGlvIG9mIHNpemUuIDAuNSA9IGhhbGZcclxuICogQHBhcmFtIFtvcHQub3B0LmFuY2hvcl0ge251bWJlcnxzdHJpbmd9ICAgYW5jaG9yIG9mIGljb24sIGFzIDI0IG9yIFwiMjR4MzJcIiBvciBcImNlbnRlclwiLiBCeSBkZWZhdWx0LCBib3R0b20tY2VudGVyXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC50YWddIHtzdHJpbmd9ICBmb3Igc3ZnLCBhbnkgdGFnIGxpa2Uge3RhZ30gd2l0aGluIHRoZSBzdmcgZmlsZSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGl0cyBhc3NvY2lhdGVkIHZhbHVlXHJcbiAqIEByZXR1cm4ge0gubWFwLkljb259IHRoZSBjcmVhdGVkIGljb25cclxuICogQGV4YW1wbGUgXHJcbiAqIGBgYGpzXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIGltZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnBuZ1wiLFxyXG4gKiAgICBvcHQ6IHtzaXplOjI0fVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2ZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnN2Z1wiLFxyXG4gKiAgICBvcHQ6IHtcclxuICogICAgICAgcmF0aW86MC41LFxyXG4gKiAgICAgICBhbmNob3I6MjR4MzJcclxuICogICAgfVxyXG4gKiB9KTtcclxuICogIFxyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IFwiQHN2Zy9jbHVzdGVyLnN2Z1wiLFxyXG4gKiAgICBvcHQ6IHtcclxuICogICAgICAgc2l6ZToyNCxcclxuICogICAgICAgY29sb3I6XCJyZWRcIlxyXG4gKiAgICB9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogY29uc3Qgc3ZnID0gYDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPiA8ZWxsaXBzZSBzdHJva2U9XCJudWxsXCIgcnk9XCI4XCIgcng9XCI3LjYxODg5NlwiIGlkPVwic3ZnXzFcIiBjeT1cIjhcIiBjeD1cIjcuODM3NDI3XCIgZmlsbD1cIntjb2xvcn1cIiBmaWxsLW9wYWNpdHk9XCIwLjlcIi8+PC9zdmc+YDtcclxuICogaG0uYnVpbGRJY29uKHtcclxuICogICAgc3ZnOiBzdmcsXHJcbiAqICAgIG9wdDoge1xyXG4gKiAgICAgICBzaXplOjI0LFxyXG4gKiAgICAgICBjb2xvcjpcInJlZFwiXHJcbiAqICAgIH0gXHJcbiAqIH0pO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBidWlsZEljb24ob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgaW1nOiBudWxsLCAvLyAgIHBuZywganBnLiBpZiBub3QgaHR0cCBpbiB0aGUgYmVnaW5uaW5nLCBsb29rIGxvY2FsbHlcclxuICAgICAgICBzdmc6IG51bGwsIC8vIHN2ZyBmaWxlOiAgaXMgYSB1cmwgb3IgYSBzdHJpbmdcclxuICAgICAgICBvcHQ6IG51bGwsIC8vIHNpemUsIGNvbG9yLCBhbmNob3IsIHRleHQuLi5zXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5pbWcgJiYgIXNldHRpbmdzLnN2Zykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpY29uLCBpY29uU3JjO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5pbWcpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNldHRpbmdzLmltZ1wiLCBzZXR0aW5ncy5pbWcpO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuaW1nWzBdID09IFwiQFwiKSAvLyB0byBpbmRpY2F0ZSBsb2NhbFxyXG4gICAgICAgICAgICBpY29uU3JjID0gY20uZ2V0SG9tZSgpICsgc2V0dGluZ3MuaW1nLnN1YnN0cigxKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGljb25TcmMgPSBzZXR0aW5ncy5pbWc7IC8vIGxvY2FsIGZpbGVcclxuXHJcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnN2Zykge1xyXG5cclxuICAgICAgICBsZXQgdXJsID0gbnVsbDtcclxuICAgICAgICBpY29uU3JjID0gc2V0dGluZ3Muc3ZnO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdmdbMF0gPT0gXCJAXCIpIC8vIGxvY2FsIFxyXG4gICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBzZXR0aW5ncy5zdmcuc3Vic3RyKDEpO1xyXG4gICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnN2Zy5zdWJzdHIoMCwgNCkgPT0gXCI8c3ZnXCIpIC8vIHVybFxyXG4gICAgICAgICAgICB1cmwgPSBudWxsO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdXJsID0gc2V0dGluZ3Muc3ZnOyAvLyBub3QgZW1iZWRkZWQgc3RyaW5nLCBzaG91bGQgYmUgYSB1cmxcclxuXHJcbiAgICAgICAgaWYgKHVybCkgeyAvLyBhbiB1cmwgdG8gZG93bmxvYWRcclxuICAgICAgICAgICAgaWNvblNyYyA9IGF3YWl0IGZldGNoKHVybClcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGljb25PcHQgPSB7XHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRydWVcclxuICAgIH07IC8vIHRvIGF2b2lkIGlzc3VlZCB3aXRoIGNhcHR1cmVcclxuICAgIGlmIChzZXR0aW5ncy5vcHQgJiYgc2V0dGluZ3Mub3B0LnNpemUpIHtcclxuICAgICAgICBsZXQgdywgaDtcclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm9wdC5zaXplID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHcgPSBoID0gc2V0dGluZ3Mub3B0LnNpemU7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBbdywgaF0gPSBzZXR0aW5ncy5vcHQuc2l6ZS5zcGxpdChcInhcIik7XHJcblxyXG4gICAgICAgIGljb25PcHQuc2l6ZSA9IHtcclxuICAgICAgICAgICAgdzogdyxcclxuICAgICAgICAgICAgaDogaFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gX2dldHNpemVTdmcoaWNvblNyYykge1xyXG4gICAgICAgIGxldCB3ID0gbnVsbCxcclxuICAgICAgICAgICAgaCA9IG51bGwsXHJcbiAgICAgICAgICAgIG1hdGNoO1xyXG4gICAgICAgIGxldCByID0gL3dpZHRoPVwiKFxcZCspXCIvO1xyXG4gICAgICAgIG1hdGNoID0gaWNvblNyYy5tYXRjaChyKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHcgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgciA9IC9oZWlnaHQ9XCIoXFxkKylcIi87XHJcbiAgICAgICAgbWF0Y2ggPSBpY29uU3JjLm1hdGNoKHIpO1xyXG4gICAgICAgIGlmIChtYXRjaCkgaCA9IG1hdGNoWzFdO1xyXG4gICAgICAgIHJldHVybiBbdywgaF07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnN2ZyAmJiBzZXR0aW5ncy5vcHQgJiYgc2V0dGluZ3Mub3B0LnJhdGlvKSB7XHJcbiAgICAgICAgbGV0IHcgPSBudWxsLFxyXG4gICAgICAgICAgICBoID0gbnVsbDtcclxuICAgICAgICBbdywgaF0gPSBfZ2V0c2l6ZVN2ZyhpY29uU3JjKTtcclxuXHJcbiAgICAgICAgaWNvbk9wdC5zaXplID0ge1xyXG4gICAgICAgICAgICB3OiBNYXRoLmZsb29yKHcgKiBzZXR0aW5ncy5vcHQucmF0aW8pLFxyXG4gICAgICAgICAgICBoOiBNYXRoLmZsb29yKGggKiBzZXR0aW5ncy5vcHQucmF0aW8pXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5hbmNob3IpIHtcclxuICAgICAgICBsZXQgeCA9IG51bGwsXHJcbiAgICAgICAgICAgIHkgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB4ID0geSA9IHNldHRpbmdzLm9wdC5hbmNob3I7XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcImNlbnRlclwiICYmIHNldHRpbmdzLnN2ZykgeyAvLyBmb3Igc3ZnIGZpbGUgb25seSBjZW50ZXI6IGdldCBzaXplIG9mIHNwbGl0IGluIDJcclxuICAgICAgICAgICAgW3gsIHldID0gX2dldHNpemVTdmcoaWNvblNyYyk7XHJcbiAgICAgICAgICAgIHggLz0gMjtcclxuICAgICAgICAgICAgeSAvPSAyO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBbeCwgeV0gPSBzZXR0aW5ncy5vcHQuYW5jaG9yLnNwbGl0KFwieFwiKTtcclxuXHJcbiAgICAgICAgaWYgKCF4IHx8ICF5KSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiQnVpbGRJY29uOiBpbmNvcnJlY3QgYW5jaG9yXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpY29uT3B0LmFuY2hvciA9IHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsIG90aGVyIGZpZWxkcyBhcmUgdHJlYXRlZCBhcyBncmFwaGljIGVuaGFuY2VlbnRcclxuICAgIGlmIChzZXR0aW5ncy5vcHQpIHtcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNldHRpbmdzLm9wdCkge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImZpbGVcIiB8fCBuYW1lID09IFwic2l6ZVwiIHx8IG5hbWUgPT0gXCJhbmNob3JcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCJ7XCIgKyBuYW1lICsgXCJ9XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgaWNvblNyYyA9IGljb25TcmMucmVwbGFjZShyZSwgc2V0dGluZ3Mub3B0W25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uU3JjXCIsIGljb25TcmMpO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uT3B0XCIsIGljb25PcHQpO1xyXG4gICAgaWNvbiA9IG5ldyBILm1hcC5JY29uKGljb25TcmMsIGljb25PcHQpO1xyXG5cclxuICAgIHJldHVybiBpY29uO1xyXG5cclxufSAvL2VuZCBvZiBpY29uXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGFkZCBhIG1hcmtlciBpbiBhIGxheWVyXHJcbiAqIHN2ZyBmaWxlcyBjYW4gYmUgY3JlYXRlZCB3aXRoIGh0dHBzOi8vZWRpdG9yLm1ldGhvZC5hYy8gXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bWFya2VyXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBjcmVhdGUgdGhlIG1hcmtlciwgY2FuIGJlIGEgY29vcmQgZGlyZWN0bHlcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9ICAgbGF5ZXIgbmFtZVxyXG4gKiBAcGFyYW0gW29wdC5jb29yZF0ge2Nvb3JkfSAgIGNvb3JkIG9mIHRoZSBtYXJrZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gW29wdC5pY29uXSB7c3RyaW5nfSAgIGNyZWF0ZWQgZnJvbSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQub3B0XSB7T2JqZWN0fSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJlbnRlciAgaWYgZW50ZXIsIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJDbGljayAgaWYgY2xpY2ssIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdC5kYXRhICBvcHRpb25hbCBkYXRhXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmJ1YmJsZSAgaWYgdHJ1ZSwgc2hvdyBidWJsZSBvbiBjbGljayB3aXRoIGRhdGFcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZHJhZ2dhYmxlICBkcmFnZ2FibGUgbWFya2VyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5kcmFnZ2VkICBpZiBkcmFnZ2VkLCBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAqIFxyXG4gKiBAcmV0dXJuIHtILm1hcC5NYXJrZXJ9ICBtYXJrZXIgY3JlYXRlZFxyXG4gKiBcclxuICogQGV4YW1wbGUgXHJcbiAqIGBgYGpzXHJcbiAqIGhtLm1hcmtlcihbNDguOCwyLjNdKTtcclxuICpcclxuICogaG0ubWFya2VyKHtcclxuICogICAgY29vcmQ6IFs0OC44LDIuM10sXHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0ubWFya2VyKHtcclxuICogICBzdmc6IFwic3ZnL21hcmtlci5zdmdcIixcclxuICogICBjb2xvcjpcInJlZFwiLFxyXG4gKiAgIHJhdGlvOjAuNVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGltZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnBuZ1wiLFxyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiAgICBkYXRhOlwiSGVsbG8gd29ybGRcIixcclxuICogICAgYnViYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0ubWFya2VyKHtcclxuICogICAgY29vcmQ6IFs0OC44LDIuM10sXHJcbiAqICAgIGRyYWdnYWJsZTp0cnVlLFxyXG4gKiAgICBkcmFnZ2VkOiBmdW5jdGlvbih0YXJnZXQsY29vcmQpIHtjb25zb2xlLmxvZyhcImRyYWdnZWQgdG9cIixjb29yZCk7fVxyXG4gKiB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbWFya2VyKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIiwgLy8gIGxheWVyIGluIHdoaWNoIHRvIGFkZCBtYXJrZXJcclxuICAgICAgICBjb29yZDogbnVsbCwgLy8gIGNvb3JkIG9mIHRoZSBtYXJrZXJcclxuICAgICAgICBpbWc6IG51bGwsIC8vICBpbWFnZSBjYW4gYmUgdXJsLCBwbmcsIGpwZy4uXHJcbiAgICAgICAgc3ZnOiBudWxsLCAvLyBzdmcgZmlsZVxyXG4gICAgICAgIGljb246IG51bGwsIC8vIGljb24gcHJldmlvdXNseSBjcmVhdGVkXHJcbiAgICAgICAgb3B0OiB7fSwgLy8gb3B0IGZvciBpY29uXHJcbiAgICAgICAgcG9pbnRlckVudGVyOiBudWxsLCAvLyAgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2KVxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgLy8gIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICAgICAgICBkYXRhOiBudWxsLCAvLyAgdXNlciBkYXRhXHJcbiAgICAgICAgYnViYmxlOiBmYWxzZSwgLy8gIHNob3cgYSBidWJibGUgd2l0aCB1c2VyIGRhdGFcclxuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLCAvLyAgaWNvbiBpcyBkcmFnZ2FsYmVcclxuICAgICAgICBkcmFnZ2VkOiBudWxsIC8vICBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNhbiBwYXNzIGRpcmVjdGx5IG9ubHkgdGhlIGNvb3JkXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHQpKVxyXG4gICAgICAgIG9wdC5jb29yZCA9IG9wdDtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR0aW5ncy5jb29yZCA9IHtcclxuICAgICAgICBsYXQ6IHNldHRpbmdzLmNvb3JkWzBdLFxyXG4gICAgICAgIGxuZzogc2V0dGluZ3MuY29vcmRbMV1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdGhlc2UgcGFyYW1ldGVycyBjYW4gYmUgaW4gb3B0Lm9wdCBvciBkaXJlY3RseSBpbiBvcHRcclxuICAgIGlmIChzZXR0aW5ncy5jb2xvcikgc2V0dGluZ3Mub3B0LmNvbG9yID0gc2V0dGluZ3MuY29sb3I7XHJcbiAgICBpZiAoc2V0dGluZ3Muc2l6ZSkgc2V0dGluZ3Mub3B0LnNpemUgPSBzZXR0aW5ncy5zaXplO1xyXG4gICAgaWYgKHNldHRpbmdzLnJhdGlvKSBzZXR0aW5ncy5vcHQucmF0aW8gPSBzZXR0aW5ncy5yYXRpbztcclxuICAgIGlmIChzZXR0aW5ncy5hbmNob3IpIHNldHRpbmdzLm9wdC5hbmNob3IgPSBzZXR0aW5ncy5hbmNob3I7XHJcblxyXG4gICAgbGV0IG1hcmtlck9wdCA9IG51bGw7XHJcbiAgICBpZiAoc2V0dGluZ3MuaW1nIHx8IHNldHRpbmdzLnN2Zykge1xyXG4gICAgICAgIGxldCBpY29uID0gYXdhaXQgYnVpbGRJY29uKHNldHRpbmdzKTtcclxuICAgICAgICBtYXJrZXJPcHQgPSB7XHJcbiAgICAgICAgICAgIGljb246IGljb25cclxuICAgICAgICB9O1xyXG4gICAgfSBlbHNlIGlmIChzZXR0aW5ncy5pY29uKSB7XHJcbiAgICAgICAgbWFya2VyT3B0ID0ge1xyXG4gICAgICAgICAgICBpY29uOiBzZXR0aW5ncy5pY29uXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwibWFya2VyIHNldHRpbmdzLmNvb3JkXCIsIHNldHRpbmdzLmNvb3JkKTtcclxuICAgIGxldCBtYXJrZXIgPSBuZXcgSC5tYXAuTWFya2VyKHNldHRpbmdzLmNvb3JkLCBtYXJrZXJPcHQpO1xyXG5cclxuICAgIG1hcmtlci5kcmFnZ2FibGUgPSBzZXR0aW5ncy5kcmFnZ2FibGU7XHJcbiAgICBpZiAoc2V0dGluZ3MuZHJvcHBhYmxlKSB7XHJcbiAgICAgICAgbWFya2VyLmRyYWdnYWJsZSA9IHRydWU7XHJcbiAgICAgICAgbWFya2VyLmRyb3BwYWJsZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dGluZ3MuZHJhZ2dlZCkgbWFya2VyLmRyYWdnZWQgPSBzZXR0aW5ncy5kcmFnZ2VkO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBzZXR0aW5ncy5kYXRhO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kYXRhID09IFwiX19PUFRfX1wiKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBzZXR0aW5ncztcclxuICAgICAgICAgICAgZGVsZXRlIGRhdGEuY29vcmQ7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHAgaW4gZGF0YSlcclxuICAgICAgICAgICAgICAgIGlmICghZGF0YVtwXSkgZGVsZXRlIGRhdGFbcF07XHJcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKS5yZXBsYWNlKC9cXG4vZywgXCI8YnIvPlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya2VyLnNldERhdGEoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGNsaWNrIGZyb20gbW91c2VcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBnLmNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG5cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqICBjYWxsYmFjayB3aGVuIGNsaWNrIG9uIG1hcmtlciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyQ2xpY2spIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJDbGljayh0YXJnZXQsIGcuY29vcmRPMkEoY29vcmQpLCBldik7XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKiogIGNhbGxiYWNrIHdoZW4gY2xpY2sgb24gbWFya2VyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgaWYgKHNldHRpbmdzLmRyb3BwYWJsZSkge1xyXG4gICAgICAgIG1hcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaHRtbEJvdW5kaW5nKCk7XHJcbiAgICAgICAgICAgIGxldCBzY3JlZW4gPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFggKyBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZICsgb2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5kcm9wcGFibGUoc2NyZWVuLCBldiwgZXYudHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaHRtbEJvdW5kaW5nKCk7XHJcbiAgICAgICAgICAgIGxldCBzY3JlZW4gPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFggKyBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZICsgb2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5kcm9wcGFibGUoc2NyZWVuLCBldiwgZXYudHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gaHRtbEJvdW5kaW5nKCk7XHJcbiAgICAgICAgICAgIGxldCBzY3JlZW4gPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFggKyBvZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZICsgb2Zmc2V0LnRvcFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5kcm9wcGFibGUoc2NyZWVuLCBldiwgZXYudHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvKioqKioqKioqKioqICBzaG93IGEgYnViYmxlIHdoZW4gY2xpY2tpbmcgb24gbWFya2VyICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgaWYgKHNldHRpbmdzLmJ1YmJsZSkge1xyXG4gICAgICAgIG1hcmtlci5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG5cclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuXHJcbiAgICAgICAgICAgIGJ1YmJsZVVuaXF1ZShnLmNvb3JkTzJBKGNvb3JkKSwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnpJbmRleClcclxuICAgICAgICBtYXJrZXIuc2V0WkluZGV4KHNldHRpbmdzLnpJbmRleCk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KG1hcmtlcik7XHJcbiAgICByZXR1cm4gbWFya2VyO1xyXG5cclxufSAvL2VuZCBvZiBtYXJrZXJcclxuXHJcblxyXG4vKipcclxuICogZ2V0IGNvb3JkaW5hdGVzIG9mIGEgbWFya2VyXHJcbiAqIEBhbGlhcyBtYXJrZXI6Z2V0Q29vcmRcclxuICogQHJldHVybiB7Y29vcmR9ICBbbGF0LGxuZ11cclxuICogQGV4YW1wbGUgXHJcbiAqIGBgYGpzXHJcbiAqIGxldCBtID1obS5tYXJrZXIoWzQ4LjgsMi4zXSk7XHJcbiAqXHJcbiAqIGxldCBjb29yZCA9IG0uZ2V0Y29vcmQoKTsgLy8gcmV0dXJucyBbNDguOCwyLjNdXHJcbiAqIFxyXG4gKiAgYGBgXHJcbiAqL1xyXG5ILm1hcC5NYXJrZXIucHJvdG90eXBlLmdldENvb3JkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcclxuICAgIHJldHVybiBnLnBvaW50MkNvb3JkKHBvcyk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERyYXcgYSBwb2x5bGluZS4gXHJcbiAqIEBhbGlhcyBobTpwb2x5bGluZVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9ICAgb3B0aW9ucyB0byBkcmF3IHBvbHlsaW5lXHJcbiAqIEBwYXJhbSBbb3B0LmxheWVyXSB7U3RyaW5nfSBvcHRpb25hbCBsYXllciB0byB1c2UgXHJcbiAqIEBwYXJhbSBbb3B0LmNvb3Jkc10ge2FycmF5fSBhcnJheSBvZiBjb29yZHMsIGFzIFxcW1xcWzQ4LjgsMi4zXFxdLFxcWzQ4Ljg1LDIuNFxcXSwuLi4gXFxdXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlXSB7b2JqZWN0fSBvcHRpb25hbCBncmFwaGljIHN0eWxlXHJcbiAqIEBwYXJhbSBbb3B0LmxpbmVXaWR0aD00XSB7bnVtYmVyfSBsaW5lIHdpZHRoXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLnN0cm9rZUNvbG9yPXJnYmEoMCwgMTI4LCAyNTUsIDAuNyldIHtzdHJpbmd9IGxpbmUgY29sb3JcclxuICogQHBhcmFtIFtvcHQuYXJyb3dzXSB7b2JqZWN0fSBvcHRpb25hbCBhcnJvd1xyXG4gKiBAcGFyYW0gW29wdC5kYXRhXSB7U3RyaW5nfSBvcHRpb25hbCB1c2VyIGRhdGFcclxuICogQHBhcmFtIFtvcHQucG9pbnRlckNsaWNrXSB7ZnVuY3Rpb259IG9wdGlvbmFsIGNhbGxiYWNrIGlmIGNsaWNrIG9uIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJlbnRlcl0ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBtb3VzZSBlbnRlcnMgb24gbGluZS4gZm9ybWF0IGNhbGxiYWNrKHRhcmdldCxjb29yZCxldmVudClcclxuICogQHBhcmFtIFtvcHQucG9pbnRlckxlYXZlXSB7ZnVuY3Rpb259IG9wdGlvbmFsIGNhbGxiYWNrIGlmIG1vdXNlIGxlYXZlcyB0aGUgbGluZS4gZm9ybWF0IGNhbGxiYWNrKHRhcmdldCxjb29yZCxldmVudClcclxuICogQHBhcmFtIFtvcHQuel0ge251bWJlcn0gb3B0aW9uYWwgeiBsZXZlbFxyXG4gKiBgYGBqc1xyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogW1s0OC44LDIuM10sWzQ4Ljg1LDIuNF0sWzQ4LjksMi42XV0sXHJcbiAqICAgIGxheWVyOlwibGF5ZXIxXCJcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gKiAgICBzdHlsZToge1xyXG4gKiAgICAgICAgbGluZVdpZHRoOiA0LFxyXG4gKiAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmVkXCJcclxuICogICAgfSxcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5wb2x5bGluZSh7XHJcbiAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gKiAgICBkYXRhOlwiSGVsbG8gV29ybGRcIixcclxuICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlsaW5lKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZHM6IG51bGwsIC8vIGNvb3JkcyBpcyBsaXN0IG9mIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiBvYmplY3Qgd2l0aCB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcnJvd3M6IG51bGwsXHJcbiAgICAgICAgZGF0YTogbnVsbCwgLy8gb3B0aW9uYWwgdXNlciBkYXRhIFxyXG4gICAgICAgIHo6IG51bGwsXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAvLyBjbGlja1xyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gY2FsbCBiYWNrXHJcbiAgICAgICAgcG9pbnRlckxlYXZlOiBudWxsIC8vIGNhbGwgYmFja1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHQpKSAvLyBkaXJlY3RlbWVudCBsZXMgY29vcmRcclxuICAgICAgICBvcHQgPSB7XHJcbiAgICAgICAgICAgIGNvb3Jkczogb3B0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNvb3Jkcykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUG9seWxpbmU6IGNvb3JkcyBub3QgZm91bmQ6XCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmlwID0gbmV3IEguZ2VvLlN0cmlwKCk7XHJcblxyXG4gICAgc2V0dGluZ3MuY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgc3RyaXAucHVzaExhdExuZ0FsdChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHBvbHlsaW5lID0gbmV3IEgubWFwLlBvbHlsaW5lKHN0cmlwLCB7XHJcbiAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlLFxyXG4gICAgICAgIGRhdGE6IHNldHRpbmdzLmRhdGEsXHJcbiAgICAgICAgYXJyb3dzOiBzZXR0aW5ncy5hcnJvd3NcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFogaW5kZXhcclxuICAgIGlmIChzZXR0aW5ncy56KSBwb2x5bGluZS5zZXRaSW5kZXgoc2V0dGluZ3Mueik7XHJcbiAgICAvLyB1c2VyIGRhdGFcclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSBwb2x5bGluZS5zZXREYXRhKHNldHRpbmdzLmRhdGEpO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpXHJcbiAgICAgICAgcG9seWxpbmUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGcuY29vcmRPMkEoY29vcmQpLCBldik7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckxlYXZlKVxyXG4gICAgICAgIHBvbHlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyTGVhdmUodGFyZ2V0LCBnLmNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJDbGljaylcclxuICAgICAgICBwb2x5bGluZS5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgZy5jb29yZE8yQShjb29yZCksIGV2KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QocG9seWxpbmUpO1xyXG5cclxuICAgIHJldHVybiBwb2x5bGluZTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBEcmF3IGEgcG9seWdvblxyXG4gKiBAYWxpYXMgaG06cG9seWdvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0ICBvcHRpb25zIHRvIGRyYXcgYSBwb2x5Z29uLiBTYW1lIG9wdGlvbnMgYXMgaG0ucG9seWxpbmVcclxuICovXHJcbmZ1bmN0aW9uIHBvbHlnb24ob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkczogXCJcIiwgLy8gY29vcmRzIGlzIGFycmF5IG9mIFtsYXQsbG5nXSBvciBhcnJheSBvZiB7bGF0Oixsbmc6fVxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogNCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiLFxyXG4gICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDI1NSwgMC43KVwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHlsZUhvdmVyOiBudWxsLCAvLyBzdHlsZSBzaSBtb3VzZSBvdmVyXHJcbiAgICAgICAgYXJyb3dzOiBudWxsLFxyXG4gICAgICAgIGRhdGE6IG51bGwsIC8vIGFkZGl0aW9uYWwgZGF0YSB0byBjYXJyeVxyXG4gICAgICAgIHo6IG51bGwsXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAvLyBjbGlja1xyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgLy8gY2FsbCBiYWNrXHJcbiAgICAgICAgcG9pbnRlckxlYXZlOiBudWxsIC8vIGNhbGwgYmFja1xyXG4gICAgfTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdCkpIC8vIGRpcmVjdGVtZW50IGxlcyBjb29yZFxyXG4gICAgICAgIG9wdCA9IHtcclxuICAgICAgICAgICAgY29vcmRzOiBvcHRcclxuICAgICAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5jb29yZHMpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlBvbHlsaW5lOiBjb29yZHMgbm90IGZvdW5kOlwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdHJpcCA9IG5ldyBILmdlby5TdHJpcCgpO1xyXG4gICAgc2V0dGluZ3MuY29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgc3RyaXAucHVzaExhdExuZ0FsdChwb2ludFswXSwgcG9pbnRbMV0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHBvbHlnb24gPSBuZXcgSC5tYXAuUG9seWdvbihzdHJpcCwge1xyXG4gICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZSxcclxuICAgICAgICBkYXRhOiBzZXR0aW5ncy5kYXRhLFxyXG4gICAgICAgIGFycm93czogc2V0dGluZ3MuYXJyb3dzXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MuZGF0YSkgcG9seWdvbi5zZXREYXRhKHNldHRpbmdzLmRhdGEpO1xyXG4gICAgLy8gWiBpbmRleFxyXG4gICAgaWYgKHNldHRpbmdzLnopIHBvbHlsaW5lLnNldFpJbmRleChzZXR0aW5ncy56KTtcclxuXHJcbiAgICAvLyBzaSB1biBzdHlsZSBkZSBob3ZlclxyXG4gICAgaWYgKHNldHRpbmdzLnN0eWxlSG92ZXIpIHtcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRTdHlsZShzZXR0aW5ncy5zdHlsZUhvdmVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zZXRTdHlsZShzZXR0aW5ncy5zdHlsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJFbnRlcilcclxuICAgICAgICBwb2x5Z29uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJFbnRlcih0YXJnZXQsIGcuY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckxlYXZlKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckxlYXZlKHRhcmdldCwgZy5jb29yZE8yQShjb29yZCksIGV2LCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyQ2xpY2spXHJcbiAgICAgICAgcG9seWdvbi5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBnLmNvb3JkTzJBKGNvb3JkKSwgZXYsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIGxheWVyLmFkZE9iamVjdChwb2x5Z29uKTtcclxuXHJcbiAgICByZXR1cm4gcG9seWdvbjtcclxufSAvLyBlbmQgb2YgcG9seWdvblxyXG5cclxuLyoqXHJcbiAqIGRyYXcgYSBjaXJjbGVcclxuICogQGFsaWFzIGhtOmNpcmNsZVxyXG4gKiBAcGFyYW0gb3B0IHsqfSAgIG9wdGlvbiBmb3IgY2lyY2xlXHJcbiAqIEBwYXJhbSBbb3B0LmxheWVyXSB7U3RyaW5nfSBvcHRpb25hbCBsYXllciB0byB1c2UgXHJcbiAqIEBwYXJhbSBbb3B0LmNvb3JkXSB7YXJyYXl9IGNlbnRlciBvZiB0aGUgY2lyY2xlLCBhcyBcXFs0OC44LDIuM1xcXVxyXG4gKiBAcGFyYW0gW29wdC5yYWRpdXNdIHtudW1iZXJ9IHJhZGl1cyBpbiBtZXRlclxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBzdHlsZVxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5zdHJva2VDb2xvcl0ge3N0cmluZ30gY29sb3Igb2YgcGVyaW1ldGVyXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLmxpbmVXaWR0aF0ge251bWJlcn0gbGluZSB3aWR0aFxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5maWxsQ29sb3JdIHtzdHJpbmd9IGZpbGwgY29sb3JcclxuICovXHJcbmZ1bmN0aW9uIGNpcmNsZShvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogXCJkZWZhdWx0XCIsXHJcbiAgICAgICAgY29vcmQ6IG51bGwsXHJcbiAgICAgICAgcmFkaXVzOiAxMDAsIC8vIG1ldGVyc1xyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBcInJnYmEoNTUsIDg1LCAxNzAsIDAuMilcIiwgLy8gQ29sb3Igb2YgdGhlIHBlcmltZXRlclxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIGZpbGxDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMCwgMC4xKVwiIC8vIENvbG9yIG9mIHRoZSBjaXJjbGVcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNpcmNsZSA9IG5ldyBILm1hcC5DaXJjbGUoXHJcbiAgICAgICAgLy8gVGhlIGNlbnRyYWwgcG9pbnQgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgIGcuY29vcmRBMk8oc2V0dGluZ3MuY29vcmQpLFxyXG4gICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZSBpbiBtZXRlcnNcclxuICAgICAgICBzZXR0aW5ncy5yYWRpdXMsIHtcclxuICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QoY2lyY2xlKTtcclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBwcm92aWRlIGJvdW5kaW5nIGJveCBvZiBlbGVtZW50IGhvc3RpbmcgbWFwLCByZWxhdHZlIHRvIHdpbmRvd1xyXG4gKiBAYWxpYXMgaG06aHRtbEJvdW5kaW5nXHJcbiAqIEByZXR1cm4ge29iamVjdH0ge3RvcCxsZWZ0LHdpZHRoLCBoZWlnaHR9IHJlbGF0aXZlIHRvIHdpbmRvd1xyXG4gKi9cclxuZnVuY3Rpb24gaHRtbEJvdW5kaW5nKCkge1xyXG4gICAgbGV0IGJiID0gX2h0bWxJdGVtSWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG4gICAgbGV0IHRvcCA9IGJiLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgIGxldCBsZWZ0ID0gYmIubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvcDogdG9wLFxyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgd2lkdGg6IGJiLndpZHRoLFxyXG4gICAgICAgIGhlaWdodDogYmIuaGVpZ2h0XHJcbiAgICB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHdhdGNoIHBvc2l0aW9uIG9uIEhUTUw1IHBvc2l0aW9uLiBUaGlzIHJlcXVpcmVzIEhUVFBTLiBDcmVhdGVzIGxheWVyIFwiX2dwc1wiXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bG9jYXRlTWVcclxuICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn0gIGNhbGxiYWNrIHdoZW4gY29vcmQgY2hhbmdlcy4gRm9ybWF0OiBjYWxsYmFjayhjb29yZCxhY2N1cmFjeSkgXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBvcHRpb25zXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uXSB7b2JqZWN0fSAgZ3JhcGhpYyBvcHRpb25zIGZvciBjZW50ZXIuIFNlZSBidWlsZEljb25cclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uc3ZnXSB7c3RyaW5nfSAgc3ZnIGZpbGVcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uY29sb3JdIHtzdHJpbmd9ICBjb2xvciBmb3IgIHtjb2xvcn0gdGFnXHJcbiAqIEBwYXJhbSBbb3B0LnBvc2l0aW9uLnNpemVdIHtudW1iZXJ9ICBzaXplIG9mIGljb25cclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uYW5jaG9yXSB7bnVtYmVyfSAgYW5jaG9yIG9mIGljb25cclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3ldIHtvYmplY3R9ICBncmFwaGljIG9wdGlvbnMgZm9yIGFjY3VyYWN5IHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSBbb3B0LmFjY3VyYWN5LnN0cm9rZUNvbG9yXSB7U3RyaW5nfSAgY29sb3Igb2YgY2lyY2xlIGxpbmUgcmVwcmVzZW50aW5nIGFjY3VyYWN5IGFyZWFcclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kubGluZVdpZHRoXSB7bnVtYmVyfSAgd2lkdGggb2YgbGluZSBvZiBjaXJjbGVcclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kuZmlsbENvbG9yXSB7U3RyaW5nfSAgZmlsbCBjb2xvciBvZiBjaXJjbGUgcmVwcmVzZW50aW5nIGFjY3VyYWN5IGFyZWFcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2F0ZU1lKGNhbGxiYWNrLCBvcHQpIHtcclxuXHJcbiAgICAvLyBpZiBubyBjYWxsYmFjaywgcmVtb3ZlIHRoZSB3YXRjaFxyXG4gICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG4gICAgICAgIGlmICghY2FsbGJhY2sgJiYgX2xvY2F0ZU1lKSB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5jbGVhcldhdGNoKF9sb2NhdGVNZSk7XHJcbiAgICAgICAgICAgIF9sb2NhdGVNZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxheWVyRGVsZXRlKFwiX2dwc1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgc3ZnOiBcIkBzdmcvdGFyZ2V0LnN2Z1wiLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiYmxhY2tcIixcclxuICAgICAgICAgICAgICAgIGFuY2hvcjogXCJjZW50ZXJcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY2N1cmFjeToge1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSgwLCAxMjgsIDAsIDAuOClcIiwgLy8gQ29sb3Igb2YgdGhlIHBlcmltZXRlclxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAwLCAwLjQpXCIgLy8gQ29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgICAgICBsZXQgaWNvbkNyb3NzSGFpciA9IGF3YWl0IGJ1aWxkSWNvbih7XHJcbiAgICAgICAgICAgIHN2Zzogc2V0dGluZ3MucG9zaXRpb24uc3ZnLFxyXG4gICAgICAgICAgICBpbWc6IHNldHRpbmdzLnBvc2l0aW9uLmltZyxcclxuICAgICAgICAgICAgb3B0OiBzZXR0aW5ncy5wb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy9uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKGZ1bmN0aW9uIHBvcyhwb3NpdGlvbikge1xyXG4gICAgICAgIF9sb2NhdGVNZSA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3BzID0gW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV07XHJcblxyXG4gICAgICAgICAgICBsYXllckVtcHR5KFwiX2dwc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNpcmNsZSBzaG93aW5nIHRoZSBhY2N1cmFjeSByYWRpdXMqL1xyXG4gICAgICAgICAgICBjaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IFwiX2dwc1wiLFxyXG4gICAgICAgICAgICAgICAgY29vcmQ6IGdwcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLmFjY3VyYWN5XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWFya2VyKHtcclxuICAgICAgICAgICAgICAgIGxheWVyOiBcIl9ncHNcIixcclxuICAgICAgICAgICAgICAgIGNvb3JkOiBncHMsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uQ3Jvc3NIYWlyXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soZ3BzLCBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kpO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gXCJcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlBFUk1JU1NJT05fREVOSUVEOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIlVzZXIgZGVuaWVkIHRoZSByZXF1ZXN0IGZvciBHZW9sb2NhdGlvbi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuUE9TSVRJT05fVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiTG9jYXRpb24gaW5mb3JtYXRpb24gaXMgdW5hdmFpbGFibGUuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlRJTUVPVVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwidGltZWQgb3V0LlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5VTktOT1dOX0VSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJIVE1MNSBsb2NhdGlvbiBlcnJvcjpcIiArIG1zZyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJubyBIVE1MNSBnZW9sb2NhdGlvbiBjYXBhYmlsaXRpZXNcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIGEgc2NyZWVuc2hvdCBvZiB0aGUgbWFwIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSBkYXRhXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06c2NyZWVuc2hvdFxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIHNjcmVlbnNob3RcclxuICogQHBhcmFtIFtvcHQubmFtZV0ge3N0cmluZ30gZmlsZW5hbWUgZm9yIGRvd25sb2FkXHJcbiAqIEBwYXJhbSBbb3B0LnVpXSB7Ym9vbGVhbn0gdHJ1ZSB0byB1aSAoc2NhbGUsIGV0Yy4uKSBpbiBzY3JlZW5zaG90XHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyBmb3Igc2NyZWVuc2hvdFxyXG4gKiBcclxuICogQHJldHVybnMge2RhdGF9IGJpbmFyeSBkYXRhIG9mIGltYWdlXHJcbiAqIFxyXG4gKi9cclxuZnVuY3Rpb24gc2NyZWVuc2hvdChvcHQpIHtcclxuICAgIGxldCBwYXJhID0gbnVsbDtcclxuICAgIGlmIChvcHQgJiYgb3B0LnVpKVxyXG4gICAgICAgIHBhcmEgPSBbX3VpXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIF9tYXAuY2FwdHVyZShmdW5jdGlvbiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbnZhcylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFwiTWFwIHNjcmVlbnNob3Qgbm90IHN1cHBvcnRlZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoKTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHQgJiYgb3B0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuaHJlZiA9IGRhdGFVUkw7XHJcbiAgICAgICAgICAgICAgICAgICAgYS50YXJnZXQgPSBcIl9ibGFua1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZG93bmxvYWQgPSBvcHQubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YVVSTCk7XHJcbiAgICAgICAgICAgIH0sIHBhcmEpO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0TWFwSHRtbEl0ZW0oKSB7XHJcbiAgICByZXR1cm4gX2h0bWxJdGVtO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXAoKSB7XHJcbiAgICByZXR1cm4gX21hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QmVoYXZpb3IoKSB7XHJcbiAgICByZXR1cm4gX2JlaGF2aW9yO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0VUkoKSB7XHJcbiAgICByZXR1cm4gX3VpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdldE1hcDogZ2V0TWFwLFxyXG4gICAgZ2V0VUk6IGdldFVJLFxyXG4gICAgZ2V0QmVoYXZpb3I6IGdldEJlaGF2aW9yLFxyXG4gICAgZ2V0TWFwSHRtbEl0ZW06IGdldE1hcEh0bWxJdGVtLFxyXG4gICAgbWFwOiBtYXAsXHJcbiAgICBidWlsZEljb246IGJ1aWxkSWNvbixcclxuICAgIG1hcmtlcjogbWFya2VyLFxyXG4gICAgZ2V0QXZhaWxhYmxlTWFwU3R5bGU6IGdldEF2YWlsYWJsZU1hcFN0eWxlLFxyXG4gICAgc2V0U2NoZW1lOiBzZXRTY2hlbWUsXHJcbiAgICBsYXllckNyZWF0ZTogbGF5ZXJDcmVhdGUsXHJcbiAgICBsYXllckZpbmQ6IGxheWVyRmluZCxcclxuICAgIGxheWVyRGVsZXRlOiBsYXllckRlbGV0ZSxcclxuICAgIGxheWVyU2V0VmlzaWJpbGl0eTogbGF5ZXJTZXRWaXNpYmlsaXR5LFxyXG4gICAgbGF5ZXJFbXB0eTogbGF5ZXJFbXB0eSxcclxuICAgIGJ1YmJsZVVuaXF1ZTogYnViYmxlVW5pcXVlLFxyXG4gICAgYnViYmxlVW5pcXVlSGlkZTogYnViYmxlVW5pcXVlSGlkZSxcclxuICAgIGNpcmNsZTogY2lyY2xlLFxyXG4gICAgcG9seWxpbmU6IHBvbHlsaW5lLFxyXG4gICAgcG9seWdvbjogcG9seWdvbixcclxuICAgIGdldENlbnRlcjogZ2V0Q2VudGVyLFxyXG4gICAgc2V0Q2VudGVyOiBzZXRDZW50ZXIsXHJcbiAgICBnZXRab29tOiBnZXRab29tLFxyXG4gICAgc2V0Wm9vbTogc2V0Wm9vbSxcclxuICAgIGdldFZpZXdCQjogZ2V0Vmlld0JCLFxyXG4gICAgc2V0Vmlld0JCOiBzZXRWaWV3QkIsXHJcbiAgICBsb2NhdGVNZTogbG9jYXRlTWUsXHJcbiAgICBzY3JlZW5zaG90OiBzY3JlZW5zaG90LFxyXG4gICAgaHRtbEJvdW5kaW5nOiBodG1sQm91bmRpbmdcclxuXHJcbn07IiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcInVzZVwiLCBcIm9uXCIsIFwib25jZVwiLCBcInNldFwiLCBcInF1ZXJ5XCIsIFwidHlwZVwiLCBcImFjY2VwdFwiLCBcImF1dGhcIiwgXCJ3aXRoQ3JlZGVudGlhbHNcIiwgXCJzb3J0UXVlcnlcIiwgXCJyZXRyeVwiLCBcIm9rXCIsIFwicmVkaXJlY3RzXCIsXG4gXCJ0aW1lb3V0XCIsIFwiYnVmZmVyXCIsIFwic2VyaWFsaXplXCIsIFwicGFyc2VcIiwgXCJjYVwiLCBcImtleVwiLCBcInBmeFwiLCBcImNlcnRcIl0uZm9yRWFjaChmbiA9PiB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbiwgYXJnc30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZGVmID0+IHtcbiAgICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgZGVmLmFyZ3MpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxubGV0IHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuY29uc3QgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuY29uc3QgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5jb25zdCByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn07XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9ICgpID0+IHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltXG4gID8gcyA9PiBzLnRyaW0oKVxuICA6IHMgPT4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2godiA9PiB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IoY29uc3Qgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywgYCR7a2V5fVske3N1YmtleX1dYCwgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3QgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgbGV0IHBhaXI7XG4gIGxldCBwb3M7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGluZTtcbiAgbGV0IGZpZWxkO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIGxldCBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgbGV0IHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCByZXEgPSB0aGlzLnJlcTtcbiAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgY29uc3QgdXJsID0gcmVxLnVybDtcblxuICBjb25zdCBtc2cgPSBgY2Fubm90ICR7bWV0aG9kfSAke3VybH0gKCR7dGhpcy5zdGF0dXN9KWA7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgbGV0IG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSBzdHJpbmcgPT4ge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gKCkgPT4ge1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybiB0aGlzLmNhbGxiYWNrKEVycm9yKFwiVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZFwiKSk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICBsZXQgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICBsZXQgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgY29uc3QgaGFuZGxlUHJvZ3Jlc3MgPSAoZGlyZWN0aW9uLCBlKSA9PiB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBsZXQgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAoY29uc3QgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSAoKSA9PiBuZXcgQWdlbnQoKTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgY29uc3QgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkgPT4ge1xuICAgICAgc2VsZi5vbignZXJyb3InLCBpbm5lclJlamVjdCk7XG4gICAgICBzZWxmLm9uKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICAgIGVyci5jb2RlID0gXCJBQk9SVEVEXCI7XG4gICAgICAgIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICAgICAgICBlcnIudXJsID0gdGhpcy51cmw7XG4gICAgICAgIGlubmVyUmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuZW5kKChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2IpIHRocm93IEVycm9yKFwiQ2FsbGJhY2sgcmVxdWlyZWRcIik7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWw7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgdW5kZWZpbmVkID09PSBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcbiAgaWYgKG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsKSB7XG4gICAgdmFsID0gJycgKyB2YWw7XG4gIH1cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJhc2ljICR7YmFzZTY0RW5jb2RlcihgJHt1c2VyfToke3Bhc3N9YCl9YCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmVhcmVyJzogLy8gdXNhZ2Ugd291bGQgYmUgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3VzZXJ9YCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aW5nIGluIGJyb3dzZXIgWEhSIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgfVxuICB0aGlzLl9tYXhSZXNwb25zZVNpemUgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICBsZXQgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiLnNlbmQoKSBjYW4ndCBiZSB1c2VkIGlmIC5hdHRhY2goKSBvciAuZmllbGQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAvLyBkZWZhdWx0IHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gYCR7dGhpcy5fZGF0YX0mJHtkYXRhfWBcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc29ydFF1ZXJ5ID0gZnVuY3Rpb24oc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgY29uc3QgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3QgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9zb3J0KSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnN1YnN0cmluZygwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFyci5qb2luKCcmJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdCBvbmx5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gKCkgPT4ge2NvbnNvbGUudHJhY2UoXCJVbnN1cHBvcnRlZFwiKTt9XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKHJlYXNvbiwgdGltZW91dCwgZXJybm8pe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7cmVhc29uICsgdGltZW91dH1tcyBleGNlZWRlZGApO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cbiAgLy8gcmVzcG9uc2UgdGltZW91dFxuICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0ICYmICF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlc3BvbnNlQmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAgIC8vIFRPRE86IG1vYXIhXG4gICAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gICAgLy8gY29udGVudC10eXBlXG4gICAgY29uc3QgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgY29uc3QgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuXG4gICAgdGhpcy5saW5rcyA9IHt9O1xuXG4gICAgLy8gbGlua3NcbiAgICB0cnkge1xuICAgICAgICBpZiAoaGVhZGVyLmxpbmspIHtcbiAgICAgICAgICAgIHRoaXMubGlua3MgPSB1dGlscy5wYXJzZUxpbmtzKGhlYWRlci5saW5rKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAgIGNvbnN0IHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuY3JlYXRlZCA9IDIwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzO1xuICAgIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gICAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IDQyMiA9PSBzdGF0dXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50eXBlID0gc3RyID0+IHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKChvYmosIHN0cikgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgY29uc3QgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqLCAqLykucmVkdWNlKChvYmosIHN0cikgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgY29uc3QgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICBjb25zdCByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gIG9ialtyZWxdID0gdXJsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IChoZWFkZXIsIGNoYW5nZXNPcmlnaW4pID0+IHtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2hvc3QnXTtcbiAgLy8gc2VjdWlydHlcbiAgaWYgKGNoYW5nZXNPcmlnaW4pIHtcbiAgICBkZWxldGUgaGVhZGVyWydhdXRob3JpemF0aW9uJ107XG4gICAgZGVsZXRlIGhlYWRlclsnY29va2llJ107XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuY29uc3QgY20gPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XHJcblxyXG5cclxuLyoqXHJcbiAqIFBsYWNlIEF1dG9TdWdnZXN0XHJcbiAqIEAgYXN5bmNcclxuICogQGFsaWFzIGhtOnBsYWNlQXV0b1N1Z2dlc3RcclxuICogQHBhcmFtIG9wdCB7T2JqZWN0fSBvcHRpb25zIG9mIGF1dG9zdWdnZXN0XHJcbiAqIEBwYXJhbSBvcHQuc2VhcmNoIHtTdHJpbmd9IHNlYXJjaCBzdHJpbmdcclxuICogQHBhcmFtIG9wdC5jZW50ZXIge0Nvb3JkfSBjZW50ZXIgc2VhcmNoIGFyb3VuZCB0aGlzIGNvb3JkXHJcbiAqIEByZXR1cm4gIHtQcm9taXNlfSBBcnJheSBvZiB7cmVzLHRpdGxlLHZhbHVlLGNvb3JkfVxyXG4gKi9cclxuZnVuY3Rpb24gcGxhY2VBdXRvU3VnZ2VzdChvcHQpIHtcclxuXHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgYXQ6IG9wdC5jZW50ZXJbMF0gKyBcIixcIiArIG9wdC5jZW50ZXJbMV0sXHJcbiAgICAgICAgcTogb3B0LnNlYXJjaFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJwbGFjZXNcIiwgXCJhcGkuaGVyZS5jb20vcGxhY2VzL3YxL2F1dG9zdWdnZXN0XCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcImdldFwiLCBmYWxzZSlcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcGxhY2VzID0gcmVzLmJvZHkucmVzdWx0cy5maWx0ZXIocGxhY2UgPT4gcGxhY2UudmljaW5pdHkpOyAvLyBrZWVwIG9ubHkgaWYgdmljaW5pdHkgZmllbGQgaXMgcHJlc2VudFxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYWNlcy5tYXAocGxhY2UgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcGxhY2UudGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgLy92YWx1ZTogcGxhY2UudGl0bGUgKyAnLCAnICsgcGxhY2UudmljaW5pdHkucmVwbGFjZSgvPGJyXFwvPi9nLCBcIiwgXCIpICsgJyAoJyArIHBsYWNlLmNhdGVnb3J5ICsgJyknLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwbGFjZS50aXRsZSArIFwiLCBcIiArIHBsYWNlLnZpY2luaXR5LnJlcGxhY2UoLzxiclxcLz4vZywgXCIsIFwiKSxcclxuICAgICAgICAgICAgICAgICAgICBjb29yZDogcGxhY2UucG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzOiBwbGFjZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBwbGFjZUF1dG9TdWdnZXN0OiBwbGFjZUF1dG9TdWdnZXN0XHJcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIGNvbXB1dGUgYSByb3V0ZSB3aXRoIG9wdGlvbmFsIHdheXBvb2ludHMuIFtTZWUgbW9yZSBpbmZvIG9uIG9wdGlvbmFsIHBhcmFtZXRlcnNdKGh0dHA6Ly9kb2N1bWVudGF0aW9uLmRldmVsb3Blci5oZXJlLmNvbS9wZGYvcm91dGluZ19obHAvNy4yLjEwMC9Sb3V0aW5nJTIwQVBJJTIwdjcuMi4xMDAlMjBEZXZlbG9wZXIncyUyMEd1aWRlLnBkZilcclxuICogQGFsaWFzIGhtOnJvdXRlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBzb3VyY2UgYXMgXFxbbGF0LGxuZ1xcXS4gQ2FuIGJlIGFycmF5IG9mIFxcW2xhdCxsbmdcXF0gdG8gZGVmaW5lIHdheXBvaW50c1xyXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzdCAtIGRlc3QgYXMgXFxbbGF0LGxuZ1xcXS4gQ2FuIGJlIGFycmF5IG9mIFxcW2xhdCxsbmdcXF0gdG8gZGVmaW5lIHdheXBvaW50c1xyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IHJvdXRlIG9wdGlvbnMgXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9ZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZF0ge3N0cmluZ30gIHJvdXRpbmcgbW9kZVxyXG4gKiBAcGFyYW0gW29wdC5yb3V0ZWF0dHJpYnV0ZXM9d2F5cG9pbnRzLHN1bW1hcnksc2hhcGVdIHtzdHJpbmd9ICByb3V0ZSBhdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSBbb3B0Lm1hbmV1dmVyYXR0cmlidXRlcz1kaXJlY3Rpb24sYWN0aW9uXSB7c3RyaW5nfSAgbWFub2V1dmVyIGF0dHJpYnV0ZXNcclxuICogQHJldHVybnMge1Byb21pc2V9IHJldHVybnMgeyBzdW1tYXJ5OiBvYmplY3QsIGNvb3JkczphcnJheSxyb3V0ZTogb2JqZWN0LCBib2R5Om9iamVjdH0uIGNvb3JkcyBpcyBhcnJheSBvZiBjb29yZCwgdG8gYmUgdXNlZCB3aXRoIGhtLnBvbHlsaW5lLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICAqIGBgYGpzXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLFs0OC43LDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTtcclxuICAqIFxyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoW1s0OC44LDIuM10sWzQ4LjksMi43XV0sIFs0OS4zLDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5yb3V0ZSk7IFxyXG4gICogXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLCBbWzQ4LjksMi43XSwgWzQ5LjMsMi41XV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTsgXHJcbiAgKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHJvdXRlKHNvdXJjZSwgZGVzdCwgb3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIsXHJcbiAgICAgICAgcmVwcmVzZW50YXRpb246IFwibGlua1BhZ2luZ1wiLFxyXG4gICAgICAgIHJvdXRlYXR0cmlidXRlczogXCJ3YXlwb2ludHMsc3VtbWFyeSxzaGFwZVwiLFxyXG4gICAgICAgIG1hbmV1dmVyYXR0cmlidXRlczogXCJkaXJlY3Rpb24sYWN0aW9uXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgLy8gMSBzZXVsIHNvdXJjZSBvdSBhcnJheSBkZSBzb3VyY2UgP1xyXG4gICAgbGV0IGlkID0gMDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVswXSkpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHBhcmFtc1tcIndheXBvaW50XCIgKyBpZCsrXSA9IHNvdXJjZVswXSArIFwiLFwiICsgc291cmNlWzFdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RbMF0pKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gZGVzdFtpXTtcclxuICAgICAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBkZXN0WzBdICsgXCIsXCIgKyBkZXN0WzFdO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlcm91dGUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcmVzLmJvZHkucmVzcG9uc2Uucm91dGVbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSByb3V0ZS5zdW1tYXJ5O1xyXG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSByb3V0ZS5zaGFwZS5tYXAoKGxhdGxuZyA9PiBsYXRsbmcuc3BsaXQoXCIsXCIpKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBzdW1tYXJ5LCBjb29yZHM6IGNvb3Jkcywgcm91dGU6IHJvdXRlLCBib2R5OiByZXMuYm9keSB9O1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhbiBpc29saW5lLiBbU2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXShodHRwOi8vZG9jdW1lbnRhdGlvbi5kZXZlbG9wZXIuaGVyZS5jb20vcGRmL3JvdXRpbmdfaGxwLzcuMi4xMDAvUm91dGluZyUyMEFQSSUyMHY3LjIuMTAwJTIwRGV2ZWxvcGVyJ3MlMjBHdWlkZS5wZGYpXHJcbiAgKiBAYWxpYXMgaG06aXNvbGluZVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbiBmb3IgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5zdGFydF0ge2Nvb3JkfSBjb29yZCBmb3Igc3RhcnRpbmcgcG9pbnQgb2YgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5kZXN0aW5hdGlvbl0ge2Nvb3JkfSBjb29yZCBmb3IgZGVzdGluYXRpb24gcG9pbnQgb2YgaXNvbGluZVxyXG4gKiBAcGFyYW0gW29wdC5yYW5nZVR5cGU9XCJ0aW1lXCJdIHtzdHJpbmd9IHRpbWUgb3IgZGlzdGFuY2VcclxuICogQHBhcmFtIFtvcHQucmFuZ2VdIHtudW1iZXJ9IHJhbmdlIGluIHNlY29uZHMgb3IgaW4gbWV0ZXJzXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9XCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCJdIHtTdHJpbmd9IHJvdXRpbmcgbW9kZVxyXG4gKiBAcGFyYW0gW29wdC5saW5rYXR0cmlidXRlcz1zaF0ge1N0cmluZ30gYXR0cmlidXRlcyB0byBiZSByZXR1cm5lZFxyXG4gKiBcclxuICogQHJldHVybnMge1Byb21pc2V9ICByZXR1cm5zIHsgcG9seTphcnJheSwgYm9keTpvYmplY3QgfS4gUG9seSBpcyBhcnJheSBvZiBjb29yZHMsIGJvZHkgaXMgZnVsbCBhbnN3ZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzb2xpbmUob3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgc3RhcnQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBkaXJlY3QgaXNvbGluZVxyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmV2ZXJzZSBpc29saW5lXHJcbiAgICAgICAgcmFuZ2VUeXBlOiBcInRpbWVcIiwgICAgICAgICAgICAgICAgICAgICAgLy8gdGltZSBvciBkaXN0YW5jZVxyXG4gICAgICAgIHJhbmdlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBzZWNvbmRzIG9yIG1ldGVyc1xyXG4gICAgICAgIGxpbmthdHRyaWJ1dGVzOiBcInNoXCIsICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCB0aGUgc2hhcGVcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiwgICAvL3Nob3J0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkIFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhcnQpXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0ID0gXCJnZW8hXCIgKyBwYXJhbXMuc3RhcnRbMF0gKyBcIixcIiArIHBhcmFtcy5zdGFydFsxXTtcclxuICAgIGlmIChwYXJhbXMuZGVzdGluYXRpb24pXHJcbiAgICAgICAgcGFyYW1zLmRlc3RpbmF0aW9uID0gXCJnZW8hXCIgKyBwYXJhbXMuZGVzdGluYXRpb25bMF0gKyBcIixcIiArIHBhcmFtcy5kZXN0aW5hdGlvblsxXTtcclxuXHJcbiAgICBpZiAoIXBhcmFtcy5zdGFydCAmJiAhcGFyYW1zLmRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJJc29saW5lIHJvdXRpbmcgOiBtaXNzaW5nIHN0YXJ0IG9yIGRlc3RpbmF0aW9uXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmFtcy5yYW5nZSkge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiSXNvbGluZSByb3V0aW5nIDogbWlzc2luZyByYW5nZVwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiaXNvbGluZS5yb3V0ZVwiLCBcImFwaS5oZXJlLmNvbS9yb3V0aW5nLzcuMi9jYWxjdWxhdGVpc29saW5lLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwicG9zdFwiKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBvZiBsYXQsbG5nLCB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHJlcy5ib2R5LnJlc3BvbnNlLmlzb2xpbmVbMF0uY29tcG9uZW50WzBdLnNoYXBlO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gc2hhcGUubWFwKHBvaW50ID0+IHBvaW50LnNwbGl0KFwiLFwiKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBwb2x5OiBwb2x5LCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgbWF0cml4LiBbU2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXShodHRwOi8vZG9jdW1lbnRhdGlvbi5kZXZlbG9wZXIuaGVyZS5jb20vcGRmL3JvdXRpbmdfaGxwLzcuMi4xMDAvUm91dGluZyUyMEFQSSUyMHY3LjIuMTAwJTIwRGV2ZWxvcGVyJ3MlMjBHdWlkZS5wZGYpXHJcbiAqIFxyXG4gKiBNYXRyaXggc2l6ZSBpcyBsaW1pdGVkIHRvIDF4MTAwLCAxMDB4MSBvciAxNXhOXHJcbiAgKiBAYWxpYXMgaG06bWF0cml4XHJcbiAqIEBwYXJhbSBzb3VyY2Uge29iamVjdH0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBkZXN0IHtvYmplY3R9IGRlc3QgYXMgXFxbbGF0LGxuZ1xcXS4gQ2FuIGJlIGFycmF5IG9mIFxcW2xhdCxsbmdcXF1cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBhZGRpdGlvbmFsIG9wdGlvbmFsIHBhcmFtZXRlcnMgbGlrZSAgbW9kZSwgc3VtbWFyeUF0dHJpYnV0ZXNcclxuICogQHBhcmFtIFtvcHQubW9kZT1cImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZW5hYmxlZFwiXSB7c3RyaW5nfSByb3V0aW5nIG1vZGUgdG8gY29tcHV0ZSBtYXRyaXhcclxuICogQHBhcmFtIFtvcHQuc3VtbWFyeUF0dHJpYnV0ZXM9XCJ0dCxkaVwiXSB7c3RyaW5nfSBhdHRyaWJ1dGVzIGluIHRoZSBhbnN3ZXJcclxuICogXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSB7IGVudHJpZXM6IG9iamVjdCwgYm9keTpvYmplY3QgfS4gZW50cmllcyBpcyB0aGUgYXJyYXkgb2Yge3N0YXJ0LHN0b3B9IGluZm9ybWF0aW9uLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgcmVzID0gYXdhaXQgaG0ubWF0cml4KHtcclxuICogICAgICBzb3VyY2U6WzQ4LjgsMi4zXVxyXG4gKiAgICAgIGRlc3Q6W1s0OC43LDIuNV0sWzQ4LjEsMi4wXSxbNDQuMiwyLjNdXVxyXG4gKiB9KTtcclxuICogY29uc29sZS5sb2cgKHJlcy5lbnRyaWVzKTsgXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1hdHJpeChzb3VyY2UsIGRlc3QsIG9wdCkge1xyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IHtcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZW5hYmxlZFwiLFxyXG4gICAgICAgIHN1bW1hcnlBdHRyaWJ1dGVzOiBcInR0LGRpXCJcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyhzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlWzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcclxuICAgIHNvdXJjZS5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcInN0YXJ0XCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZXN0WzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBkZXN0ID0gW2Rlc3RdO1xyXG4gICAgZGVzdC5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcImRlc3RpbmF0aW9uXCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwibWF0cml4LnJvdXRlXCIsIFwiYXBpLmhlcmUuY29tL3JvdXRpbmcvNy4yL2NhbGN1bGF0ZW1hdHJpeC5qc29uXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcInBvc3RcIilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4geyBlbnRyaWVzOiByZXMuYm9keS5yZXNwb25zZS5tYXRyaXhFbnRyeSwgYm9keTogcmVzLmJvZHkgfTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBkZXRvdXIgZm9yIGVhY2ggd2F5cG9pbnQgcHJvdmlkZWQsIGNvbXBhcmVkIHRvIG5vcm1hbCByb3V0ZSBmcm9tIEEgdG8gQlxyXG4gKiBcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpkZXRvdXJcclxuICogQHBhcmFtIHN0YXJ0IHtjb29yZH0gIHN0YXJ0aW5nIHBvaW50IGZvciByb3V0ZVxyXG4gKiBAcGFyYW0gc3RvcCB7Y29vcmR9ICAgZGVzdGluYXRpb24gcG9pbnQgb2Ygcm91dGVcclxuICogQHBhcmFtIHdheXBvaW50cyB7YXJyYXl9ICBsaXN0IG9mIHdhdHlwb2ludHMgdG8gdGVzdCBcclxuICogQHJldHVybnMge1Byb21pc2V9IHJldHVybnMge3JlZmVyZW5jZToge3N0YXJ0LCBzdG9wLCBkaXN0YW5jZSwgZGlzdGFuY2UyLCB0aW1lLCB0aW1lMn0gLHdheXBvaW50czpbIHtjb29yZCwgZGlzdEEsIHRpbWVBLCBkaXN0QiwgdGltZUJ9XX1cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRldG91cihzdGFydCwgc3RvcCwgd2F5cG9pbnRzKSB7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgICBuby11bmRlZlxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFxyXG4gICAgICAgIGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgLy9sZXQgdFN0YXJ0ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc3RhcnQpIHJldHVybiByZWplY3QoXCJtaXNzaW5nIHN0YXJ0IHBvaW50XCIpO1xyXG4gICAgICAgICAgICBpZiAoIXN0b3ApIHJldHVybiByZWplY3QoXCJtaXNzaW5nIHN0b3AgcG9pbnRcIik7XHJcbiAgICAgICAgICAgIGlmICghd2F5cG9pbnRzKSByZXR1cm4gcmVqZWN0KFwibWlzc2luZyB3YXlwb2ludHNcIik7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSkgcmV0dXJuIHJlamVjdChcIndheXBvaW50cyBzaG91bGQgYmUgYW4gYXJyYXlcIik7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gaW5pdGlhbGlzZSBsZSByZXN1bHRhdCBcclxuICAgICAgICAgICAgbGV0IHJlcyA9IHtcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZToge30sXHJcbiAgICAgICAgICAgICAgICB3YXlwb2ludHM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjdWwgbGVzIGNvb3JkcyBub25Qb3N0R3JlcywgY3JlZXIgbCdhcnJheSBkZSBjb29yZCBkZXMgd2F5cG9pbnRzLlxyXG4gICAgICAgICAgICBsZXQgZGVzdCA9IFtzdG9wXTsgLy8gc28gd2UgaGF2ZSBhIGRpc3RhbmNlL3RpbWUgcmVmZXJlbmNlLCBub3Qgc2FtZSBhcyBmcm9tIHJvdXRpbmcgMToxXHJcbiAgICAgICAgICAgIHdheXBvaW50cy5mb3JFYWNoKHdheXBvaW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGRlc3QucHVzaCh3YXlwb2ludCk7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgeyBjb29yZDogd2F5cG9pbnQgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGluc3BlY3QoZGVzdCwgXCJkZXN0IGZyb20gZGV0b3VyXCIpXHJcblxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIHN0YXJ0IHRvIGFsbCB3YXlwb2ludCwgMXN0IHdheXBvaW50IGlzIHN0b3AgdG8gZ2V0IGEgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGxldCBwMSA9IG1hdHJpeChzdGFydCwgZGVzdCwgeyBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgZnJvbSBhbGwgd2F5cG9pbnQgdG8gc3RvcCwgMXN0IHdheXBvaW50IGlzIHN0YXJ0IHRvIGdldCBhbm90aGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICBkZXN0WzBdID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIGxldCBwMiA9IG1hdHJpeChkZXN0LCBzdG9wLCB7IG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiIH0pO1xyXG4gICAgICAgICAgICAvLyB3YWl0IGZvciBib3RoIG1hdHJpeCB0byBjb21wbGV0ZVxyXG5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICAgbm8tdW5kZWZcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoW3AxLCBwMl0pO1xyXG5cclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBmaXJzdCBwYXJ0OiBzdGFydCA9PiBOIHdheXBvaW50c1xyXG4gICAgICAgICAgICBsZXQgZW50cmllcyA9IHJlc3VsdFswXS5lbnRyaWVzO1xyXG4gICAgICAgICAgICAvLyBmaXJzdCBlbnRyeSBpcyBzdGFydCBzdG9wXHJcbiAgICAgICAgICAgIGxldCBkaXN0ID0gZW50cmllc1swXS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICBsZXQgdGltZSA9IGVudHJpZXNbMF0uc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2Uuc3RvcCA9IHN0b3A7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UuZGlzdGFuY2UgPSBkaXN0O1xyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLnRpbWUgPSB0aW1lOyAvLyB0aGUgcmVmZXJlbmNlIHNhbnMgd2F5cG9pbnRcclxuXHJcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHJldHVybjsgLy8gc2tpcCB0aGUgZmlyc3Qgd2hpY2ggaXMgc3RhcnQgc3RvcFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zdGF0dXMgPT0gXCJmYWlsZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZW50cnksIFwiZXJyb3Igb24gbWF0cml4QVwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdGFydCwgXCJhc3NvY2lhdGVkIHN0YXJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGVzdFtpXSwgXCJhc3NvY2lhdGVkIGRlc3RcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBlbnRyeS5kZXN0aW5hdGlvbkluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSBlbnRyeS5zdW1tYXJ5LmRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSBlbnRyeS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0uZGlzdEEgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLnRpbWVBID0gdGltZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBzZWNvbmQgcGFydDogTiB3YXlwb2ludHMgPT4gc3RvcFxyXG4gICAgICAgICAgICBlbnRyaWVzID0gcmVzdWx0WzFdLmVudHJpZXM7XHJcbiAgICAgICAgICAgIC8vaW5zcGVjdChlbnRyaWVzWzBdLCBcIm1hdHJpeEIwXCIpO1xyXG5cclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5kaXN0YW5jZTIgPSBlbnRyaWVzWzBdLnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UudGltZTIgPSBlbnRyaWVzWzBdLnN1bW1hcnkudHJhdmVsVGltZTtcclxuXHJcbiAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHJldHVybjsgLy8gc2tpcCB0aGUgZmlyc3Qgd2hpY2ggaXMgc3RhcnQgc3RvcFxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zdGF0dXMgPT0gXCJmYWlsZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZW50cnksIFwiZXJyb3Igb24gbWF0cml4QlwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlbnRyeSwgXCJhc3NvY2lhdGVkIHN0YXJ0XCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHN0b3AsIFwiYXNzb2NpYXRlZCBzdG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBpZCA9IGVudHJ5LnN0YXJ0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IGVudHJ5LnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZSA9IGVudHJ5LnN1bW1hcnkudHJhdmVsVGltZTtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS5kaXN0QiA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0udGltZUIgPSB0aW1lO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzKTtcclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG1hdHJpeDogbWF0cml4LFxyXG4gICAgcm91dGU6IHJvdXRlLFxyXG4gICAgaXNvbGluZTogaXNvbGluZSxcclxuICAgIGRldG91cjogZGV0b3VyXHJcbn07XHJcblxyXG4iLCIvKiBnbG9iYWwgZG9jdW1lbnQsSCAqL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuY29uc3QgaG0gPSByZXF1aXJlKFwiLi9tYXAuanNcIik7XHJcbmNvbnN0IHNpbXBsaWZ5ID0gcmVxdWlyZShcInNpbXBsaWZ5LWpzXCIpO1xyXG5cclxuXHJcbmxldCBfdG91Y2hPZmZzZXQgPSBudWxsO1xyXG5sZXQgX3RvdWNoQ29vcmRzID0gbnVsbDtcclxubGV0IF90b3VjaFBvbHlsaW5lID0gbnVsbDtcclxubGV0IF90b3VjaExheWVyID0gbnVsbDtcclxubGV0IF90b3VjaENhbGxiYWNrID0gbnVsbDtcclxubGV0IF9tYXAgPSBudWxsO1xyXG5sZXQgX2JlaGF2aW9yID0gbnVsbDtcclxuXHJcbmxldCBfYmVoYXZpb3JFbmFibGUgPSB0cnVlO1xyXG5mdW5jdGlvbiBiZWhhdmlvckVuYWJsZShvbm9mZikge1xyXG4gICAgaWYgKF9iZWhhdmlvckVuYWJsZSAmJiAhb25vZmYpIHtcclxuICAgICAgICBfYmVoYXZpb3IuZGlzYWJsZSgpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJiZWhhdmlvciBkaXNhYmxlZFwiKTtcclxuICAgICAgICBfYmVoYXZpb3JFbmFibGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghX2JlaGF2aW9yRW5hYmxlICYmIG9ub2ZmKSB7XHJcbiAgICAgICAgX2JlaGF2aW9yLmVuYWJsZSgpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJiZWhhdmlvciBlbmFibGVkXCIpO1xyXG4gICAgICAgIF9iZWhhdmlvckVuYWJsZSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGFjdGl2YXRlIHRvdWNoLCBhbGxvd2luZyBoYW5kIGRyYXdpbmcsIHdpdGggZW1iZWRkZWQgc2ltcGxpZmljYXRpb24gb2YgdGhlIGxpbmVcclxuICogQGFsaWFzIGhtOnRvdWNoXHJcbiAqIEBwYXJhbSBvbm9mZiB7Ym9vbGVhbn0gIGFjdGl2YXRlIG9yIGRlYWN0aXZhdGVcclxuICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gb3B0aW9ucyAgdG8gY29udHJvbCB0aGUgdG91Y2ggYmVoYXZpb3VyXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5jYWxsYmFja10ge2Z1bmN0aW9ufSBjYWxsaW5nIGNhbGxiYWNrKGNvb3Jkcykgd2hlbiB0b3VjaCBlbmRzXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5sYXllcl0ge3N0cmluZ30gbGF5ZXIgd2hlcmUgdG8gcHV0IHRoZSBkcmF3aW5nXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5zdHlsZV0ge29iamVjdH0gZHJhd2luZyBzdHlsZSBmb3IgdGhlIGxpbmVcclxuICogQHBhcmFtIFtvcHRpb25zLmFycm93XSB7b2JqZWN0fSBhcnJvdyBzdHlsZSBmb3IgdGhlIGxpbmVcclxuICogQHBhcmFtIFtvcHRpb25zLnRvbGVyYW5jZT00XSB7bnVtYmVyfSB0b2xlcmFuY2UgZm9yIHNpbXBsaWZpY2F0aW9uXHJcbiAqIEBwYXJhbSBbb3B0aW9ucy5rZWVwPWZhbHNlXSB7Ym9vbGVhbn0ga2VlcCBncmFwaGljIG9yIG5vdCB3aGVuIGNhbGxpbmcgY2FsbGJhY2tcclxuICovXHJcbmZ1bmN0aW9uIHRvdWNoKG9ub2ZmLCBvcHRpb25zKSB7XHJcblxyXG4gICAgX21hcCA9IGhtLmdldE1hcCgpO1xyXG4gICAgX2JlaGF2aW9yID0gaG0uZ2V0QmVoYXZpb3IoKTtcclxuICAgIGxldCBlbG10ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaG0uZ2V0TWFwSHRtbEl0ZW0oKSk7XHJcblxyXG4gICAgbGV0IGJiID0gZWxtdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIF90b3VjaE9mZnNldCA9IHsgbGVmdDogYmIueCwgdG9wOiBiYi55IH07IC8vIG9mZnNldCBvZiB3aW5kb3cgdG8gYnJvd3NlclxyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGNhbGxiYWNrOiBudWxsLFxyXG4gICAgICAgIGxheWVyOiBcIl90b3VjaFwiLFxyXG4gICAgICAgIGtlZXA6IGZhbHNlLFxyXG4gICAgICAgIHN0eWxlOiB7IGxpbmVXaWR0aDogNSwgc3Ryb2tlQ29sb3I6IFwicmdiYSgyNTUsIDAsIDAsIDAuNylcIiB9LFxyXG4gICAgICAgIGFycm93czogeyBmaWxsQ29sb3I6IFwid2hpdGVcIiwgZnJlcXVlbmN5OiA1LCB3aWR0aDogMSwgbGVuZ3RoOiAyIH0sXHJcbiAgICAgICAgdG9sZXJhbmNlOiA0LCAvLyBsZXZlbCBvZiBzaW1wbGlmaWNhdGlvblxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgICBfdG91Y2hMYXllciA9IGhtLmxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIV90b3VjaExheWVyKSB7XHJcbiAgICAgICAgX3RvdWNoTGF5ZXIgPSBobS5sYXllckNyZWF0ZShzZXR0aW5ncy5sYXllcik7XHJcbiAgICAgICAgLy9fdG91Y2hMYXllciA9IGhtLmxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbGJhY2sgZGVzIGV2ZW50IExpc3RlbmVyXHJcbiAgICAvLyBkZWZpbmkgc2V1bGVtZW50IHN1ciBvbm9mZiwgcG91ciBuZSBwYXMgY3JlZXIgdW5lIGF1dHJlIGZvaXMgbGEgZm9uY3Rpb25cclxuICAgIGlmIChvbm9mZilcclxuICAgICAgICBfdG91Y2hDYWxsYmFjayA9IGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgdG91Y2hvYmogPSBlLmNoYW5nZWRUb3VjaGVzWzBdOyAvLyByZWZlcmVuY2UgZmlyc3QgdG91Y2ggcG9pbnQgKGllOiBmaXJzdCBmaW5nZXIpXHJcblxyXG4gICAgICAgICAgICAvLyBpZiAoKGUudG91Y2hlcy5sZW5ndGggPj0gMiAmJiBlLnRhcmdldFRvdWNoZXMubGVuZ3RoID49IDIpKSB7XHJcbiAgICAgICAgICAgIGlmICgoZS50b3VjaGVzLmxlbmd0aCA+PSAyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgY29uc29sZS5sb2coXCJ0b3VjaC5sZW5ndGhcIiwgZS50b3VjaGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBiZWhhdmlvckVuYWJsZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSBcInRvdWNobW92ZVwiKVxyXG4gICAgICAgICAgICAgICAgYmVoYXZpb3JFbmFibGUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZS50eXBlXCIsIGUudHlwZSk7XHJcbiAgICAgICAgICAgIGxldCBzaW1wbGlmaWVkO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgX3RvdWNoQ29vcmRzID0gW107IC8vIGNvb3Jkc1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcclxuICAgICAgICAgICAgICAgICAgICAvLyAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdG91Y2hDb29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRvdWNob2JqLmNsaWVudFggLSBfdG91Y2hPZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdG91Y2hvYmouY2xpZW50WSAtIF90b3VjaE9mZnNldC50b3BcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90b3VjaENvb3Jkcy5sZW5ndGggPCAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lU3RyaW5nID0gbmV3IEguZ2VvLkxpbmVTdHJpbmc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF90b3VjaENvb3Jkcy5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGMueCwgYy55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0cmluZy5wdXNoTGF0TG5nQWx0KGNvb3JkLmxhdCwgY29vcmQubG5nLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIHBvbHlsaW5lIGlmIG5vdCBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90b3VjaFBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90b3VjaFBvbHlsaW5lID0gbmV3IEgubWFwLlBvbHlsaW5lKGxpbmVTdHJpbmcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycm93czogc2V0dGluZ3MuYXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdG91Y2hMYXllci5hZGRPYmplY3QoX3RvdWNoUG9seWxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSAgLy8gbW9kaWYgZ2VvbWV0cnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RvdWNoUG9seWxpbmUuc2V0R2VvbWV0cnkobGluZVN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6IC8vIGMnZXN0IGxhIGZpbiwgb24gc2ltcGxpZmllIGV0IGFwcGVsbGUgbGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RvdWNoQ29vcmRzLmxlbmd0aCA8IDIpIC8vIG5vdCBlbm91Z2ggcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZCA9IF90b3VjaENvb3JkczsgLy9hcyBhcnJheSBvZiB7eCx5fVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jYWxsYmFjaykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGxpZnkgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudG9sZXJhbmNlID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBzaW1wbGlmeShfdG91Y2hDb29yZHMsIHNldHRpbmdzLnRvbGVyYW5jZSwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBwb2ludHMsIGdvIGJhY2sgdG8gaW5pdGlhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxpZmllZC5sZW5ndGggPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZCA9IF90b3VjaENvb3JkcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbXt4LHl9IHNjcmVlbiB0byBbbGF0LGxuZ11cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9IHNpbXBsaWZpZWQubWFwKGNvb3JkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsYXRsbmcgPSBfbWFwLnNjcmVlblRvR2VvKGNvb3JkLngsIGNvb3JkLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsYXRsbmcubGF0LCBsYXRsbmcubG5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBjb29yZHMgPSBnZW9tLnNpbXBsaWZ5KF90b3VjaENvb3Jkcywgc2V0dGluZ3MudG9sZXJhbmNlKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy91cCB0byBjYWxsYmFjayB0byByZWRyYXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90b3VjaFBvbHlsaW5lICYmICFzZXR0aW5ncy5rZWVwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RvdWNoTGF5ZXIucmVtb3ZlT2JqZWN0KF90b3VjaFBvbHlsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RvdWNoUG9seWxpbmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3JFbmFibGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5jYWxsYmFjayhjb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9OyAvLyBvZiBfdG91Y2hcclxuXHJcblxyXG5cclxuICAgIGlmIChvbm9mZikge1xyXG4gICAgICAgIGVsbXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RvdWNoQ2FsbGJhY2spO1xyXG4gICAgICAgIGVsbXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdG91Y2hDYWxsYmFjayk7XHJcbiAgICAgICAgZWxtdC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RvdWNoQ2FsbGJhY2spO1xyXG4gICAgICAgIC8vICAgICAgICBiZWhhdmlvckVuYWJsZShmYWxzZSk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlbG10LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90b3VjaENhbGxiYWNrKTtcclxuICAgICAgICBlbG10LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RvdWNoQ2FsbGJhY2spO1xyXG4gICAgICAgIGVsbXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90b3VjaENhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgaWYgKF90b3VjaFBvbHlsaW5lKVxyXG4gICAgICAgICAgICBfdG91Y2hMYXllci5yZW1vdmVPYmplY3QoX3RvdWNoUG9seWxpbmUpO1xyXG5cclxuICAgICAgICBfdG91Y2hMYXllciA9IG51bGw7XHJcbiAgICAgICAgX3RvdWNoUG9seWxpbmUgPSBudWxsO1xyXG4gICAgICAgIF90b3VjaENvb3JkcyA9IG51bGw7XHJcbiAgICAgICAgYmVoYXZpb3JFbmFibGUodHJ1ZSk7XHJcbiAgICB9XHJcblxyXG5cclxufSAvLyBvZiB0b3VjaFxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdG91Y2g6IHRvdWNoXHJcbn07Il19
