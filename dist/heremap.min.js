(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.heremap = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],3:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":2,"./is-object":4,"./request-base":5,"./response-base":6,"component-emitter":8}],4:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],5:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":4}],6:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":7}],7:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],8:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],9:[function(require,module,exports){
/* global H, fetch */
"use strict";
const m = require("map");

let map = null;

let clusterLayer = null;


/**
 * creates a cluster of points
 * @async
 * @alias hm:cluster
 * @param coords {Array}  array of \[lat,lng,payload\]
 * @param opt {object} options for cluster
 * @param [opt.minZoom] {number} min zoom for cluster to be visible
 * @param [opt.maxZoom] {number} max zoom for cluster to be visible
 * @param [opt.noise] {array} graphic to represent stand-alone point. format: [url,size]
 * @param [opt.clusterIcon] {string} url of svg file representing a cluster
 * @param [opt.style] {object} define for each minium aggregation level the color and size of the icon. See example
 * @param {function} cb callback to be called if click on item. Format cb(event, coord, payload, weigth). 
 * `coord` is coord of icon
 * `payload` is payload associated to point. 
 * `weight` is number of points aggregated, when clicking on a cluster icon, 1 if single point
 * 
 * @return {H.map.layer.ObjectLayer}  layer created
 * 
  * @example
  * ```js
  * let pois = [[48.8,2.3,"Hello world"],[48.5,2.4,"How are you"],[45.2,2.93,"Very well"]];
  * 
  * hm.cluster(pois);
  * 
  * // with more graphic options and callback defined
 *  hm.cluster(pois, {
 *           noise: ["mcdo.png", 24],
 *           clusterIcon: '../svg/cluster2.svg',    //  icon for cluster
 *           style: {
 *               200: { color: "#B50015", size: 64 }  // for 200 or more points aggrregated, drag red big icon
 *               75: { color: "#FF6900", size: 58 },  // for 75 or more points aggregated. orange middle size icon
 *               2: { color: "#7BD30A", size: 46 },   // for 2 or more points aggregated. green small icon
 *           }
 *       },
 *           (event, coordinate, data, weight) => {
 *               if (data)
 *                   console.log("click on point ", data);
 *               else
 *                   console.log("click on cluster with weight", weight);
 *           });
* ```
 */
async function cluster(coords, opt, cb = null) {

    let dataPoints = [];
    map = m.getMap();

    let settings = {
        minZoom: 1,     // min zoom
        maxZoom: 24,    // max zoom
        noise: ["http:svg/bluedot.svg", 16],  //  icon+size for noise, can be svg or image
        clusterIcon: "http:svg/cluster.svg",    //  icon for cluster
        style: {
            75: { color: "#FF6900", size: 36 },
            3: { color: "#7BD30A", size: 32 },
            200: { color: "#B50015", size: 48 }
        }
    };
    if (opt)
        Object.assign(settings, opt);


    coords.forEach(coord => {
        // use op_weight of 1 for each coord
        // provides all coord as data
        let dp = new H.clustering.DataPoint(coord[0], coord[1], 1, coord);
        dataPoints.push(dp);

    });


    // noise icon : if SVG, needs to fetch it
    let noiseIcon = settings.noise[0];
    let noiseSize = settings.noise[1];

    if (noiseIcon.substr(-3) == "svg") {
        noiseIcon = await fetch(noiseIcon)
            .then(res => {
                if (res.status != 200)
                    return null;
                return res.text();
            });

    }

    if (!noiseIcon) return; // if no result, let's quit

    // to speed up, create only once the icon for noise
    const iconNoise = new H.map.Icon(noiseIcon, { size: { w: noiseSize, h: noiseSize } });

    // let's now fetch cluster icon
    let svgCluster = await fetch(settings.clusterIcon)
        .then(res => {
            if (res.status != 200)
                return null;
            return res.text();
        });

    if (!svgCluster)
        return;


    // to speed display display, we will cache the various cluster icons
    // from the base svg, we will create different icons with different size/color/text
    let cacheIcon = {}; // cache of icons

    // order style by size descending
    let styleSize = Object.keys(settings.style).sort(function (a, b) { return b - a; });

    // this function  cretaes the icon for a cluster
    function getClusterPresentation(cluster) {

        // building data object which will be returned when clicking on the icon
        var data = {};
        data.isCluster = () => { return true; };  // so we know it is a cluster
        let weight = cluster.getWeight();
        data.getWeight = () => { return weight; }; // number of individual item clustered together

        // let's find the relevant color and size
        let entry = styleSize.find(elt => (weight >= elt));
        let color = settings.style[entry].color;
        let size = settings.style[entry].size;

        // let's create and cache the needed icons
        let key = color + "-" + weight + "-" + size;
        if (typeof cacheIcon[key] == "undefined") {
            let svg = svgCluster.replace("{text}", weight).replace(/{color}/g, color);
            cacheIcon[key] = new H.map.Icon(svg, { size: { w: size, h: size } });
        }

        // create a marker for the Cluster
        var clusterMarker = new H.map.Marker(cluster.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: cluster.getMinZoom(),
            max: cluster.getMaxZoom(),
            icon: cacheIcon[key],

        });

        // Link data from the from the cluster to the marker,
        // to make it accessible on callback
        clusterMarker.setData(data);

        return clusterMarker;
    }

    // function to represent a single item
    function getNoisePresentation(noisePoint) {

        // data to be sent on callback
        const data = {
            getData: () => { return noisePoint.getData(); },
            isCluster: () => { return false; },
            getWeight: () => { return 1; }
        };

        // Create a marker for the noisePoint
        var noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: noisePoint.getMinZoom(),
            icon: iconNoise
        });


        // Link a data from the point to the marker
        // to make it accessible on callback
        noiseMarker.setData(data);

        return noiseMarker;
    }


    // create cluster provider
    let clusteredDataProvider = new H.clustering.Provider(dataPoints, {
        clusteringOptions: {
            // Maximum radius of the neighborhood
            eps: 64,
            // minimum weight of points required to form a cluster
            minWeight: styleSize[styleSize.length - 1] // minimum clustering is defined by minsize in Style
        },
        min: settings.minZoom, // min zoom
        max: settings.maxZoom, // max zoom
        theme: { getClusterPresentation: getClusterPresentation, getNoisePresentation: getNoisePresentation }
    });

    // Create a layer that includes the data provider and its data points:
    let layer = new H.map.layer.ObjectLayer(clusteredDataProvider);
    // Add the layer to the map:
    map.addLayer(layer);

    // if a callback is defined, add event listener
    if (cb) {
        clusteredDataProvider.addEventListener("tap", function (ev) {
            // Log data bound to the marker that has been tapped:
            let data = ev.target.getData();
            let coord = map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            let isCluster = data.isCluster();

            if (isCluster) {
                let weigth = data.getWeight();
                cb(ev, m.coordO2A(coord), null, weigth);
            }

            else {
                let userData = data.getData(); // lat,lng, payload
                cb(ev, m.coordO2A(coord), userData[2], 1);
            }
        });
    }

    return layer;
}

function hide() {
    clusterLayer.setMax(0);
    clusterLayer.setMin(0);
}

function show() {
    clusterLayer.setMax(24);
    clusterLayer.setMin(0);

}


module.exports = {
    cluster: cluster,
    clusterShow: show,
    clusterHide: hide
};


},{"map":12}],10:[function(require,module,exports){
(function (process){
/* global document */
"use strict";

const request = require("superagent");

// by default, unless specified fby calling config
// environment usable with node
let APP_ID = process.env.APP_ID;
let APP_CODE = process.env.APP_CODE;
let CIT = ""; // production by default
let PROTOCOL = "https:"; // by default
let _useHTTPS = true; // by default
let _home = ".";


// find out where we are and relative position for png/svg files
// pay attention if library is build in ./dist
if (process.browser) {
    let _script = document.getElementsByTagName("script");
    let _file = _script[_script.length - 1].src;
    let _path = _file.substring(0, _file.lastIndexOf("/"));

    _home = _path + "/../"; // a bit dirty but ...
}

/**
 * To configure app_id, app_code and optionally use CIT and http
 * @alias hm:config
 *
 * @param opt {Object}  - `opt` with parameters.
 * @param [opt.app_id] {string} - the app_id from developer.here.com
 * @param [opt.app_code] {string} - the app_code from developer.here.com
 * @param [opt.useCIT=false] {boolean} - true to use CIT environment. 
 * @param [opt.useHTTP=false] {string} - true to use HTTP. 
 * @param [opt.useHTTPS=true] {string} - true to use HTTPS. 
 *
 * @example
 * ```js
 *  hm.config({
 *      app_id: "YOUR APP_ID",
 *      app_code: "YOUR APP_CODE",
*   });
*  ```
 */
function config(opt) {
    if (opt.app_id) APP_ID = opt.app_id;
    if (opt.app_code) APP_CODE = opt.app_code;
    if (opt.useCIT) CIT = ".cit";
    if (opt.useHTTP) {
        PROTOCOL = "http:";
        _useHTTPS = false;
    }
    if (opt.useHTTPS) {
        PROTOCOL = "https:";
        _useHTTPS = true;
    }
}

/**
 * return URL of module home directory
 * @ignore
 *  @alias hm:getHome
 * @return {string} url of home directory including http or https
 */
function getHome() {
    return _home;
}

/**
 * returns app_id
 * @ignore
 *  @alias hm:getAppId
 * @return {string} app_id
*/
function getAppId() {
    return APP_ID;
}

/**
 * return app_code
 *  @ignore
 *  @alias hm:getHome
 *  @alias hm:getAppCode
  * @return {string} app_code
*/
function getAppCode() {
    return APP_CODE;
}

/**
 * return true if using CIT
 * @ignore
 * @alias hm:getCIT
 * @return {booolean} true if using CIT
*/
function getCIT() {
    return CIT;
}

/**
 * return protocol used, http:// or https://
 * @ignore
 * @alias hm:getProtocol
 * @return {string} - protocol
*/
function getProtocol() {
    return PROTOCOL;
}

/**
 * return true is https is used
 * @ignore
 *  @alias hm:useHTTPS
 * @return {boolean} - true if https is used
*/
function useHTTPS() {
    return _useHTTPS;
}

/**
 * add credentials to object provided
  * @ignore
 *  @alias hm:addCredentials
 * @param  {...objects} list of `objects` 
 * @return {object} object with all input objectconcatenated, and app_id/app_code inserted
 */
function addCredentials(...obj) {
    return Object.assign({
        app_id: APP_ID,
        app_code: APP_CODE
    }, ...obj);
}

/**
 * build HERE REST full url, taking in account protocol and cit. for instance  cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json"
 * @ignore
 * @alias hm:buildUrl
 * @param {string} base - base name
 * @param {string} endpoint - end point
 * @return {string} full url
 */
function buildUrl(base, endpoint) {
    return PROTOCOL + "//" + base + CIT + "." + endpoint;
}

/**
 * does get/post request to HERE RESDT backend and manage main errors
 * @ignore
 * @alias hm:hereRest
 * @param {string} url  - url to call , for instance from buildUrl
 * @param {object} settings - settings to add in request
 * @param  {string} mode=get - mode "get" or "post"
 * @return {promise} - promise to resolve/reject
 */
async function hereRest(url, settings, mode = "get") {

    let p = request.get(url);
    if (mode == "post")
        p = request.post(url);

    return p
        .query(settings)
        .then(res => {
            // res.body, res.headers, res.status
            if (res.status != "200") {
                let e = new Error("Error " + res.status + ":" + res.body); // e.message
                throw (e);
            }


            if (!res.body.Response && !res.body.response) { // one of the two should be in the answer
                console.error(res.body);
                let e = new Error("Query error:" + res.body); // e.message
                throw (e);
            }

            if (res.body.response && res.body.response.type == "ApplicationError") {
                console.error(res.body);
                let e = new Error("Error" + res.body.response.details); // e.message
                throw (e);
            }

            return res;
        });
}

module.exports = {
    config: config,
    buildUrl: buildUrl,
    getAppId: getAppId,
    getAppCode: getAppCode,
    getCIT: getCIT,
    getProtocol: getProtocol,
    getHome: getHome,
    useHTTPS: useHTTPS,
    addCredentials: addCredentials,
    hereRest: hereRest
};
}).call(this,require('_process'))

},{"_process":1,"superagent":3}],11:[function(require,module,exports){
/**
 * @file Geocoding functions : addresses <--> [lat,lng]
 * @author Devbab 
 */

"use strict";
const cm = require("./common.js");

/**
 * geocode an address
 * @async
 * @alias hm:geocode
 * @param {string} address - address as string
 * @returns {Object} returns  {coord,body}. coord is geocode as \[lat,lng\]. body is full json answer
 * 
 * @example
 * ```js
 * const res = await hm.geocode("avenue des chaps elysees, paris");
 * console.log (res.coord);
 * ```
 */
async function geocode(address) {

    const settings = cm.addCredentials({
        searchText: address
    });

    const url = cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json");
    return cm.hereRest(url, settings)
        .then(res => {

            if (res.body.Response.View.length == 0) {
                let e = new Error("Geocode Address not found: " + address); // e.message
                throw (e);
            }

            var location = res.body.Response.View[0].Result[0].Location;
            var coord = [location.NavigationPosition[0].Latitude, location.NavigationPosition[0].Longitude];
            return { coord: coord, body: res.body };
        });
}


/**
 * reverse geocode a coordinate
 * @async
 * @alias hm:reverseGeocode
 * @param {Coord} coord - coord \[lat,lng\] to reverse geocode
 * @returns {object} returns { location:object, address:object, body:object}. 
 */
async function reverseGeocode(coord) {

    const settings = cm.addCredentials({
        mode: "retrieveAddresses",
        prox: coord[0] + "," + coord[1]
    });

    const url = cm.buildUrl("reverse.geocoder", "api.here.com/6.2/reversegeocode.json");

    return cm.hereRest(url, settings)
        .then(res => {
            // res.body, res.headers, res.status
            var location = res.body.Response.View[0].Result[0].Location;
            return ({ location: location, address: location.Address, body: res.body });
        });
}


module.exports = {
    geocode: geocode,
    reverseGeocode: reverseGeocode
};


},{"./common.js":10}],12:[function(require,module,exports){
/* global H, fetch, document, navigator, mapsjs, window APP_ID_JAPAN,APP_CODE_JAPAN,APP_ID_KOREA,APP_CODE_KOREA*/

"use strict";
const cm = require("./common.js");

let _platform = null;
let _provider = null;
let _defaultLayers = null;
let _ui = null;
let _map = null;
let group = null;
let _layers = []; // list all layers
let _key = {};     // keys  
let _bubbleMarker = null;     // bubble de mamrker
let _scheme = "normal.day.grey";
let _locateMe = null;         // id when locate is active



function coordO2A(obj) {
    return [obj.lat, obj.lng];
}

function coordA2O(arr) {
    return { lat: arr[0], lng: arr[1] };
}


/**
 * create a map area within the specified item
  * @alias hm:map

 * @param htmlItem {string}  - identifier of html div item on which to insert map
 * @param opt {object}  - options
 * @param [opt.zoom=10] {number}  - zoom factor
 * @param [opt.center=[48.86, 2.3]] {Coord}  - Coord of the center
 * @param [opt.click=null] {function()}  - callback on mouse click: callback(coord,button,key)
 * @param [opt.dbClick=null] {function()}  - callback on mouse double click: callback(coord,button,key)
 * @param [opt.clickLeft=null] {function}  - callback on mouse click left: callback(coord,button,key)
 * @param [opt.clickRight=null] {function()}  - callback on mouse click right.: callback(coord,button,key)
 * @param [opt.keyDown=null] {function}  - callback on key down : callback(key)
 * @param [opt.viewChange=null] {function}  - callback if map is panned or zoomed : callback(zoom,coordCenter)
 * @param [opt.loadTile=null] {function}  - callback when a tile is loaded : callback(z,x,y,url)
 *
 * @example
 * ```js
 * const hm = window.heremap;
 * 
 * hm.config({
 *    app_id: "YOUR APP_ID",
 *    app_code: "YOUR APP_CODE",
 * });
 *
 * hm.map("map", {
 *    zoom:5,
 *    center: [48.8,2.3],
 *    click: function(coord,button,key) {console.log("clicked on",coord,"with button",button);}
 * });
*  ```
*/
function map(htmlItem, opt) {

    let settings = {
        zoom: 10,
        center: [48.86, 2.3],
        clickLeft: null,
        clickRight: null,
        keyDown: null,  // keyboard event
        click: null,
        dbClick: null,
        viewChange: null, // (zoom,coord)
        loadTile: null // quand une tile est affichée
    };

    let mps = 1;

    let app_id = cm.getAppId();
    let app_code = cm.getAppCode();

    if (!app_id || !app_code) {
        console.log("app_id/app_code not initialised");
        document.getElementById(htmlItem).innerHTML = "app_id/app_code not initialised";
        return;
    }

    _platform = new H.service.Platform({
        app_id: app_id,
        app_code: app_code,
        useCIT: cm.getCIT(),
        useHTTPS: cm.useHTTPS()
    });

    Object.assign(settings, opt);
    if (settings.scheme) _scheme = settings.scheme; // store scheme if defined

    _defaultLayers = _platform.createDefaultLayers();
    console.log(_defaultLayers);

    // http://heremaps.github.io/examples/explorer.html#map-tiles__base-map-styles-and-modes
    _provider = new H.map.provider.ImageTileProvider({
        label: "Base Provider",
        descr: "",
        min: 0,
        max: 20,
        crossOrigin: "anonymous",
        getURL: function (col, row, level) {
            mps++; if (mps > 4) mps = 1;
            let url = [cm.getProtocol(), "//", mps, ".base.maps" + cm.getCIT() + ".api.here.com/maptile/", "2.1",
                "/", "maptile", "/", "newest", "/",
                _scheme, "/", level, "/", col, "/", row, "/", "256",
                "/", "png", "?lg=", "FRE",
                "&app_code=", app_code, "&app_id=",
                app_id].join("");

            if (_scheme == "japan")
                url = [cm.getProtocol(), "//", "m.lbs" + cm.getCIT() + ".api.heremaps.jp/v1/map?app_id=",
                    APP_ID_JAPAN,
                    "&app_code=",
                    APP_CODE_JAPAN,
                    "&tilematrix=EPSG:900913:",
                    level,
                    "&tilecol=",
                    col,
                    "&tilerow=",
                    row].join("");

            else if (_scheme == "korea")
                url = [cm.getProtocol(), "//", "3.base.maps" + cm.getCIT() + ".api.heremaps.kr/maptile/2.1/maptile/34439348c3/normal.day/",
                    "/", level, "/", col, "/", row, "/", "256",
                    "/", "png", "?lg=", "FRE",
                    "&app_code=", APP_CODE_KOREA, "&app_id=",
                    APP_ID_KOREA].join("");

            else if (_scheme == "black")
                url = cm.getHome() + "png/black.png";
            else if (_scheme == "white")
                url = cm.getHome() + "png/white.png";
            else if (_scheme == "transparent")
                url = cm.getHome() + "png/transparent.png";


            if (settings.loadTile)
                settings.loadTile(level, col, row, url);

            return url;
        }


    });

    let __layer = new H.map.layer.TileLayer(_provider);

    //console.log("normal map");
    //Step 2: initialize a HEREMap 
    _map = new H.Map(document.getElementById(htmlItem),
        __layer, {
            center: coordA2O(settings.center),
            zoom: settings.zoom
        });

    let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(_map));

    // Create the default UI components
    _ui = H.ui.UI.createDefault(_map, _defaultLayers);

    // create default layer
    layerCreate("default");

    // if callback on zoom Change
    if (settings.viewChange) {
        _map.addEventListener("mapviewchangeend", function () {
            let bound = _map.getViewBounds();
            let lat = (bound.ka + bound.ja) / 2;
            let lng = (bound.ga + bound.ha) / 2;

            //console.log("viewChange center " + lat + " " + lng);
            settings.viewChange(_map.getZoom(), [lat, lng]);
        });
    }

    /***********************           to handle keyboard while mouse in map        ***********************/
    let kup = function () {
        _key.ctrl = false;
        _key.shift = false;
        _key.alt = false;
        _key.key = "";
    };

    let kdown = function (e) {
        _key.ctrl = ((e.key == "Control") || (e.keyIdentifier == "Control") || (e.ctrlKey == true));
        _key.shift = ((e.key == "Shift") || (e.keyIdentifier == "Shift") || (e.shiftKey == true));
        _key.alt = ((e.key == "Alt") || (e.keyIdentifier == "Alt") || (e.shiftKey == true));
        _key.key = e.key;
        if (settings.keyDown) settings.keyDown(_key);
    };

    _map.addEventListener("mouseenter", function () {
        // console.log("map mouse enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });

    _map.addEventListener("pointerenter", function () {
        //console.log("map pointer enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });
    _map.addEventListener("mouseleave", function () {
        // console.log("map mouse leave");
        document.removeEventListener("keydown", kdown);
        document.removeEventListener("keyup", kup);
    });

    /***********************           to handle double click         ***********************/
    _map.addEventListener("dbltap", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) return; // don't do anything if click on marker

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;
        if (settings.dbClick != "") {
            switch (button) {
                case 0: settings.dbClick(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.dbClick(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /***********************           to handle simple click         ***********************/
    _map.addEventListener("tap", function (ev) {
        let target = ev.target;

        if (target instanceof H.map.Marker) return;

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;

        if ((button == 0) && (settings.clickLeft))
            settings.clickLeft(coordO2A(coord), "left", _key);
        if ((button == 2) && (settings.clickRight))
            settings.clickRight(coordO2A(coord), "right", _key);
        if (settings.click != "") {
            switch (button) {
                case 0: settings.click(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.click(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /*********  disable the default draggability of the underlying map when starting to drag a marker object *****************/
    _map.addEventListener("dragstart", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) {
            behavior.disable();
        }
    }, false);

    /************   re - enable the default draggability of the underlying map when dragging has completed ***********************/
    _map.addEventListener("dragend", function (ev) {
        let target = ev.target;
        if (target instanceof mapsjs.map.Marker) {
            behavior.enable();
            if (typeof target.dragged !== "undefined") {
                let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
                (target.dragged)(target, coordO2A(coord));
            }
        }
    }, false);

    /***********************  Listen to the drag event and move the position of the marker as necessary *******************/
    _map.addEventListener("drag", function (ev) {
        let target = ev.target,
            pointer = ev.currentPointer;
        if (target instanceof mapsjs.map.Marker) {
            target.setPosition(_map.screenToGeo(pointer.viewportX, pointer.viewportY));
        }
    }, false);


    /****************  detect map resize and adjust accoridngly ******************************/
    window.addEventListener("resize", function () {
        _map.getViewPort().resize();

    });
}

/**
 * list of all available map styles normal.day, night.... 
 * @alias hm:getAvailableMapStyle
 * @return {json} list of map styles as json
 */
function getAvailableMapStyle() {
    // https://1.base.maps.api.here.com/maptile/2.1/info?xnlp=CL_JSMv3.0.17.0&app_id=nOSh21214JFMSEPQkqno&app_code=rX_l7YvALtNkqU2bx5FWEA&output=json

    const settings = cm.addCredentials({
        output: "json"
    });

    const url = cm.buildUrl("1.base.maps", "api.here.com/maptile/2.1/info");
    return cm.hereRest(url, settings)
        .then(res => {
            return res.body.response;
        });
}

/**
 * define the scheme. List of scheme can be obtained from {hm.getAvailableMapStyle()}
 * @alias hm:setScheme
 * @param {string} scheme scheme name
 */
function setScheme(scheme) {
    _scheme = scheme;
}

/**
 * create a layer
 * @alias hm:layerCreate
 * @param {string} name  - name of layer
 * @param {boolean} visible  - initial status
 * @example
 * ```js
 * hm.layerCreate("layer1");
 *  ```
 */
function layerCreate(name, visible) {
    group = new H.map.Group();
    group.name = name;
    _map.addObject(group);

    // push into list of layers
    _layers.push(group);

    // can be visible or hidden
    if (typeof visible != "undefined")
        group.setVisibility(visible);

    return group;
}

/**
 * delete a layer
 * @alias hm:layerDelete
 * @param {String} name name of layer
 */
function layerDelete(name) {
    let layer = layerFind(name);
    if (!layer)
        return;

    layer.name = null;
    _map.removeObject(layer);
}

/**
 * Empty a layer, actually deletes it and recreate it
 * @alias hm:layerEmpty
 * @param {string} layer 
 */
function layerEmpty(name) {
    layerDelete(name);
    layerCreate(name);
}


/**
 * find layer by its name or return null 
 * @alias hm:layerFind
 * @param {string} name 
 */
function layerFind(name) {
    let l = _layers.find(layer => {
        return layer.name == name;
    });
    if (typeof l == "undefined") return null;
    return l;
}


/**
 * set center of the map
* @alias hm:setCenter
 * @param {Array} - coord as [lat,lng]
 * * @example
 * ```js
 * hm.setCenter([48.8,2.3]);
 *  ```
 */
function setCenter(coord) {
    _map.setCenter(coordA2O(coord));
}

/**
 * return coordinate of the center of the map
 * @alias hm:getCenter
 * @returns {coord} coord of the center as \[lat,lng\]
 */
function getCenter() {
    let bound = _map.getViewBounds();
    //_HM.log("viewbound",bound);

    let lng = (bound.ga + bound.ha) / 2;
    let lat = (bound.ka + bound.ja) / 2;
    return [lat, lng];

}

/**
 * return bounding box of visible part of map
 * @alias hm:getViewBB
 * @returns {Object} bouding box of visible part of the map, as \[latm,latM,longm,lngM\]
 */
function getViewBB() {
    let bb = _map.getViewBounds();

    let bb2 = {
        latm: bb.ja,
        latM: bb.ka,
        lngm: bb.ga,
        lngM: bb.ha
    };
    return bb2;
}

/**
 * sets bouding box to be displayed
 * @alias hm:setViewBB
 * @param opt {Object| string}  either an object specifying how to set bounding box, or  a String being the name of a layer
 * @param [opt.layer] {string} bouding box aroud all objects of the layer
 * @param [opt.pois] {array} bouding box aroud all coords defined as \[coord,coord...\]
 * @example
 * ```js
  * hm.setViewBB("layer1");
 *
 * hm.setViewBB({
    *    pois: coords
    * });
 *  ```
 */
function setViewBB(opt) {

    if (typeof opt == "string")
        opt = { layer: opt };

    let settings = {
        layer: null,
        pois: null // array of [lat,lng]
    };
    Object.assign(settings, opt);

    let bbox;

    //set BB based on layer
    if (settings.layer) {
        let layer = layerFind(settings.layer);
        if (!layer) return;

        // get view bound and add a bit around, like 1/5
        let bb = layer.getBounds();
        if (!bb) // as if nothing in layer
            return;
        bb.latm = bb.ja;
        bb.latM = bb.ka;
        bb.lngm = bb.ga;
        bb.lngM = bb.ha;
        let dx = bb.lngM - bb.lngm;
        let dy = bb.latM - bb.latm;
        dx = dx / 5;
        dy = dy / 5;
        bb.latM += dy;
        bb.lngm -= dx;
        bb.latm -= dy;
        bb.lngM += dx;
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);

    }

    else if (settings.pois) {
        let bb = {
            latM: 0,
            lngm: 180,
            latm: 90,
            lngM: -180,
        };
        let arr = settings.pois;
        arr.forEach((poi) => {
            if (poi[0] > bb.latM) bb.latM = poi[0];
            if (poi[1] > bb.lngM) bb.lngM = poi[1];
            if (poi[0] < bb.latm) bb.latm = poi[0];
            if (poi[1] < bb.lngm) bb.lngm = poi[1];
        });
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);
    }
}


/**
 * return zoom value
 * @alias hm:getZoom
 * @returns {number} zoom level
 */
function getZoom() {
    return _map.getZoom();
}

/**
 * set zoom level
 * @alias heremap:setZoom
 * @param {number} zoom 
 */
function setZoom(zoom) {
    _map.setZoom(zoom);
}



/**
 * create an icon, to be used for a marker
 * @async
 * @alias hm:buildIcon
 * @param opt {object} options to specify the icon
 * @param [opt.img] {string}  use a png/jpg image. Specify the url 
 * @param [opt.svg] {string}  url a svg. This can be an inline svg, a url, or a svg from heremap
 * @param [opt.opt] {object}   style object
 * @param [opt.opt.size] {number|string}   size of icon, as 24 or 24x32
 * @param [opt.opt.anchor] {number|string}   anchor of icon, as 24 or 24x32. By default, bottom-center
 * @param [opt.opt.tag] {string}   for svg, any tag like{tag}. will be replaced by associated value
 * @return {H.map.Icon} the created icon
 * @example 
 * ```js
 * hm.buildIcon({
 *    img: "http://whatever.com/image.png",
 *    opt: {size:24}
 * });
 * 
 * hm.buildIcon({
 *    svg: "http://whatever.com/image.svg",
 *    opt: {
 *       size:24,
 *       anchor:24x32
 *    }
 * });
 *  
 * hm.buildIcon({
 *    svg: "svg/cluster.svg",
 *    opt: {
 *       size:24,
 *       color:"red"
 *    }
 * });
 * 
 * const svg = `<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"> <ellipse stroke="null" ry="8" rx="7.618896" id="svg_1" cy="8" cx="7.837427" fill="{color}" fill-opacity="0.9"/></svg>`;
 * hm.buildIcon({
 *    svg: svg,
 *    opt: {
 *       size:24,
 *       color:"red"
 *    } 
 * });
 *  ```
 */
async function buildIcon(opt) {
    let settings = {
        img: null,             //   png, jpg. if not http in the beginning, look locally
        svg: null,             // svg file:  is a url or a string
        opt: null,              // size, color, anchor, text...s
    };

    Object.assign(settings, opt);

    if (!settings.img && !settings.svg) {
        return null;
    }

    let icon, iconSrc;

    if (settings.img) {
        // console.log("settings.img", settings.img);

        if (settings.img.substr(0, 4) == "http") // url
            iconSrc = settings.img;
        else
            iconSrc = cm.getProtocol() + settings.img; // local file

    }
    else if (settings.svg) {

        let url = null;
        iconSrc = settings.svg;
        if (settings.svg.substr(0, 4) == "http") // url
            url = settings.svg;
        else if (settings.svg.substr(0, 4) == "<svg") // url
            url = null;
        else
            url = cm.getHome() + settings.svg; //missing protocol, not an embedded string, look in local heremap module

        if (url) // an url to download
            iconSrc = await fetch(url)
                .then(res => {
                    if (res.status != 200)
                        return null;
                    return res.text();
                });
    }

    let iconOpt = { crossOrigin: true }; // to avoid issued with capture
    if (settings.opt && settings.opt.size) {
        let w, h;
        if (typeof settings.opt.size == "number")
            w = h = settings.opt.size;
        else
            [w, h] = settings.opt.size.split("x");

        iconOpt.size = { w: w, h: h };
    }

    if (settings.opt && settings.opt.anchor) {
        let w, h;
        if (typeof settings.opt.anchor == "number")
            w = h = settings.opt.anchor;
        else
            [w, h] = settings.opt.anchor.split("x");
        iconOpt.anchor = new H.math.Point(w, h);
    }

    // all other fields are treated as graphic enhanceent
    if (settings.opt) {
        for (let name in settings.opt) {
            if (name == "file" || name == "size" || name == "anchor") continue;
            let re = new RegExp("{" + name + "}", "g");
            iconSrc = iconSrc.replace(re, settings.opt[name]);
        }
    }

    // console.log("iconSrc", iconSrc);
    // console.log("iconOpt", iconOpt);
    icon = new H.map.Icon(iconSrc, iconOpt);

    return icon;

} //end of icon





/**
 * add a marker in a layer
 * svg files can be created with https://editor.method.ac/ 
 * @async
 * @alias hm:marker
 * @param opt {object} options to create the marker
 * @param [opt.layer] {string}   layer name
 * @param [opt.coord] {coord}   coord of the marker as \[lat,lng\]
 * @param [opt.icon] {string}   created from hm.buildIcon
 * @param [opt.svg] {string}   see hm.buildIcon
 * @param [opt.opt] {Object}   see hm.buildIcon
 * @param {function} opt.pointerenter  if enter, callback(target,coord,ev)
 * @param {function} opt.pointerClick  if click, callback(target,coord,ev)
 * @param {string} opt.data  optional data
 * @param {boolean} opt.bubble  if true, show buble on click with data
 * @param {boolean} opt.draggable  draggable marker
 * @param {function} opt.dragged  if dragged, callback(target,coord)
 * @example 
 * ```js
 * hm.marker({
 *    coord: [48.8,2.3],
 * });
 * 
 * hm.marker({
    *   svg: "svg/marker.svg",
    *   color:"red",
    *   size:16
    * });
    * 
 * hm.marker({
 *    img: "http://whatever.com/image.png",
 *    coord: [48.8,2.3]
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    data:"Hello world",
 *    bubble: true
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    draggable:true,
 *    dragged: function(target,coord) {console.log("dragged to",coord);}
 * });
*  ```
 */
async function marker(opt) {
    let settings = {
        layer: "default",       //  layer in which to add marker
        coord: null,            //  coord of the marker
        img: null,             //  image can be url, png, jpg..
        svg: null,             // svg file
        icon: null,              // icon previously created
        opt: {},               // opt for icon
        pointerEnter: null,     //  callback(target,coord,ev)
        pointerClick: null,     //  callback(target,coord,ev)
        data: null,             //  user data
        bubble: false,          //  show a bubble with user data
        draggable: false,       //  icon is draggalbe
        dragged: null           //  callback(target,coord)
    };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    settings.coord = { lat: settings.coord[0], lng: settings.coord[1] };

    // these parameters can be in opt.opt or directly in opt
    if (settings.color) settings.opt.color = settings.color;
    if (settings.size) settings.opt.size = settings.size;
    if (settings.anchor) settings.opt.size = settings.anchor;

    let markerOpt = null;
    if (settings.img || settings.svg) {
        let icon = await buildIcon(settings);
        markerOpt = { icon: icon };
    }
    else if (settings.icon) {
        markerOpt = { icon: settings.icon };
    }

    //console.log("marker settings.coord", settings.coord);
    let marker = new H.map.Marker(settings.coord, markerOpt);

    marker.draggable = settings.draggable;

    if (settings.dragged) marker.dragged = settings.dragged;

    if (settings.data)
        marker.setData(settings.data);

    // get click from mouse
    if (settings.pointerEnter) {
        marker.addEventListener("pointerenter", function (ev) {

            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.pointerClick) {
        marker.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);

        });
    }

    /************  show a bubble when clicking on marker *****************************/
    if (settings.bubble) {
        marker.addEventListener("tap", function (ev) {

            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);

            bubbleUnique(coordO2A(coord), data);
        });
    }

    layer.addObject(marker);
    return marker;

} //end of marker

/**
 * display a unique bubble. Associated CSS style is .H_ib_body
 * @alias hm:bubbleUnique
 * @param {Array} coord of the bubble
 * @param {String} txt html text to display
 */
function bubbleUnique(coord, txt) {

    if (!_bubbleMarker) {
        _bubbleMarker = new H.ui.InfoBubble(
            coordA2O(coord), {
                content: txt
            });

        _ui.addBubble(_bubbleMarker);
        _bubbleMarker.addClass("bubbleUnique");

    } else {
        _bubbleMarker.setPosition(coordA2O(coord));
        _bubbleMarker.setContent(txt);
        _bubbleMarker.open();
    }

}


/**
 * hide a unique bubble
 * @alias hm:bubbleUniqueHide
 */
function bubbleUniqueHide() {
    if (!_bubbleMarker)
        return;
    _bubbleMarker.close();
}




/**
 * Draw a polyline. 
 * @alias hm:polyline
 * @param opt {object}   options to draw polyline
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coords] {array} array of coords, as \[\[48.8,2.3\],\[48.85,2.4\],... \]
 * @param [opt.style] {object} optional graphic style
 * @param [opt.lineWidth=4] {number} line width
 * @param [opt.style.strokeColor=rgba(0, 128, 255, 0.7)] {string} line color
 * @param [opt.arrows] {object} optional arrow
 * @param [opt.data] {String} optional user data
 * @param [opt.pointerClick] {function} optional callback if click on line. format callback(target,coord,event)
 * @param [opt.pointerenter] {function} optional callback if mouse enters on line. format callback(target,coord,event)
 * @param [opt.pointerLeave] {function} optional callback if mouse leaves the line. format callback(target,coord,event)
 * @param [opt.z] {number} optional z level
* ```js
* hm.polyline({
    *    coords: [[48.8,2.3],[48.85,2.4],[48.9,2.6]],
    *    layer:"layer1"
    * });
    * 
    * hm.polyline({
    *    coords: coords,
    *    style: {
    *        lineWidth: 4,
    *        strokeColor: "red"
    *    },
    * });
    * 
    * hm.polyline({
        *    coords: coords,
        *    data:"Hello World",
        * });
    *  ```
 */
function polyline(opt) {
    let settings = {
        layer: "default",
        coords: null, // coords is list of array of [lat,lng] or array of object with {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)"
        },
        arrows: null,
        data: null,         // optional user data 
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();

    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polyline = new H.map.Polyline(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    // Z index
    if (settings.z) polyline.setZIndex(settings.z);
    // user data
    if (settings.data) polyline.setData(settings.data);

    if (settings.pointerEnter)
        polyline.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);
        });
    if (settings.pointerLeave)
        polyline.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev);
        });
    if (settings.pointerClick)
        polyline.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);
        });

    layer.addObject(polyline);

    return polyline;
}


/**
 * Draw a polygon
 * @alias hm:polygon
 * @param {Object} opt  options to draw a polygon. Same options as hm.polyline
 */
function polygon(opt) {
    let settings = {
        layer: "default",
        coords: "", // coords is array of [lat,lng] or array of {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)",
            fillColor: "rgba(0, 128, 255, 0.7)"
        },
        styleHover: null, // style si mouse over
        arrows: null,
        data: null, // additional data to carry
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();
    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polygon = new H.map.Polygon(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    if (settings.data) polygon.setData(settings.data);
    // Z index
    if (settings.z) polyline.setZIndex(settings.z);

    // si un style de hover
    if (settings.styleHover) {
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            target.setStyle(settings.styleHover);
        });
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            target.setStyle(settings.style);
        });
    }

    if (settings.pointerEnter)
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerLeave)
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerClick)
        polygon.addEventListener("tap", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev, data);
        });

    layer.addObject(polygon);

    return polygon;
} // end of polygon

/**
 * draw a circle
 * @alias hm:circle
 * @param opt {*}   option for circle
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coord] {array} center of the circle, as \[48.8,2.3\]
 * @param [opt.radius] {number} radius in meter
 * @param [opt.style] {object} optional graphic style
 * @param [opt.style.strokeColor] {string} color of perimeter
 * @param [opt.style.lineWidth] {number} line width
 * @param [opt.style.fillColor] {string} fill color
 */
function circle(opt) {
    let settings = {
        layer: "default",
        coord: null,
        radius: 100, // meters
        style: {
            strokeColor: "rgba(55, 85, 170, 0.2)", // Color of the perimeter
            lineWidth: 2,
            fillColor: "rgba(0, 128, 0, 0.1)"  // Color of the circle
        }

    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }
    let circle = new H.map.Circle(
        // The central point of the circle
        coordA2O(settings.coord),
        // The radius of the circle in meters
        settings.radius,
        {
            style: settings.style
        }
    );

    layer.addObject(circle);
    return circle;
}




/**
 * watch position on HTML5 position. requires HTTPS
 * @async
 * @alias hm:locateMe
 * @param callback {function}  callback when coord changes. Format: callback(coord,accuracy) 
 * @param opt {Object} optional graphic options
 * @param [opt.position] {object}  graphic options for center. See buildIcon
 * @param [opt.position.svg] {string}  svg file
 * @param [opt.position.color] {string}  color for  {color} tag
 * @param [opt.position.size] {number}  size of icon
 * @param [opt.position.anchor] {number}  anchor of icon
 * @param [opt.accuracy] {object}  graphic options for accuracy representation
 * @param [opt.accuracy.strokeColor] {String}  color of circle line representing accuracy area
 * @param [opt.accuracy.lineWidth] {number}  width of line of circle
 * @param [opt.accuracy.fillColor] {String}  fill color of circle representing accuracy area
 */
async function locateMe(callback, opt) {

    // if no callback, remove the watch
    if (navigator.geolocation) {
        if (!callback && _locateMe) {
            navigator.geolocation.clearWatch(_locateMe);
            _locateMe = null;
            return;
        }

        let settings = {
            position: {
                svg: "svg/crosshair.svg",
                color: "black",
                size: 24,
                anchor: 12
            },
            accuracy: {
                strokeColor: "rgba(0, 128, 0, 0.8)", // Color of the perimeter
                lineWidth: 2,
                fillColor: "rgba(0, 128, 0, 0.4)"  // Color of the circle
            }
        };
        Object.assign(settings, opt);

        let iconCrossHair = await buildIcon({
            svg: settings.position.svg,
            img: settings.position.img,
            opt: settings.position
        });


        //navigator.geolocation.getCurrentPosition(function pos(position) {
        _locateMe = navigator.geolocation.watchPosition((position) => {
            let gps = [position.coords.latitude, position.coords.longitude];

            layerEmpty("_gps");

            /* circle showing the accuracy radius*/
            circle({
                layer: "_gps",
                coord: gps,
                radius: position.coords.accuracy,
                style: settings.accuracy
            });

            marker({
                layer: "_gps",
                coord: gps,
                icon: iconCrossHair
            });

            callback(gps, position.coords.accuracy);
        }, (error) => {
            let msg = "";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    msg += "timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    msg += "An unknown error occurred.";
                    break;
            }
            let e = new Error("HTML5 location error:" + msg); // e.message
            throw (e);
        }, {
                enableHighAccuracy: true
            }
        );
    }
    else {
        let e = new Error("no HTML5 geolocation capabilities"); // e.message
        throw (e);
    }
}


/**
 * perform a screenshot of the map and returns a promise with the data
 * @async
 * @alias hm:locateMe
 * @param opt {object} options for screenshot
 * @param [opt.name] {string} filename for download
 * @param [opt.ui] {boolean} true to save ui (scale, etc..)
 * @param opt {object} options for screenshot
 * 
 * @returns {data} binary data of image
 * 
 */
function screenshot(opt) {
    let para = null;
    if (opt && opt.ui)
        para = [_ui];

    return new Promise(
        (resolve, reject) => {
            _map.capture(function (canvas) {
                if (!canvas)
                    return reject("Map screenshot not supported");

                let dataURL = canvas.toDataURL();

                if (opt && opt.name) {
                    let a = document.createElement('a');
                    a.href = dataURL;
                    a.target = '_blank';
                    a.download = opt.name;
                    document.body.appendChild(a);
                    a.click();
                }
                resolve(dataURL);


            }, para);
        });
}


function getMap() {
    return _map;
}

function getUI() {
    return _ui;
}

module.exports = {
    coordO2A: coordO2A,
    coordA2O: coordA2O,
    getMap: getMap,
    getUI: getUI,
    map: map,
    getAvailableMapStyle: getAvailableMapStyle,
    setScheme: setScheme,
    layerCreate: layerCreate,
    layerFind: layerFind,
    layerDelete: layerDelete,
    layerEmpty: layerEmpty,
    buildIcon: buildIcon,
    bubbleUnique: bubbleUnique,
    bubbleUniqueHide: bubbleUniqueHide,
    marker: marker,
    circle: circle,
    polyline: polyline,
    polygon: polygon,
    getCenter: getCenter,
    setCenter: setCenter,
    getZoom: getZoom,
    setZoom: setZoom,
    getviewBB: getViewBB,
    setViewBB: setViewBB,
    locateMe: locateMe,
    screenshot: screenshot

};






},{"./common.js":10}],13:[function(require,module,exports){
"use strict";
const cm = require("./common.js");

/**
 * compute a route with optional waypooints. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 *  @async
 * @alias hm:route
 * @param {object} source - source as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param {object} dest - dest as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param opt {object} route options 
 * @param [opt.mode=fastest;car;traffic:disabled] {string}  routing mode
 * @param [opt.routeattributes=waypoints,summary,shape] {string}  route attributes
 * @param [opt.maneuverattributes=direction,action] {string}  manoeuver attributes
 * @returns {object} returns { summary: object, coords:array,route: object, body:object}. coords is array of coord, to be used with hm.polyline. 
 *
 * @example
  * ```js
  * const res = await hm.route([48.8,2.3],[48.7,2.5]);
  * console.log (res.summary);
  * 
  * const res = await hm.route([[48.8,2.3],[48.9,2.7]], [49.3,2.5]);
  * console.log (res.route); 
  * 
  * const res = await hm.route([48.8,2.3], [[48.9,2.7], [49.3,2.5]]);
  * console.log (res.summary); 
  * ```
 */
async function route(source, dest, opt) {

    const settings = {
        mode: "fastest;car;traffic:disabled",
        representation: "linkPaging",
        routeattributes: "waypoints,summary,shape",
        maneuverattributes: "direction,action"
    };

    const params = cm.addCredentials(settings, opt);

    // 1 seul source ou array de source ?
    let id = 0;
    if (Array.isArray(source[0]))
        for (var i = 0; i < source.length; i++) {
            let coord = source[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = source[0] + "," + source[1];

    if (Array.isArray(dest[0]))

        for (let i = 0; i < dest.length; i++) {
            let coord = dest[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = dest[0] + "," + dest[1];

    const url = cm.buildUrl("route", "api.here.com/routing/7.2/calculateroute.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            const route = res.body.response.route[0];
            const summary = route.summary;
            const coords = route.shape.map((latlng => latlng.split(",")));

            return { summary: summary, coords: coords, route: route, body: res.body };

        });

}


/**
 * compute an isoline. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * @async
 * @alias hm:isoline
 * @param opt {object} option for isoline
 * @param [opt.start] {coord} coord for starting point of isoline
 * @param [opt.destination] {coord} coord for destination point of isoline
 * @param [opt.rangeType="time"] {string} time or distance
 * @param [opt.range] {number} range in seconds or in meters
 * @param [opt.mode="fastest;car;traffic:disabled"] {String} routing mode
 * @param [opt.linkattributes=sh] {String} attributes to be returned
 * 
 * @returns {object}  returns { poly:array, body:object }. Poly is array of coords, body is full answer
 */
async function isoline(opt) {

    const settings = {
        start: null,                            // for direct isoline
        destination: null,                      // for reverse isoline
        rangeType: "time",                      // time or distance
        range: null,                            // in seconds or meters
        linkattributes: "sh",                   // to get the shape
        mode: "fastest;car;traffic:disabled",   //shortest;car;traffic:disabled 
    };
    const params = cm.addCredentials(settings, opt);

    if (params.start)
        params.start = "geo!" + params.start[0] + "," + params.start[1];
    if (params.destination)
        params.destination = "geo!" + params.destination[0] + "," + params.destination[1];

    if (!params.start && !params.destination) {
        let e = new Error("Isoline routing : missing start or destination"); // e.message
        throw (e);
    }
    if (!params.range) {
        let e = new Error("Isoline routing : missing range"); // e.message
        throw (e);
    }

    const url = cm.buildUrl("isoline.route", "api.here.com/routing/7.2/calculateisoline.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            // array of lat,lng, to be transformed into array of [lat,lng]
            const shape = res.body.response.isoline[0].component[0].shape;
            const poly = shape.map(point => point.split(","));

            return { poly: poly, body: res.body };
        });

}


/**
 * compute a matrix. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * 
 * Matrix size is limited to 1x100,100X1 or 15*N
 *  @async
 * @alias hm:matrix
 * @param source {object} source as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param dest {object} dest as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param opt {object} additional optional parameters like  mode, summaryAttributes
 * @param [opt.mode="fastest;car;traffic:enabled"] {string} routing mode to compute matrix
 * @param [opt.summaryAttributes="tt,di"] {string} attributes in the answer
 * 
 * @returns {object} { entries: object, body:object }. entries is the array of {start,stop} information. body is full json answer
 * @example
 * ```js
 * const res = await hm.matrix({
 *      source:[48.8,2.3]
 *      dest:[[48.7,2.5],[48.1,2.0],[44.2,2.3]]
 * });
 * console.log (res.entries); 
 * ```
 */

async function matrix(source, dest, opt) {

    var settings = {
        mode: "fastest;car;traffic:enabled",
        summaryAttributes: "tt,di"
    };
    const params = cm.addCredentials(settings, opt);

    if (!Array.isArray(source[0])) // if only one coord
        source = [source];
    source.forEach((coord, i) => {
        params["start" + i] = coord[0] + "," + coord[1];
    });

    if (!Array.isArray(dest[0])) // if only one coord
        dest = [dest];
    dest.forEach((coord, i) => {
        params["destination" + i] = coord[0] + "," + coord[1];
    });

    const url = cm.buildUrl("matrix.route", "api.here.com/routing/7.2/calculatematrix.json");
    return cm.hereRest(url, params, "post")
        .then(res => {
            return { entries: res.body.response.matrixEntry, body: res.body };
        });


}



/**
 * Compute the detour for each waypoint provided, compared to normal route from A to B
 * 
 * @async
 * @alias hm:detour
 * @param start {coord}  starting point for route
 * @param stop {coord}   destination point of route
 * @param waypoints {array}  list of watypoints to test 
 * @returns {object} returns {reference,waypoints:[ {coord,distA,timeA,distB,timeB}]}
 */
async function detour(start, stop, waypoints) {
    // eslint-disable-next-line   no-undef
    return new Promise(
        async (resolve, reject) => {
            //let tStart = new Date();

            if (!start) return reject("missing start point");
            if (!stop) return reject("missing stop point");
            if (!waypoints) return reject("missing waypoints");
            if (!Array.isArray) return reject("waypoints should be an array");


            // initialise le resultat 
            let res = {
                reference: {},
                waypoints: []
            };

            // calcul les coords nonPostGres, creer l'array de coord des waypoints.
            let dest = [stop]; // so we have a distance/time reference, not same as from routing 1:1
            waypoints.forEach(waypoint => {
                dest.push(waypoint);
                res.waypoints.push(
                    { coord: waypoint }
                );
            });
            // inspect(dest, "dest from detour")

            // compute start to all waypoint, 1st waypoint is stop to get a reference
            let p1 = matrix(start, dest, { mode: "fastest;car;traffic:disabled" });

            // compute from all waypoint to stop, 1st waypoint is start to get another reference
            dest[0] = start;
            let p2 = matrix(dest, stop, { mode: "fastest;car;traffic:disabled" });
            // wait for both matrix to complete

            // eslint-disable-next-line   no-undef
            const result = await Promise.all([p1, p2]);

            // process first part: start => N waypoints
            let entries = result[0].entries;
            // first entry is start stop
            let dist = entries[0].summary.distance;
            let time = entries[0].summary.travelTime;
            res.reference.start = start;
            res.reference.stop = stop;
            res.reference.distance = dist;
            res.reference.time = time; // the reference sans waypoint

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixA" + i);
                    //console.log(start, "associated start");
                    //console.log(dest[i], "associated dest" + i);
                    return;
                }

                let id = entry.destinationIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distA = dist;
                res.waypoints[id - 1].timeA = time;
            });


            // process second part: N waypoints => stop
            entries = result[1].entries;
            //inspect(entries[0], "matrixB0");

            res.reference.distance2 = entries[0].summary.distance;
            res.reference.time2 = entries[0].summary.travelTime;

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixB" + i);
                    //console.log(entry, "associated start" + i);
                    //console.log(stop, "associated stop");
                    return;
                }
                let id = entry.startIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distB = dist;
                res.waypoints[id - 1].timeB = time;
            });
            return resolve(res);
        });

}


module.exports = {
    matrix: matrix,
    route: route,
    isoline: isoline,
    detour: detour
};


},{"./common.js":10}],"heremap.js":[function(require,module,exports){
(function (process){
"use strict";

/*
 * @module HEREMAP
 * @typicalname hm
 */

let modules = {};
Object.assign(modules, require("./common.js"));
Object.assign(modules, require("./routing.js"));
Object.assign(modules, require("./geocoding.js"));

if (process.browser) {
    Object.assign(modules, require("./map.js"));
    Object.assign(modules, require("./cluster.js"));
}
// export all the above
module.exports = modules;

//console.log("module.exports", module.exports);
//console.log("process.browser", process.browser);
}).call(this,require('_process'))

},{"./cluster.js":9,"./common.js":10,"./geocoding.js":11,"./map.js":12,"./routing.js":13,"_process":1}]},{},[10,12,13,11,9])("heremap.js")
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXNwb25zZS1iYXNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsImNsdXN0ZXIuanMiLCJjb21tb24uanMiLCJnZW9jb2RpbmcuanMiLCJtYXAuanMiLCJyb3V0aW5nLmpzIiwiaGVyZW1hcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcInVzZVwiLCBcIm9uXCIsIFwib25jZVwiLCBcInNldFwiLCBcInF1ZXJ5XCIsIFwidHlwZVwiLCBcImFjY2VwdFwiLCBcImF1dGhcIiwgXCJ3aXRoQ3JlZGVudGlhbHNcIiwgXCJzb3J0UXVlcnlcIiwgXCJyZXRyeVwiLCBcIm9rXCIsIFwicmVkaXJlY3RzXCIsXG4gXCJ0aW1lb3V0XCIsIFwiYnVmZmVyXCIsIFwic2VyaWFsaXplXCIsIFwicGFyc2VcIiwgXCJjYVwiLCBcImtleVwiLCBcInBmeFwiLCBcImNlcnRcIl0uZm9yRWFjaChmbiA9PiB7XG4gIC8qKiBEZWZhdWx0IHNldHRpbmcgZm9yIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgYWdlbnQgKi9cbiAgQWdlbnQucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbiwgYXJnc30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZGVmID0+IHtcbiAgICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgZGVmLmFyZ3MpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxubGV0IHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuY29uc3QgUmVxdWVzdEJhc2UgPSByZXF1aXJlKCcuL3JlcXVlc3QtYmFzZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuY29uc3QgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vYWdlbnQtYmFzZScpO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe307XG5cbi8qKlxuICogRXhwb3NlIGByZXF1ZXN0YC5cbiAqL1xuXG5jb25zdCByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn07XG5cbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lIFhIUi5cbiAqL1xuXG5yZXF1ZXN0LmdldFhIUiA9ICgpID0+IHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3RcbiAgICAgICYmICghcm9vdC5sb2NhdGlvbiB8fCAnZmlsZTonICE9IHJvb3QubG9jYXRpb24ucHJvdG9jb2xcbiAgICAgICAgICB8fCAhcm9vdC5BY3RpdmVYT2JqZWN0KSkge1xuICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC42LjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgfVxuICB0aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IHRyaW0gPSAnJy50cmltXG4gID8gcyA9PiBzLnRyaW0oKVxuICA6IHMgPT4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShvYmopIHtcbiAgaWYgKCFpc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICBjb25zdCBwYWlycyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2godiA9PiB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBmb3IoY29uc3Qgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywgYCR7a2V5fVske3N1YmtleX1dYCwgdmFsW3N1YmtleV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZU9iamVjdCA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gICogUGFyc2UgdGhlIGdpdmVuIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBgc3RyYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3QgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgbGV0IHBhaXI7XG4gIGxldCBwb3M7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pO1xuICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgbGV0IGluZGV4O1xuICBsZXQgbGluZTtcbiAgbGV0IGZpZWxkO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIGxldCBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgbGV0IHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCByZXEgPSB0aGlzLnJlcTtcbiAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZDtcbiAgY29uc3QgdXJsID0gcmVxLnVybDtcblxuICBjb25zdCBtc2cgPSBgY2Fubm90ICR7bWV0aG9kfSAke3VybH0gKCR7dGhpcy5zdGF0dXN9KWA7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSBtZXRob2Q7XG4gIGVyci51cmwgPSB1cmw7XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBSZXNwb25zZWAuXG4gKi9cblxucmVxdWVzdC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlcXVlc3RgIHdpdGggdGhlIGdpdmVuIGBtZXRob2RgIGFuZCBgdXJsYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgbGV0IG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZXIgPSBzdHJpbmcgPT4ge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgY29uc3QgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1JlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy4nKTtcbiAgZXJyLmNyb3NzRG9tYWluID0gdHJ1ZTtcblxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gIGVyci5tZXRob2QgPSB0aGlzLm1ldGhvZDtcbiAgZXJyLnVybCA9IHRoaXMudXJsO1xuXG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cbi8vIFRoaXMgb25seSB3YXJucywgYmVjYXVzZSB0aGUgcmVxdWVzdCBpcyBzdGlsbCBsaWtlbHkgdG8gd29ya1xuUmVxdWVzdC5wcm90b3R5cGUuYnVmZmVyID0gUmVxdWVzdC5wcm90b3R5cGUuY2EgPSBSZXF1ZXN0LnByb3RvdHlwZS5hZ2VudCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnNvbGUud2FybihcIlRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyIHZlcnNpb24gb2Ygc3VwZXJhZ2VudFwiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGlzIHRocm93cywgYmVjYXVzZSBpdCBjYW4ndCBzZW5kL3JlY2VpdmUgZGF0YSBhcyBleHBlY3RlZFxuUmVxdWVzdC5wcm90b3R5cGUucGlwZSA9IFJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gKCkgPT4ge1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHJldHVybiB0aGlzLmNhbGxiYWNrKEVycm9yKFwiVGhlIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBldmVuIGJlZm9yZSAuZW5kKCkgd2FzIGNhbGxlZFwiKSk7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICBsZXQgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPj0gMiAmJiBzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgaWYgKDQgIT0gcmVhZHlTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluIElFOSwgcmVhZHMgdG8gYW55IHByb3BlcnR5IChlLmcuIHN0YXR1cykgb2ZmIG9mIGFuIGFib3J0ZWQgWEhSIHdpbGxcbiAgICAvLyByZXN1bHQgaW4gdGhlIGVycm9yIFwiQ291bGQgbm90IGNvbXBsZXRlIHRoZSBvcGVyYXRpb24gZHVlIHRvIGVycm9yIGMwMGMwMjNmXCJcbiAgICBsZXQgc3RhdHVzO1xuICAgIHRyeSB7IHN0YXR1cyA9IHhoci5zdGF0dXMgfSBjYXRjaChlKSB7IHN0YXR1cyA9IDA7IH1cblxuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICBpZiAoc2VsZi50aW1lZG91dCB8fCBzZWxmLl9hYm9ydGVkKSByZXR1cm47XG4gICAgICByZXR1cm4gc2VsZi5jcm9zc0RvbWFpbkVycm9yKCk7XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gIH07XG5cbiAgLy8gcHJvZ3Jlc3NcbiAgY29uc3QgaGFuZGxlUHJvZ3Jlc3MgPSAoZGlyZWN0aW9uLCBlKSA9PiB7XG4gICAgaWYgKGUudG90YWwgPiAwKSB7XG4gICAgICBlLnBlcmNlbnQgPSBlLmxvYWRlZCAvIGUudG90YWwgKiAxMDA7XG4gICAgfVxuICAgIGUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHNlbGYuZW1pdCgncHJvZ3Jlc3MnLCBlKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKCdwcm9ncmVzcycpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHhoci5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAnZG93bmxvYWQnKTtcbiAgICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ3VwbG9hZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgLy8gQWNjZXNzaW5nIHhoci51cGxvYWQgZmFpbHMgaW4gSUUgZnJvbSBhIHdlYiB3b3JrZXIsIHNvIGp1c3QgcHJldGVuZCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gUmVwb3J0ZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvODM3MjQ1L3htbGh0dHByZXF1ZXN0LXVwbG9hZC10aHJvd3MtaW52YWxpZC1hcmd1bWVudC13aGVuLXVzZWQtZnJvbS13ZWItd29ya2VyLWNvbnRleHRcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWF0ZSByZXF1ZXN0XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCkge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlLCB0aGlzLnVzZXJuYW1lLCB0aGlzLnBhc3N3b3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJsLCB0cnVlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHNlZSAjMTE0OVxuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycik7XG4gIH1cblxuICAvLyBDT1JTXG4gIGlmICh0aGlzLl93aXRoQ3JlZGVudGlhbHMpIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXG4gIC8vIGJvZHlcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSAmJiAnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIC8vIHNlcmlhbGl6ZSBzdHVmZlxuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBsZXQgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAoY29uc3QgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbn07XG5cbnJlcXVlc3QuYWdlbnQgPSAoKSA9PiBuZXcgQWdlbnQoKTtcblxuW1wiR0VUXCIsIFwiUE9TVFwiLCBcIk9QVElPTlNcIiwgXCJQQVRDSFwiLCBcIlBVVFwiLCBcIkRFTEVURVwiXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgY29uc3QgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdERUxFVEUnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn1cblxucmVxdWVzdFsnZGVsJ10gPSBkZWw7XG5yZXF1ZXN0WydkZWxldGUnXSA9IGRlbDtcblxuLyoqXG4gKiBQQVRDSCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wYXRjaCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BBVENIJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBPU1QgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucG9zdCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BPU1QnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUFVUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnB1dCA9ICh1cmwsIGRhdGEsIGZuKSA9PiB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ1BVVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gbnVsbCAhPT0gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBvZiBtaXhlZC1pbiBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gbm9kZSBhbmQgY2xpZW50IGNvZGVcbiAqL1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgc3dpdGNoKG9wdGlvbikge1xuICAgICAgY2FzZSAnZGVhZGxpbmUnOlxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXNwb25zZSc6XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLCBvcHRpb24pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IG51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBvbiBlcnJvci5cbiAqXG4gKiBGYWlsZWQgcmVxdWVzdHMgd2lsbCBiZSByZXRyaWVkICdjb3VudCcgdGltZXMgaWYgdGltZW91dCBvciBlcnIuY29kZSA+PSA1MDAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24gcmV0cnkoY291bnQsIGZuKXtcbiAgLy8gRGVmYXVsdCB0byAxIGlmIG5vIGNvdW50IHBhc3NlZCBvciB0cnVlXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSB0cnVlKSBjb3VudCA9IDE7XG4gIGlmIChjb3VudCA8PSAwKSBjb3VudCA9IDA7XG4gIHRoaXMuX21heFJldHJpZXMgPSBjb3VudDtcbiAgdGhpcy5fcmV0cmllcyA9IDA7XG4gIHRoaXMuX3JldHJ5Q2FsbGJhY2sgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5jb25zdCBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbGZpbGxlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkgPT4ge1xuICAgICAgc2VsZi5vbignZXJyb3InLCBpbm5lclJlamVjdCk7XG4gICAgICBzZWxmLmVuZCgoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZCkge1xuICAgICAgdGhpcy5zZXQoa2V5LCBmaWVsZFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gdmFsO1xuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAudW5zZXQoJ1VzZXItQWdlbnQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIGRlbGV0ZSB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG4gIGRlbGV0ZSB0aGlzLmhlYWRlcltmaWVsZF07XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdFxuICogZm9yIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHJlcXVlc3QgYm9kaWVzLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKCdmb28nLCAnYmFyJylcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmZpZWxkKHsgZm9vOiAnYmFyJywgYmF6OiAncXV4JyB9KVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd8QmxvYnxGaWxlfEJ1ZmZlcnxmcy5SZWFkU3RyZWFtfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gIC8vIG5hbWUgc2hvdWxkIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gIGlmIChudWxsID09PSBuYW1lIHx8IHVuZGVmaW5lZCA9PT0gbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAoY29uc3QgaSBpbiB2YWwpIHtcbiAgICAgIHRoaXMuZmllbGQobmFtZSwgdmFsW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB2YWwgc2hvdWxkIGJlIGRlZmluZWQgbm93XG4gIGlmIChudWxsID09PSB2YWwgfHwgdW5kZWZpbmVkID09PSB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIHZhbCBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gIH1cbiAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbCkge1xuICAgIHZhbCA9ICcnICsgdmFsO1xuICB9XG4gIHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKG5hbWUsIHZhbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBYm9ydCB0aGUgcmVxdWVzdCwgYW5kIGNsZWFyIHBvdGVudGlhbCB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xuICB0aGlzLnhociAmJiB0aGlzLnhoci5hYm9ydCgpOyAvLyBicm93c2VyXG4gIHRoaXMucmVxICYmIHRoaXMucmVxLmFib3J0KCk7IC8vIG5vZGVcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgdGhpcy5lbWl0KCdhYm9ydCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGJhc2U2NEVuY29kZXIpIHtcbiAgc3dpdGNoIChvcHRpb25zLnR5cGUpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2Jhc2U2NEVuY29kZXIoYCR7dXNlcn06JHtwYXNzfWApfWApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdXRvJzpcbiAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VyO1xuICAgICAgdGhpcy5wYXNzd29yZCA9IHBhc3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlYXJlcic6IC8vIHVzYWdlIHdvdWxkIGJlIC5hdXRoKGFjY2Vzc1Rva2VuLCB7IHR5cGU6ICdiZWFyZXInIH0pXG4gICAgICB0aGlzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHt1c2VyfWApO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxuICpcbiAqIE5vdGUgdGhhdCBmb3IgdGhpcyB0byB3b3JrIHRoZSBvcmlnaW4gbXVzdCBub3QgYmVcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxuICogYW5kIGFsc28gbXVzdCBzZXQgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gKiB0byBcInRydWVcIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihvbikge1xuICAvLyBUaGlzIGlzIGJyb3dzZXItb25seSBmdW5jdGlvbmFsaXR5LiBOb2RlIHNpZGUgaXMgbm8tb3AuXG4gIGlmIChvbiA9PSB1bmRlZmluZWQpIG9uID0gdHJ1ZTtcbiAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heCByZWRpcmVjdHMgdG8gYG5gLiBEb2VzIG5vdGluZyBpbiBicm93c2VyIFhIUiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZWRpcmVjdHMgPSBmdW5jdGlvbihuKXtcbiAgdGhpcy5fbWF4UmVkaXJlY3RzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1heGltdW0gc2l6ZSBvZiBidWZmZXJlZCByZXNwb25zZSBib2R5LCBpbiBieXRlcy4gQ291bnRzIHVuY29tcHJlc3NlZCBzaXplLlxuICogRGVmYXVsdCAyMDBNQi5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5tYXhSZXNwb25zZVNpemUgPSBmdW5jdGlvbihuKXtcbiAgaWYgKCdudW1iZXInICE9PSB0eXBlb2Ygbikge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gIH1cbiAgdGhpcy5fbWF4UmVzcG9uc2VTaXplID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCAobm90IEpTT04gc3RyaW5nKSBvZiBzY2FsYXIgcHJvcGVydGllcy5cbiAqIE5vdGUgYXMgdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gcmV0dXJuIGEgdXNlZnVsIG5vbi10aGlzIHZhbHVlLFxuICogaXQgY2Fubm90IGJlIGNoYWluZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZXNjcmliaW5nIG1ldGhvZCwgdXJsLCBhbmQgZGF0YSBvZiB0aGlzIHJlcXVlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgdXJsOiB0aGlzLnVybCxcbiAgICBkYXRhOiB0aGlzLl9kYXRhLFxuICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcixcbiAgfTtcbn07XG5cbi8qKlxuICogU2VuZCBgZGF0YWAgYXMgdGhlIHJlcXVlc3QgYm9keSwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cbiAqIGFuIG9iamVjdCBpcyBnaXZlbi5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBtYW51YWwganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdqc29uJylcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9JylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcbiAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKXtcbiAgY29uc3QgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgbGV0IHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICB0aGlzLl9kYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgfVxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgLy8gZGVmYXVsdCB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xuICAgIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XG4gICAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YVxuICAgICAgICA/IGAke3RoaXMuX2RhdGF9JiR7ZGF0YX1gXG4gICAgICAgIDogZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhIHx8ICcnKSArIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgaWYgKCFpc09iaiB8fCB0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdG8ganNvblxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU29ydCBgcXVlcnlzdHJpbmdgIGJ5IHRoZSBzb3J0IGZ1bmN0aW9uXG4gKlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIGRlZmF1bHQgb3JkZXJcbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KClcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemVkIHNvcnQgZnVuY3Rpb25cbiAqICAgICAgIHJlcXVlc3QuZ2V0KCcvdXNlcicpXG4gKiAgICAgICAgIC5xdWVyeSgnbmFtZT1OaWNrJylcbiAqICAgICAgICAgLnF1ZXJ5KCdzZWFyY2g9TWFubnknKVxuICogICAgICAgICAuc29ydFF1ZXJ5KGZ1bmN0aW9uKGEsIGIpe1xuICogICAgICAgICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICogICAgICAgICB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzb3J0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNvcnRRdWVyeSA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgLy8gX3NvcnQgZGVmYXVsdCB0byB0cnVlIGJ1dCBvdGhlcndpc2UgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYm9vbGVhblxuICB0aGlzLl9zb3J0ID0gdHlwZW9mIHNvcnQgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IHNvcnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wb3NlIHF1ZXJ5c3RyaW5nIHRvIGFwcGVuZCB0byByZXEudXJsXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fZmluYWxpemVRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IHF1ZXJ5QXJyID0gdGhpcy51cmwuc3Vic3RyaW5nKGluZGV4ICsgMSkuc3BsaXQoJyYnKTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fc29ydCkge1xuICAgICAgICBxdWVyeUFyci5zb3J0KHRoaXMuX3NvcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCgpO1xuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgJz8nICsgcXVlcnlBcnIuam9pbignJicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQgb25seVxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hcHBlbmRRdWVyeVN0cmluZyA9ICgpID0+IHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke3JlYXNvbiArIHRpbWVvdXR9bXMgZXhjZWVkZWRgKTtcbiAgZXJyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICBlcnIuY29kZSA9ICdFQ09OTkFCT1JURUQnO1xuICBlcnIuZXJybm8gPSBlcnJubztcbiAgdGhpcy50aW1lZG91dCA9IHRydWU7XG4gIHRoaXMuYWJvcnQoKTtcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zZXRUaW1lb3V0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdSZXNwb25zZSB0aW1lb3V0IG9mICcsIHNlbGYuX3Jlc3BvbnNlVGltZW91dCwgJ0VUSU1FRE9VVCcpO1xuICAgIH0sIHRoaXMuX3Jlc3BvbnNlVGltZW91dCk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIGNvbnN0IGN0ID0gaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcbiAgICB0aGlzLnR5cGUgPSB1dGlscy50eXBlKGN0KTtcblxuICAgIC8vIHBhcmFtc1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICBjb25zdCB0eXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcblxuICAgIC8vIHN0YXR1cyAvIGNsYXNzXG4gICAgdGhpcy5zdGF0dXMgPSB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0dXNUeXBlID0gdHlwZTtcblxuICAgIC8vIGJhc2ljc1xuICAgIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcbiAgICB0aGlzLm9rID0gMiA9PSB0eXBlO1xuICAgIHRoaXMucmVkaXJlY3QgPSAzID09IHR5cGU7XG4gICAgdGhpcy5jbGllbnRFcnJvciA9IDQgPT0gdHlwZTtcbiAgICB0aGlzLnNlcnZlckVycm9yID0gNSA9PSB0eXBlO1xuICAgIHRoaXMuZXJyb3IgPSAoNCA9PSB0eXBlIHx8IDUgPT0gdHlwZSlcbiAgICAgICAgPyB0aGlzLnRvRXJyb3IoKVxuICAgICAgICA6IGZhbHNlO1xuXG4gICAgLy8gc3VnYXJcbiAgICB0aGlzLmNyZWF0ZWQgPSAyMDEgPT0gc3RhdHVzO1xuICAgIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xuICAgIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cztcbiAgICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xuICAgIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcbiAgICB0aGlzLm5vdEZvdW5kID0gNDA0ID09IHN0YXR1cztcbiAgICB0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHkgPSA0MjIgPT0gc3RhdHVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJhbXMgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gIGNvbnN0IHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFBhcnNlIExpbmsgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcnNlTGlua3MgPSBzdHIgPT4gc3RyLnNwbGl0KC8gKiwgKi8pLnJlZHVjZSgob2JqLCBzdHIpID0+IHtcbiAgY29uc3QgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gIGNvbnN0IHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgY29uc3QgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICBvYmpbcmVsXSA9IHVybDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSAoaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKSA9PiB7XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LWxlbmd0aCddO1xuICBkZWxldGUgaGVhZGVyWyd0cmFuc2Zlci1lbmNvZGluZyddO1xuICBkZWxldGUgaGVhZGVyWydob3N0J107XG4gIC8vIHNlY3VpcnR5XG4gIGlmIChjaGFuZ2VzT3JpZ2luKSB7XG4gICAgZGVsZXRlIGhlYWRlclsnYXV0aG9yaXphdGlvbiddO1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2Nvb2tpZSddO1xuICB9XG4gIHJldHVybiBoZWFkZXI7XG59O1xuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyogZ2xvYmFsIEgsIGZldGNoICovXHJcblwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBtID0gcmVxdWlyZShcIm1hcFwiKTtcclxuXHJcbmxldCBtYXAgPSBudWxsO1xyXG5cclxubGV0IGNsdXN0ZXJMYXllciA9IG51bGw7XHJcblxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZXMgYSBjbHVzdGVyIG9mIHBvaW50c1xyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmNsdXN0ZXJcclxuICogQHBhcmFtIGNvb3JkcyB7QXJyYXl9ICBhcnJheSBvZiBcXFtsYXQsbG5nLHBheWxvYWRcXF1cclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBjbHVzdGVyXHJcbiAqIEBwYXJhbSBbb3B0Lm1pblpvb21dIHtudW1iZXJ9IG1pbiB6b29tIGZvciBjbHVzdGVyIHRvIGJlIHZpc2libGVcclxuICogQHBhcmFtIFtvcHQubWF4Wm9vbV0ge251bWJlcn0gbWF4IHpvb20gZm9yIGNsdXN0ZXIgdG8gYmUgdmlzaWJsZVxyXG4gKiBAcGFyYW0gW29wdC5ub2lzZV0ge2FycmF5fSBncmFwaGljIHRvIHJlcHJlc2VudCBzdGFuZC1hbG9uZSBwb2ludC4gZm9ybWF0OiBbdXJsLHNpemVdXHJcbiAqIEBwYXJhbSBbb3B0LmNsdXN0ZXJJY29uXSB7c3RyaW5nfSB1cmwgb2Ygc3ZnIGZpbGUgcmVwcmVzZW50aW5nIGEgY2x1c3RlclxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gZGVmaW5lIGZvciBlYWNoIG1pbml1bSBhZ2dyZWdhdGlvbiBsZXZlbCB0aGUgY29sb3IgYW5kIHNpemUgb2YgdGhlIGljb24uIFNlZSBleGFtcGxlXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpZiBjbGljayBvbiBpdGVtLiBGb3JtYXQgY2IoZXZlbnQsIGNvb3JkLCBwYXlsb2FkLCB3ZWlndGgpLiBcclxuICogYGNvb3JkYCBpcyBjb29yZCBvZiBpY29uXHJcbiAqIGBwYXlsb2FkYCBpcyBwYXlsb2FkIGFzc29jaWF0ZWQgdG8gcG9pbnQuIFxyXG4gKiBgd2VpZ2h0YCBpcyBudW1iZXIgb2YgcG9pbnRzIGFnZ3JlZ2F0ZWQsIHdoZW4gY2xpY2tpbmcgb24gYSBjbHVzdGVyIGljb24sIDEgaWYgc2luZ2xlIHBvaW50XHJcbiAqIFxyXG4gKiBAcmV0dXJuIHtILm1hcC5sYXllci5PYmplY3RMYXllcn0gIGxheWVyIGNyZWF0ZWRcclxuICogXHJcbiAgKiBAZXhhbXBsZVxyXG4gICogYGBganNcclxuICAqIGxldCBwb2lzID0gW1s0OC44LDIuMyxcIkhlbGxvIHdvcmxkXCJdLFs0OC41LDIuNCxcIkhvdyBhcmUgeW91XCJdLFs0NS4yLDIuOTMsXCJWZXJ5IHdlbGxcIl1dO1xyXG4gICogXHJcbiAgKiBobS5jbHVzdGVyKHBvaXMpO1xyXG4gICogXHJcbiAgKiAvLyB3aXRoIG1vcmUgZ3JhcGhpYyBvcHRpb25zIGFuZCBjYWxsYmFjayBkZWZpbmVkXHJcbiAqICBobS5jbHVzdGVyKHBvaXMsIHtcclxuICogICAgICAgICAgIG5vaXNlOiBbXCJtY2RvLnBuZ1wiLCAyNF0sXHJcbiAqICAgICAgICAgICBjbHVzdGVySWNvbjogJy4uL3N2Zy9jbHVzdGVyMi5zdmcnLCAgICAvLyAgaWNvbiBmb3IgY2x1c3RlclxyXG4gKiAgICAgICAgICAgc3R5bGU6IHtcclxuICogICAgICAgICAgICAgICAyMDA6IHsgY29sb3I6IFwiI0I1MDAxNVwiLCBzaXplOiA2NCB9ICAvLyBmb3IgMjAwIG9yIG1vcmUgcG9pbnRzIGFnZ3JyZWdhdGVkLCBkcmFnIHJlZCBiaWcgaWNvblxyXG4gKiAgICAgICAgICAgICAgIDc1OiB7IGNvbG9yOiBcIiNGRjY5MDBcIiwgc2l6ZTogNTggfSwgIC8vIGZvciA3NSBvciBtb3JlIHBvaW50cyBhZ2dyZWdhdGVkLiBvcmFuZ2UgbWlkZGxlIHNpemUgaWNvblxyXG4gKiAgICAgICAgICAgICAgIDI6IHsgY29sb3I6IFwiIzdCRDMwQVwiLCBzaXplOiA0NiB9LCAgIC8vIGZvciAyIG9yIG1vcmUgcG9pbnRzIGFnZ3JlZ2F0ZWQuIGdyZWVuIHNtYWxsIGljb25cclxuICogICAgICAgICAgIH1cclxuICogICAgICAgfSxcclxuICogICAgICAgICAgIChldmVudCwgY29vcmRpbmF0ZSwgZGF0YSwgd2VpZ2h0KSA9PiB7XHJcbiAqICAgICAgICAgICAgICAgaWYgKGRhdGEpXHJcbiAqICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2sgb24gcG9pbnQgXCIsIGRhdGEpO1xyXG4gKiAgICAgICAgICAgICAgIGVsc2VcclxuICogICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGljayBvbiBjbHVzdGVyIHdpdGggd2VpZ2h0XCIsIHdlaWdodCk7XHJcbiAqICAgICAgICAgICB9KTtcclxuKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNsdXN0ZXIoY29vcmRzLCBvcHQsIGNiID0gbnVsbCkge1xyXG5cclxuICAgIGxldCBkYXRhUG9pbnRzID0gW107XHJcbiAgICBtYXAgPSBtLmdldE1hcCgpO1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBtaW5ab29tOiAxLCAgICAgLy8gbWluIHpvb21cclxuICAgICAgICBtYXhab29tOiAyNCwgICAgLy8gbWF4IHpvb21cclxuICAgICAgICBub2lzZTogW1wiaHR0cDpzdmcvYmx1ZWRvdC5zdmdcIiwgMTZdLCAgLy8gIGljb24rc2l6ZSBmb3Igbm9pc2UsIGNhbiBiZSBzdmcgb3IgaW1hZ2VcclxuICAgICAgICBjbHVzdGVySWNvbjogXCJodHRwOnN2Zy9jbHVzdGVyLnN2Z1wiLCAgICAvLyAgaWNvbiBmb3IgY2x1c3RlclxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIDc1OiB7IGNvbG9yOiBcIiNGRjY5MDBcIiwgc2l6ZTogMzYgfSxcclxuICAgICAgICAgICAgMzogeyBjb2xvcjogXCIjN0JEMzBBXCIsIHNpemU6IDMyIH0sXHJcbiAgICAgICAgICAgIDIwMDogeyBjb2xvcjogXCIjQjUwMDE1XCIsIHNpemU6IDQ4IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKG9wdClcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuXHJcbiAgICBjb29yZHMuZm9yRWFjaChjb29yZCA9PiB7XHJcbiAgICAgICAgLy8gdXNlIG9wX3dlaWdodCBvZiAxIGZvciBlYWNoIGNvb3JkXHJcbiAgICAgICAgLy8gcHJvdmlkZXMgYWxsIGNvb3JkIGFzIGRhdGFcclxuICAgICAgICBsZXQgZHAgPSBuZXcgSC5jbHVzdGVyaW5nLkRhdGFQb2ludChjb29yZFswXSwgY29vcmRbMV0sIDEsIGNvb3JkKTtcclxuICAgICAgICBkYXRhUG9pbnRzLnB1c2goZHApO1xyXG5cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyBub2lzZSBpY29uIDogaWYgU1ZHLCBuZWVkcyB0byBmZXRjaCBpdFxyXG4gICAgbGV0IG5vaXNlSWNvbiA9IHNldHRpbmdzLm5vaXNlWzBdO1xyXG4gICAgbGV0IG5vaXNlU2l6ZSA9IHNldHRpbmdzLm5vaXNlWzFdO1xyXG5cclxuICAgIGlmIChub2lzZUljb24uc3Vic3RyKC0zKSA9PSBcInN2Z1wiKSB7XHJcbiAgICAgICAgbm9pc2VJY29uID0gYXdhaXQgZmV0Y2gobm9pc2VJY29uKVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW5vaXNlSWNvbikgcmV0dXJuOyAvLyBpZiBubyByZXN1bHQsIGxldCdzIHF1aXRcclxuXHJcbiAgICAvLyB0byBzcGVlZCB1cCwgY3JlYXRlIG9ubHkgb25jZSB0aGUgaWNvbiBmb3Igbm9pc2VcclxuICAgIGNvbnN0IGljb25Ob2lzZSA9IG5ldyBILm1hcC5JY29uKG5vaXNlSWNvbiwgeyBzaXplOiB7IHc6IG5vaXNlU2l6ZSwgaDogbm9pc2VTaXplIH0gfSk7XHJcblxyXG4gICAgLy8gbGV0J3Mgbm93IGZldGNoIGNsdXN0ZXIgaWNvblxyXG4gICAgbGV0IHN2Z0NsdXN0ZXIgPSBhd2FpdCBmZXRjaChzZXR0aW5ncy5jbHVzdGVySWNvbilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPSAyMDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgaWYgKCFzdmdDbHVzdGVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgLy8gdG8gc3BlZWQgZGlzcGxheSBkaXNwbGF5LCB3ZSB3aWxsIGNhY2hlIHRoZSB2YXJpb3VzIGNsdXN0ZXIgaWNvbnNcclxuICAgIC8vIGZyb20gdGhlIGJhc2Ugc3ZnLCB3ZSB3aWxsIGNyZWF0ZSBkaWZmZXJlbnQgaWNvbnMgd2l0aCBkaWZmZXJlbnQgc2l6ZS9jb2xvci90ZXh0XHJcbiAgICBsZXQgY2FjaGVJY29uID0ge307IC8vIGNhY2hlIG9mIGljb25zXHJcblxyXG4gICAgLy8gb3JkZXIgc3R5bGUgYnkgc2l6ZSBkZXNjZW5kaW5nXHJcbiAgICBsZXQgc3R5bGVTaXplID0gT2JqZWN0LmtleXMoc2V0dGluZ3Muc3R5bGUpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9KTtcclxuXHJcbiAgICAvLyB0aGlzIGZ1bmN0aW9uICBjcmV0YWVzIHRoZSBpY29uIGZvciBhIGNsdXN0ZXJcclxuICAgIGZ1bmN0aW9uIGdldENsdXN0ZXJQcmVzZW50YXRpb24oY2x1c3Rlcikge1xyXG5cclxuICAgICAgICAvLyBidWlsZGluZyBkYXRhIG9iamVjdCB3aGljaCB3aWxsIGJlIHJldHVybmVkIHdoZW4gY2xpY2tpbmcgb24gdGhlIGljb25cclxuICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgIGRhdGEuaXNDbHVzdGVyID0gKCkgPT4geyByZXR1cm4gdHJ1ZTsgfTsgIC8vIHNvIHdlIGtub3cgaXQgaXMgYSBjbHVzdGVyXHJcbiAgICAgICAgbGV0IHdlaWdodCA9IGNsdXN0ZXIuZ2V0V2VpZ2h0KCk7XHJcbiAgICAgICAgZGF0YS5nZXRXZWlnaHQgPSAoKSA9PiB7IHJldHVybiB3ZWlnaHQ7IH07IC8vIG51bWJlciBvZiBpbmRpdmlkdWFsIGl0ZW0gY2x1c3RlcmVkIHRvZ2V0aGVyXHJcblxyXG4gICAgICAgIC8vIGxldCdzIGZpbmQgdGhlIHJlbGV2YW50IGNvbG9yIGFuZCBzaXplXHJcbiAgICAgICAgbGV0IGVudHJ5ID0gc3R5bGVTaXplLmZpbmQoZWx0ID0+ICh3ZWlnaHQgPj0gZWx0KSk7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gc2V0dGluZ3Muc3R5bGVbZW50cnldLmNvbG9yO1xyXG4gICAgICAgIGxldCBzaXplID0gc2V0dGluZ3Muc3R5bGVbZW50cnldLnNpemU7XHJcblxyXG4gICAgICAgIC8vIGxldCdzIGNyZWF0ZSBhbmQgY2FjaGUgdGhlIG5lZWRlZCBpY29uc1xyXG4gICAgICAgIGxldCBrZXkgPSBjb2xvciArIFwiLVwiICsgd2VpZ2h0ICsgXCItXCIgKyBzaXplO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FjaGVJY29uW2tleV0gPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICBsZXQgc3ZnID0gc3ZnQ2x1c3Rlci5yZXBsYWNlKFwie3RleHR9XCIsIHdlaWdodCkucmVwbGFjZSgve2NvbG9yfS9nLCBjb2xvcik7XHJcbiAgICAgICAgICAgIGNhY2hlSWNvbltrZXldID0gbmV3IEgubWFwLkljb24oc3ZnLCB7IHNpemU6IHsgdzogc2l6ZSwgaDogc2l6ZSB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbWFya2VyIGZvciB0aGUgQ2x1c3RlclxyXG4gICAgICAgIHZhciBjbHVzdGVyTWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihjbHVzdGVyLmdldFBvc2l0aW9uKCksIHtcclxuICAgICAgICAgICAgLy8gVXNlIG1pbiB6b29tIGZyb20gYSBub2lzZSBwb2ludFxyXG4gICAgICAgICAgICAvLyB0byBzaG93IGl0IGNvcnJlY3RseSBhdCBjZXJ0YWluIHpvb20gbGV2ZWxzOlxyXG4gICAgICAgICAgICBtaW46IGNsdXN0ZXIuZ2V0TWluWm9vbSgpLFxyXG4gICAgICAgICAgICBtYXg6IGNsdXN0ZXIuZ2V0TWF4Wm9vbSgpLFxyXG4gICAgICAgICAgICBpY29uOiBjYWNoZUljb25ba2V5XSxcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIExpbmsgZGF0YSBmcm9tIHRoZSBmcm9tIHRoZSBjbHVzdGVyIHRvIHRoZSBtYXJrZXIsXHJcbiAgICAgICAgLy8gdG8gbWFrZSBpdCBhY2Nlc3NpYmxlIG9uIGNhbGxiYWNrXHJcbiAgICAgICAgY2x1c3Rlck1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2x1c3Rlck1hcmtlcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmdW5jdGlvbiB0byByZXByZXNlbnQgYSBzaW5nbGUgaXRlbVxyXG4gICAgZnVuY3Rpb24gZ2V0Tm9pc2VQcmVzZW50YXRpb24obm9pc2VQb2ludCkge1xyXG5cclxuICAgICAgICAvLyBkYXRhIHRvIGJlIHNlbnQgb24gY2FsbGJhY2tcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBnZXREYXRhOiAoKSA9PiB7IHJldHVybiBub2lzZVBvaW50LmdldERhdGEoKTsgfSxcclxuICAgICAgICAgICAgaXNDbHVzdGVyOiAoKSA9PiB7IHJldHVybiBmYWxzZTsgfSxcclxuICAgICAgICAgICAgZ2V0V2VpZ2h0OiAoKSA9PiB7IHJldHVybiAxOyB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFya2VyIGZvciB0aGUgbm9pc2VQb2ludFxyXG4gICAgICAgIHZhciBub2lzZU1hcmtlciA9IG5ldyBILm1hcC5NYXJrZXIobm9pc2VQb2ludC5nZXRQb3NpdGlvbigpLCB7XHJcbiAgICAgICAgICAgIC8vIFVzZSBtaW4gem9vbSBmcm9tIGEgbm9pc2UgcG9pbnRcclxuICAgICAgICAgICAgLy8gdG8gc2hvdyBpdCBjb3JyZWN0bHkgYXQgY2VydGFpbiB6b29tIGxldmVsczpcclxuICAgICAgICAgICAgbWluOiBub2lzZVBvaW50LmdldE1pblpvb20oKSxcclxuICAgICAgICAgICAgaWNvbjogaWNvbk5vaXNlXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAvLyBMaW5rIGEgZGF0YSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbWFya2VyXHJcbiAgICAgICAgLy8gdG8gbWFrZSBpdCBhY2Nlc3NpYmxlIG9uIGNhbGxiYWNrXHJcbiAgICAgICAgbm9pc2VNYXJrZXIuc2V0RGF0YShkYXRhKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5vaXNlTWFya2VyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBjcmVhdGUgY2x1c3RlciBwcm92aWRlclxyXG4gICAgbGV0IGNsdXN0ZXJlZERhdGFQcm92aWRlciA9IG5ldyBILmNsdXN0ZXJpbmcuUHJvdmlkZXIoZGF0YVBvaW50cywge1xyXG4gICAgICAgIGNsdXN0ZXJpbmdPcHRpb25zOiB7XHJcbiAgICAgICAgICAgIC8vIE1heGltdW0gcmFkaXVzIG9mIHRoZSBuZWlnaGJvcmhvb2RcclxuICAgICAgICAgICAgZXBzOiA2NCxcclxuICAgICAgICAgICAgLy8gbWluaW11bSB3ZWlnaHQgb2YgcG9pbnRzIHJlcXVpcmVkIHRvIGZvcm0gYSBjbHVzdGVyXHJcbiAgICAgICAgICAgIG1pbldlaWdodDogc3R5bGVTaXplW3N0eWxlU2l6ZS5sZW5ndGggLSAxXSAvLyBtaW5pbXVtIGNsdXN0ZXJpbmcgaXMgZGVmaW5lZCBieSBtaW5zaXplIGluIFN0eWxlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtaW46IHNldHRpbmdzLm1pblpvb20sIC8vIG1pbiB6b29tXHJcbiAgICAgICAgbWF4OiBzZXR0aW5ncy5tYXhab29tLCAvLyBtYXggem9vbVxyXG4gICAgICAgIHRoZW1lOiB7IGdldENsdXN0ZXJQcmVzZW50YXRpb246IGdldENsdXN0ZXJQcmVzZW50YXRpb24sIGdldE5vaXNlUHJlc2VudGF0aW9uOiBnZXROb2lzZVByZXNlbnRhdGlvbiB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBsYXllciB0aGF0IGluY2x1ZGVzIHRoZSBkYXRhIHByb3ZpZGVyIGFuZCBpdHMgZGF0YSBwb2ludHM6XHJcbiAgICBsZXQgbGF5ZXIgPSBuZXcgSC5tYXAubGF5ZXIuT2JqZWN0TGF5ZXIoY2x1c3RlcmVkRGF0YVByb3ZpZGVyKTtcclxuICAgIC8vIEFkZCB0aGUgbGF5ZXIgdG8gdGhlIG1hcDpcclxuICAgIG1hcC5hZGRMYXllcihsYXllcik7XHJcblxyXG4gICAgLy8gaWYgYSBjYWxsYmFjayBpcyBkZWZpbmVkLCBhZGQgZXZlbnQgbGlzdGVuZXJcclxuICAgIGlmIChjYikge1xyXG4gICAgICAgIGNsdXN0ZXJlZERhdGFQcm92aWRlci5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAvLyBMb2cgZGF0YSBib3VuZCB0byB0aGUgbWFya2VyIHRoYXQgaGFzIGJlZW4gdGFwcGVkOlxyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGV2LnRhcmdldC5nZXREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IG1hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIGxldCBpc0NsdXN0ZXIgPSBkYXRhLmlzQ2x1c3RlcigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzQ2x1c3Rlcikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdlaWd0aCA9IGRhdGEuZ2V0V2VpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICBjYihldiwgbS5jb29yZE8yQShjb29yZCksIG51bGwsIHdlaWd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVzZXJEYXRhID0gZGF0YS5nZXREYXRhKCk7IC8vIGxhdCxsbmcsIHBheWxvYWRcclxuICAgICAgICAgICAgICAgIGNiKGV2LCBtLmNvb3JkTzJBKGNvb3JkKSwgdXNlckRhdGFbMl0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoaWRlKCkge1xyXG4gICAgY2x1c3RlckxheWVyLnNldE1heCgwKTtcclxuICAgIGNsdXN0ZXJMYXllci5zZXRNaW4oMCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNob3coKSB7XHJcbiAgICBjbHVzdGVyTGF5ZXIuc2V0TWF4KDI0KTtcclxuICAgIGNsdXN0ZXJMYXllci5zZXRNaW4oMCk7XHJcblxyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBjbHVzdGVyOiBjbHVzdGVyLFxyXG4gICAgY2x1c3RlclNob3c6IHNob3csXHJcbiAgICBjbHVzdGVySGlkZTogaGlkZVxyXG59O1xyXG5cclxuIiwiLyogZ2xvYmFsIGRvY3VtZW50ICovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoXCJzdXBlcmFnZW50XCIpO1xyXG5cclxuLy8gYnkgZGVmYXVsdCwgdW5sZXNzIHNwZWNpZmllZCBmYnkgY2FsbGluZyBjb25maWdcclxuLy8gZW52aXJvbm1lbnQgdXNhYmxlIHdpdGggbm9kZVxyXG5sZXQgQVBQX0lEID0gcHJvY2Vzcy5lbnYuQVBQX0lEO1xyXG5sZXQgQVBQX0NPREUgPSBwcm9jZXNzLmVudi5BUFBfQ09ERTtcclxubGV0IENJVCA9IFwiXCI7IC8vIHByb2R1Y3Rpb24gYnkgZGVmYXVsdFxyXG5sZXQgUFJPVE9DT0wgPSBcImh0dHBzOlwiOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfdXNlSFRUUFMgPSB0cnVlOyAvLyBieSBkZWZhdWx0XHJcbmxldCBfaG9tZSA9IFwiLlwiO1xyXG5cclxuXHJcbi8vIGZpbmQgb3V0IHdoZXJlIHdlIGFyZSBhbmQgcmVsYXRpdmUgcG9zaXRpb24gZm9yIHBuZy9zdmcgZmlsZXNcclxuLy8gcGF5IGF0dGVudGlvbiBpZiBsaWJyYXJ5IGlzIGJ1aWxkIGluIC4vZGlzdFxyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7XHJcbiAgICBsZXQgX3NjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xyXG4gICAgbGV0IF9maWxlID0gX3NjcmlwdFtfc2NyaXB0Lmxlbmd0aCAtIDFdLnNyYztcclxuICAgIGxldCBfcGF0aCA9IF9maWxlLnN1YnN0cmluZygwLCBfZmlsZS5sYXN0SW5kZXhPZihcIi9cIikpO1xyXG5cclxuICAgIF9ob21lID0gX3BhdGggKyBcIi8uLi9cIjsgLy8gYSBiaXQgZGlydHkgYnV0IC4uLlxyXG59XHJcblxyXG4vKipcclxuICogVG8gY29uZmlndXJlIGFwcF9pZCwgYXBwX2NvZGUgYW5kIG9wdGlvbmFsbHkgdXNlIENJVCBhbmQgaHR0cFxyXG4gKiBAYWxpYXMgaG06Y29uZmlnXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdH0gIC0gYG9wdGAgd2l0aCBwYXJhbWV0ZXJzLlxyXG4gKiBAcGFyYW0gW29wdC5hcHBfaWRdIHtzdHJpbmd9IC0gdGhlIGFwcF9pZCBmcm9tIGRldmVsb3Blci5oZXJlLmNvbVxyXG4gKiBAcGFyYW0gW29wdC5hcHBfY29kZV0ge3N0cmluZ30gLSB0aGUgYXBwX2NvZGUgZnJvbSBkZXZlbG9wZXIuaGVyZS5jb21cclxuICogQHBhcmFtIFtvcHQudXNlQ0lUPWZhbHNlXSB7Ym9vbGVhbn0gLSB0cnVlIHRvIHVzZSBDSVQgZW52aXJvbm1lbnQuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQPWZhbHNlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFAuIFxyXG4gKiBAcGFyYW0gW29wdC51c2VIVFRQUz10cnVlXSB7c3RyaW5nfSAtIHRydWUgdG8gdXNlIEhUVFBTLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogIGhtLmNvbmZpZyh7XHJcbiAqICAgICAgYXBwX2lkOiBcIllPVVIgQVBQX0lEXCIsXHJcbiAqICAgICAgYXBwX2NvZGU6IFwiWU9VUiBBUFBfQ09ERVwiLFxyXG4qICAgfSk7XHJcbiogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gY29uZmlnKG9wdCkge1xyXG4gICAgaWYgKG9wdC5hcHBfaWQpIEFQUF9JRCA9IG9wdC5hcHBfaWQ7XHJcbiAgICBpZiAob3B0LmFwcF9jb2RlKSBBUFBfQ09ERSA9IG9wdC5hcHBfY29kZTtcclxuICAgIGlmIChvcHQudXNlQ0lUKSBDSVQgPSBcIi5jaXRcIjtcclxuICAgIGlmIChvcHQudXNlSFRUUCkge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwOlwiO1xyXG4gICAgICAgIF91c2VIVFRQUyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdC51c2VIVFRQUykge1xyXG4gICAgICAgIFBST1RPQ09MID0gXCJodHRwczpcIjtcclxuICAgICAgICBfdXNlSFRUUFMgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIFVSTCBvZiBtb2R1bGUgaG9tZSBkaXJlY3RvcnlcclxuICogQGlnbm9yZVxyXG4gKiAgQGFsaWFzIGhtOmdldEhvbWVcclxuICogQHJldHVybiB7c3RyaW5nfSB1cmwgb2YgaG9tZSBkaXJlY3RvcnkgaW5jbHVkaW5nIGh0dHAgb3IgaHR0cHNcclxuICovXHJcbmZ1bmN0aW9uIGdldEhvbWUoKSB7XHJcbiAgICByZXR1cm4gX2hvbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGFwcF9pZFxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0QXBwSWRcclxuICogQHJldHVybiB7c3RyaW5nfSBhcHBfaWRcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwSWQoKSB7XHJcbiAgICByZXR1cm4gQVBQX0lEO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGFwcF9jb2RlXHJcbiAqICBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0SG9tZVxyXG4gKiAgQGFsaWFzIGhtOmdldEFwcENvZGVcclxuICAqIEByZXR1cm4ge3N0cmluZ30gYXBwX2NvZGVcclxuKi9cclxuZnVuY3Rpb24gZ2V0QXBwQ29kZSgpIHtcclxuICAgIHJldHVybiBBUFBfQ09ERTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB0cnVlIGlmIHVzaW5nIENJVFxyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRDSVRcclxuICogQHJldHVybiB7Ym9vb2xlYW59IHRydWUgaWYgdXNpbmcgQ0lUXHJcbiovXHJcbmZ1bmN0aW9uIGdldENJVCgpIHtcclxuICAgIHJldHVybiBDSVQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gcHJvdG9jb2wgdXNlZCwgaHR0cDovLyBvciBodHRwczovL1xyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpnZXRQcm90b2NvbFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gcHJvdG9jb2xcclxuKi9cclxuZnVuY3Rpb24gZ2V0UHJvdG9jb2woKSB7XHJcbiAgICByZXR1cm4gUFJPVE9DT0w7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gdHJ1ZSBpcyBodHRwcyBpcyB1c2VkXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTp1c2VIVFRQU1xyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIHRydWUgaWYgaHR0cHMgaXMgdXNlZFxyXG4qL1xyXG5mdW5jdGlvbiB1c2VIVFRQUygpIHtcclxuICAgIHJldHVybiBfdXNlSFRUUFM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGQgY3JlZGVudGlhbHMgdG8gb2JqZWN0IHByb3ZpZGVkXHJcbiAgKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06YWRkQ3JlZGVudGlhbHNcclxuICogQHBhcmFtICB7Li4ub2JqZWN0c30gbGlzdCBvZiBgb2JqZWN0c2AgXHJcbiAqIEByZXR1cm4ge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGlucHV0IG9iamVjdGNvbmNhdGVuYXRlZCwgYW5kIGFwcF9pZC9hcHBfY29kZSBpbnNlcnRlZFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkQ3JlZGVudGlhbHMoLi4ub2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgYXBwX2lkOiBBUFBfSUQsXHJcbiAgICAgICAgYXBwX2NvZGU6IEFQUF9DT0RFXHJcbiAgICB9LCAuLi5vYmopO1xyXG59XHJcblxyXG4vKipcclxuICogYnVpbGQgSEVSRSBSRVNUIGZ1bGwgdXJsLCB0YWtpbmcgaW4gYWNjb3VudCBwcm90b2NvbCBhbmQgY2l0LiBmb3IgaW5zdGFuY2UgIGNtLmJ1aWxkVXJsKFwiZ2VvY29kZXJcIiwgXCJhcGkuaGVyZS5jb20vNi4yL2dlb2NvZGUuanNvblwiXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlIC0gYmFzZSBuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIGVuZCBwb2ludFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGZ1bGwgdXJsXHJcbiAqL1xyXG5mdW5jdGlvbiBidWlsZFVybChiYXNlLCBlbmRwb2ludCkge1xyXG4gICAgcmV0dXJuIFBST1RPQ09MICsgXCIvL1wiICsgYmFzZSArIENJVCArIFwiLlwiICsgZW5kcG9pbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkb2VzIGdldC9wb3N0IHJlcXVlc3QgdG8gSEVSRSBSRVNEVCBiYWNrZW5kIGFuZCBtYW5hZ2UgbWFpbiBlcnJvcnNcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06aGVyZVJlc3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAgLSB1cmwgdG8gY2FsbCAsIGZvciBpbnN0YW5jZSBmcm9tIGJ1aWxkVXJsXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyAtIHNldHRpbmdzIHRvIGFkZCBpbiByZXF1ZXN0XHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbW9kZT1nZXQgLSBtb2RlIFwiZ2V0XCIgb3IgXCJwb3N0XCJcclxuICogQHJldHVybiB7cHJvbWlzZX0gLSBwcm9taXNlIHRvIHJlc29sdmUvcmVqZWN0XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBoZXJlUmVzdCh1cmwsIHNldHRpbmdzLCBtb2RlID0gXCJnZXRcIikge1xyXG5cclxuICAgIGxldCBwID0gcmVxdWVzdC5nZXQodXJsKTtcclxuICAgIGlmIChtb2RlID09IFwicG9zdFwiKVxyXG4gICAgICAgIHAgPSByZXF1ZXN0LnBvc3QodXJsKTtcclxuXHJcbiAgICByZXR1cm4gcFxyXG4gICAgICAgIC5xdWVyeShzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gXCIyMDBcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJFcnJvciBcIiArIHJlcy5zdGF0dXMgKyBcIjpcIiArIHJlcy5ib2R5KTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoIXJlcy5ib2R5LlJlc3BvbnNlICYmICFyZXMuYm9keS5yZXNwb25zZSkgeyAvLyBvbmUgb2YgdGhlIHR3byBzaG91bGQgYmUgaW4gdGhlIGFuc3dlclxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlF1ZXJ5IGVycm9yOlwiICsgcmVzLmJvZHkpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHRocm93IChlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlcy5ib2R5LnJlc3BvbnNlICYmIHJlcy5ib2R5LnJlc3BvbnNlLnR5cGUgPT0gXCJBcHBsaWNhdGlvbkVycm9yXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzLmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJFcnJvclwiICsgcmVzLmJvZHkucmVzcG9uc2UuZGV0YWlscyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNvbmZpZzogY29uZmlnLFxyXG4gICAgYnVpbGRVcmw6IGJ1aWxkVXJsLFxyXG4gICAgZ2V0QXBwSWQ6IGdldEFwcElkLFxyXG4gICAgZ2V0QXBwQ29kZTogZ2V0QXBwQ29kZSxcclxuICAgIGdldENJVDogZ2V0Q0lULFxyXG4gICAgZ2V0UHJvdG9jb2w6IGdldFByb3RvY29sLFxyXG4gICAgZ2V0SG9tZTogZ2V0SG9tZSxcclxuICAgIHVzZUhUVFBTOiB1c2VIVFRQUyxcclxuICAgIGFkZENyZWRlbnRpYWxzOiBhZGRDcmVkZW50aWFscyxcclxuICAgIGhlcmVSZXN0OiBoZXJlUmVzdFxyXG59OyIsIi8qKlxyXG4gKiBAZmlsZSBHZW9jb2RpbmcgZnVuY3Rpb25zIDogYWRkcmVzc2VzIDwtLT4gW2xhdCxsbmddXHJcbiAqIEBhdXRob3IgRGV2YmFiIFxyXG4gKi9cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBnZW9jb2RlIGFuIGFkZHJlc3NcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpnZW9jb2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gYWRkcmVzcyBhcyBzdHJpbmdcclxuICogQHJldHVybnMge09iamVjdH0gcmV0dXJucyAge2Nvb3JkLGJvZHl9LiBjb29yZCBpcyBnZW9jb2RlIGFzIFxcW2xhdCxsbmdcXF0uIGJvZHkgaXMgZnVsbCBqc29uIGFuc3dlclxyXG4gKiBcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgcmVzID0gYXdhaXQgaG0uZ2VvY29kZShcImF2ZW51ZSBkZXMgY2hhcHMgZWx5c2VlcywgcGFyaXNcIik7XHJcbiAqIGNvbnNvbGUubG9nIChyZXMuY29vcmQpO1xyXG4gKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGdlb2NvZGUoYWRkcmVzcykge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIHNlYXJjaFRleHQ6IGFkZHJlc3NcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiZ2VvY29kZXJcIiwgXCJhcGkuaGVyZS5jb20vNi4yL2dlb2NvZGUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHNldHRpbmdzKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLmJvZHkuUmVzcG9uc2UuVmlldy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJHZW9jb2RlIEFkZHJlc3Mgbm90IGZvdW5kOiBcIiArIGFkZHJlc3MpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHRocm93IChlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmJvZHkuUmVzcG9uc2UuVmlld1swXS5SZXN1bHRbMF0uTG9jYXRpb247XHJcbiAgICAgICAgICAgIHZhciBjb29yZCA9IFtsb2NhdGlvbi5OYXZpZ2F0aW9uUG9zaXRpb25bMF0uTGF0aXR1ZGUsIGxvY2F0aW9uLk5hdmlnYXRpb25Qb3NpdGlvblswXS5Mb25naXR1ZGVdO1xyXG4gICAgICAgICAgICByZXR1cm4geyBjb29yZDogY29vcmQsIGJvZHk6IHJlcy5ib2R5IH07XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogcmV2ZXJzZSBnZW9jb2RlIGEgY29vcmRpbmF0ZVxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOnJldmVyc2VHZW9jb2RlXHJcbiAqIEBwYXJhbSB7Q29vcmR9IGNvb3JkIC0gY29vcmQgXFxbbGF0LGxuZ1xcXSB0byByZXZlcnNlIGdlb2NvZGVcclxuICogQHJldHVybnMge29iamVjdH0gcmV0dXJucyB7IGxvY2F0aW9uOm9iamVjdCwgYWRkcmVzczpvYmplY3QsIGJvZHk6b2JqZWN0fS4gXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZXZlcnNlR2VvY29kZShjb29yZCkge1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG1vZGU6IFwicmV0cmlldmVBZGRyZXNzZXNcIixcclxuICAgICAgICBwcm94OiBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicmV2ZXJzZS5nZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvcmV2ZXJzZWdlb2NvZGUuanNvblwiKTtcclxuXHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBzZXR0aW5ncylcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAvLyByZXMuYm9keSwgcmVzLmhlYWRlcnMsIHJlcy5zdGF0dXNcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmJvZHkuUmVzcG9uc2UuVmlld1swXS5SZXN1bHRbMF0uTG9jYXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiAoeyBsb2NhdGlvbjogbG9jYXRpb24sIGFkZHJlc3M6IGxvY2F0aW9uLkFkZHJlc3MsIGJvZHk6IHJlcy5ib2R5IH0pO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBnZW9jb2RlOiBnZW9jb2RlLFxyXG4gICAgcmV2ZXJzZUdlb2NvZGU6IHJldmVyc2VHZW9jb2RlXHJcbn07XHJcblxyXG4iLCIvKiBnbG9iYWwgSCwgZmV0Y2gsIGRvY3VtZW50LCBuYXZpZ2F0b3IsIG1hcHNqcywgd2luZG93IEFQUF9JRF9KQVBBTixBUFBfQ09ERV9KQVBBTixBUFBfSURfS09SRUEsQVBQX0NPREVfS09SRUEqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxubGV0IF9wbGF0Zm9ybSA9IG51bGw7XHJcbmxldCBfcHJvdmlkZXIgPSBudWxsO1xyXG5sZXQgX2RlZmF1bHRMYXllcnMgPSBudWxsO1xyXG5sZXQgX3VpID0gbnVsbDtcclxubGV0IF9tYXAgPSBudWxsO1xyXG5sZXQgZ3JvdXAgPSBudWxsO1xyXG5sZXQgX2xheWVycyA9IFtdOyAvLyBsaXN0IGFsbCBsYXllcnNcclxubGV0IF9rZXkgPSB7fTsgICAgIC8vIGtleXMgIFxyXG5sZXQgX2J1YmJsZU1hcmtlciA9IG51bGw7ICAgICAvLyBidWJibGUgZGUgbWFtcmtlclxyXG5sZXQgX3NjaGVtZSA9IFwibm9ybWFsLmRheS5ncmV5XCI7XHJcbmxldCBfbG9jYXRlTWUgPSBudWxsOyAgICAgICAgIC8vIGlkIHdoZW4gbG9jYXRlIGlzIGFjdGl2ZVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBjb29yZE8yQShvYmopIHtcclxuICAgIHJldHVybiBbb2JqLmxhdCwgb2JqLmxuZ107XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvb3JkQTJPKGFycikge1xyXG4gICAgcmV0dXJuIHsgbGF0OiBhcnJbMF0sIGxuZzogYXJyWzFdIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlIGEgbWFwIGFyZWEgd2l0aGluIHRoZSBzcGVjaWZpZWQgaXRlbVxyXG4gICogQGFsaWFzIGhtOm1hcFxyXG5cclxuICogQHBhcmFtIGh0bWxJdGVtIHtzdHJpbmd9ICAtIGlkZW50aWZpZXIgb2YgaHRtbCBkaXYgaXRlbSBvbiB3aGljaCB0byBpbnNlcnQgbWFwXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gIC0gb3B0aW9uc1xyXG4gKiBAcGFyYW0gW29wdC56b29tPTEwXSB7bnVtYmVyfSAgLSB6b29tIGZhY3RvclxyXG4gKiBAcGFyYW0gW29wdC5jZW50ZXI9WzQ4Ljg2LCAyLjNdXSB7Q29vcmR9ICAtIENvb3JkIG9mIHRoZSBjZW50ZXJcclxuICogQHBhcmFtIFtvcHQuY2xpY2s9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrOiBjYWxsYmFjayhjb29yZCxidXR0b24sa2V5KVxyXG4gKiBAcGFyYW0gW29wdC5kYkNsaWNrPW51bGxdIHtmdW5jdGlvbigpfSAgLSBjYWxsYmFjayBvbiBtb3VzZSBkb3VibGUgY2xpY2s6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrTGVmdD1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIGxlZnQ6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrUmlnaHQ9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIHJpZ2h0LjogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQua2V5RG93bj1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIGtleSBkb3duIDogY2FsbGJhY2soa2V5KVxyXG4gKiBAcGFyYW0gW29wdC52aWV3Q2hhbmdlPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgaWYgbWFwIGlzIHBhbm5lZCBvciB6b29tZWQgOiBjYWxsYmFjayh6b29tLGNvb3JkQ2VudGVyKVxyXG4gKiBAcGFyYW0gW29wdC5sb2FkVGlsZT1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIHdoZW4gYSB0aWxlIGlzIGxvYWRlZCA6IGNhbGxiYWNrKHoseCx5LHVybClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgaG0gPSB3aW5kb3cuaGVyZW1hcDtcclxuICogXHJcbiAqIGhtLmNvbmZpZyh7XHJcbiAqICAgIGFwcF9pZDogXCJZT1VSIEFQUF9JRFwiLFxyXG4gKiAgICBhcHBfY29kZTogXCJZT1VSIEFQUF9DT0RFXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBobS5tYXAoXCJtYXBcIiwge1xyXG4gKiAgICB6b29tOjUsXHJcbiAqICAgIGNlbnRlcjogWzQ4LjgsMi4zXSxcclxuICogICAgY2xpY2s6IGZ1bmN0aW9uKGNvb3JkLGJ1dHRvbixrZXkpIHtjb25zb2xlLmxvZyhcImNsaWNrZWQgb25cIixjb29yZCxcIndpdGggYnV0dG9uXCIsYnV0dG9uKTt9XHJcbiAqIH0pO1xyXG4qICBgYGBcclxuKi9cclxuZnVuY3Rpb24gbWFwKGh0bWxJdGVtLCBvcHQpIHtcclxuXHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgem9vbTogMTAsXHJcbiAgICAgICAgY2VudGVyOiBbNDguODYsIDIuM10sXHJcbiAgICAgICAgY2xpY2tMZWZ0OiBudWxsLFxyXG4gICAgICAgIGNsaWNrUmlnaHQ6IG51bGwsXHJcbiAgICAgICAga2V5RG93bjogbnVsbCwgIC8vIGtleWJvYXJkIGV2ZW50XHJcbiAgICAgICAgY2xpY2s6IG51bGwsXHJcbiAgICAgICAgZGJDbGljazogbnVsbCxcclxuICAgICAgICB2aWV3Q2hhbmdlOiBudWxsLCAvLyAoem9vbSxjb29yZClcclxuICAgICAgICBsb2FkVGlsZTogbnVsbCAvLyBxdWFuZCB1bmUgdGlsZSBlc3QgYWZmaWNow6llXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBtcHMgPSAxO1xyXG5cclxuICAgIGxldCBhcHBfaWQgPSBjbS5nZXRBcHBJZCgpO1xyXG4gICAgbGV0IGFwcF9jb2RlID0gY20uZ2V0QXBwQ29kZSgpO1xyXG5cclxuICAgIGlmICghYXBwX2lkIHx8ICFhcHBfY29kZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiYXBwX2lkL2FwcF9jb2RlIG5vdCBpbml0aWFsaXNlZFwiKTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sSXRlbSkuaW5uZXJIVE1MID0gXCJhcHBfaWQvYXBwX2NvZGUgbm90IGluaXRpYWxpc2VkXCI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIF9wbGF0Zm9ybSA9IG5ldyBILnNlcnZpY2UuUGxhdGZvcm0oe1xyXG4gICAgICAgIGFwcF9pZDogYXBwX2lkLFxyXG4gICAgICAgIGFwcF9jb2RlOiBhcHBfY29kZSxcclxuICAgICAgICB1c2VDSVQ6IGNtLmdldENJVCgpLFxyXG4gICAgICAgIHVzZUhUVFBTOiBjbS51c2VIVFRQUygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG4gICAgaWYgKHNldHRpbmdzLnNjaGVtZSkgX3NjaGVtZSA9IHNldHRpbmdzLnNjaGVtZTsgLy8gc3RvcmUgc2NoZW1lIGlmIGRlZmluZWRcclxuXHJcbiAgICBfZGVmYXVsdExheWVycyA9IF9wbGF0Zm9ybS5jcmVhdGVEZWZhdWx0TGF5ZXJzKCk7XHJcbiAgICBjb25zb2xlLmxvZyhfZGVmYXVsdExheWVycyk7XHJcblxyXG4gICAgLy8gaHR0cDovL2hlcmVtYXBzLmdpdGh1Yi5pby9leGFtcGxlcy9leHBsb3Jlci5odG1sI21hcC10aWxlc19fYmFzZS1tYXAtc3R5bGVzLWFuZC1tb2Rlc1xyXG4gICAgX3Byb3ZpZGVyID0gbmV3IEgubWFwLnByb3ZpZGVyLkltYWdlVGlsZVByb3ZpZGVyKHtcclxuICAgICAgICBsYWJlbDogXCJCYXNlIFByb3ZpZGVyXCIsXHJcbiAgICAgICAgZGVzY3I6IFwiXCIsXHJcbiAgICAgICAgbWluOiAwLFxyXG4gICAgICAgIG1heDogMjAsXHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXHJcbiAgICAgICAgZ2V0VVJMOiBmdW5jdGlvbiAoY29sLCByb3csIGxldmVsKSB7XHJcbiAgICAgICAgICAgIG1wcysrOyBpZiAobXBzID4gNCkgbXBzID0gMTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IFtjbS5nZXRQcm90b2NvbCgpLCBcIi8vXCIsIG1wcywgXCIuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlLmNvbS9tYXB0aWxlL1wiLCBcIjIuMVwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwibWFwdGlsZVwiLCBcIi9cIiwgXCJuZXdlc3RcIiwgXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBfc2NoZW1lLCBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwicG5nXCIsIFwiP2xnPVwiLCBcIkZSRVwiLFxyXG4gICAgICAgICAgICAgICAgXCImYXBwX2NvZGU9XCIsIGFwcF9jb2RlLCBcIiZhcHBfaWQ9XCIsXHJcbiAgICAgICAgICAgICAgICBhcHBfaWRdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3NjaGVtZSA9PSBcImphcGFuXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIm0ubGJzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5qcC92MS9tYXA/YXBwX2lkPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIEFQUF9JRF9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfQ09ERV9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlbWF0cml4PUVQU0c6OTAwOTEzOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVjb2w9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVyb3c9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93XS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcImtvcmVhXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIjMuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5rci9tYXB0aWxlLzIuMS9tYXB0aWxlLzM0NDM5MzQ4YzMvbm9ybWFsLmRheS9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiLCBcInBuZ1wiLCBcIj9sZz1cIiwgXCJGUkVcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIiwgQVBQX0NPREVfS09SRUEsIFwiJmFwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfSURfS09SRUFdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwiYmxhY2tcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL2JsYWNrLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwid2hpdGVcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3doaXRlLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3RyYW5zcGFyZW50LnBuZ1wiO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2FkVGlsZSlcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmxvYWRUaWxlKGxldmVsLCBjb2wsIHJvdywgdXJsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX19sYXllciA9IG5ldyBILm1hcC5sYXllci5UaWxlTGF5ZXIoX3Byb3ZpZGVyKTtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwibm9ybWFsIG1hcFwiKTtcclxuICAgIC8vU3RlcCAyOiBpbml0aWFsaXplIGEgSEVSRU1hcCBcclxuICAgIF9tYXAgPSBuZXcgSC5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEl0ZW0pLFxyXG4gICAgICAgIF9fbGF5ZXIsIHtcclxuICAgICAgICAgICAgY2VudGVyOiBjb29yZEEyTyhzZXR0aW5ncy5jZW50ZXIpLFxyXG4gICAgICAgICAgICB6b29tOiBzZXR0aW5ncy56b29tXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGV0IGJlaGF2aW9yID0gbmV3IEgubWFwZXZlbnRzLkJlaGF2aW9yKG5ldyBILm1hcGV2ZW50cy5NYXBFdmVudHMoX21hcCkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBVSSBjb21wb25lbnRzXHJcbiAgICBfdWkgPSBILnVpLlVJLmNyZWF0ZURlZmF1bHQoX21hcCwgX2RlZmF1bHRMYXllcnMpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGxheWVyXHJcbiAgICBsYXllckNyZWF0ZShcImRlZmF1bHRcIik7XHJcblxyXG4gICAgLy8gaWYgY2FsbGJhY2sgb24gem9vbSBDaGFuZ2VcclxuICAgIGlmIChzZXR0aW5ncy52aWV3Q2hhbmdlKSB7XHJcbiAgICAgICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwibWFwdmlld2NoYW5nZWVuZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBib3VuZCA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG4gICAgICAgICAgICBsZXQgbGF0ID0gKGJvdW5kLmthICsgYm91bmQuamEpIC8gMjtcclxuICAgICAgICAgICAgbGV0IGxuZyA9IChib3VuZC5nYSArIGJvdW5kLmhhKSAvIDI7XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlld0NoYW5nZSBjZW50ZXIgXCIgKyBsYXQgKyBcIiBcIiArIGxuZyk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnZpZXdDaGFuZ2UoX21hcC5nZXRab29tKCksIFtsYXQsIGxuZ10pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIGtleWJvYXJkIHdoaWxlIG1vdXNlIGluIG1hcCAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBsZXQga3VwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9rZXkuY3RybCA9IGZhbHNlO1xyXG4gICAgICAgIF9rZXkuc2hpZnQgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LmFsdCA9IGZhbHNlO1xyXG4gICAgICAgIF9rZXkua2V5ID0gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IGtkb3duID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBfa2V5LmN0cmwgPSAoKGUua2V5ID09IFwiQ29udHJvbFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiQ29udHJvbFwiKSB8fCAoZS5jdHJsS2V5ID09IHRydWUpKTtcclxuICAgICAgICBfa2V5LnNoaWZ0ID0gKChlLmtleSA9PSBcIlNoaWZ0XCIpIHx8IChlLmtleUlkZW50aWZpZXIgPT0gXCJTaGlmdFwiKSB8fCAoZS5zaGlmdEtleSA9PSB0cnVlKSk7XHJcbiAgICAgICAgX2tleS5hbHQgPSAoKGUua2V5ID09IFwiQWx0XCIpIHx8IChlLmtleUlkZW50aWZpZXIgPT0gXCJBbHRcIikgfHwgKGUuc2hpZnRLZXkgPT0gdHJ1ZSkpO1xyXG4gICAgICAgIF9rZXkua2V5ID0gZS5rZXk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmtleURvd24pIHNldHRpbmdzLmtleURvd24oX2tleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWFwIG1vdXNlIGVudGVyXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIm1hcCBwb2ludGVyIGVudGVyXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXAgbW91c2UgbGVhdmVcIik7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2Rvd24pO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrdXApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqICAgICAgICAgICB0byBoYW5kbGUgZG91YmxlIGNsaWNrICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmx0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuTWFya2VyKSByZXR1cm47IC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIGNsaWNrIG9uIG1hcmtlclxyXG5cclxuICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZXYuY3VycmVudFBvaW50ZXIuYnV0dG9uO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5kYkNsaWNrICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogc2V0dGluZ3MuZGJDbGljayhjb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogc2V0dGluZ3MuZGJDbGljayhjb29yZE8yQShjb29yZCksIFwicmlnaHRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogICAgICAgICAgIHRvIGhhbmRsZSBzaW1wbGUgY2xpY2sgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG5cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuTWFya2VyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgIGxldCBidXR0b24gPSBldi5jdXJyZW50UG9pbnRlci5idXR0b247XHJcblxyXG4gICAgICAgIGlmICgoYnV0dG9uID09IDApICYmIChzZXR0aW5ncy5jbGlja0xlZnQpKVxyXG4gICAgICAgICAgICBzZXR0aW5ncy5jbGlja0xlZnQoY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgaWYgKChidXR0b24gPT0gMikgJiYgKHNldHRpbmdzLmNsaWNrUmlnaHQpKVxyXG4gICAgICAgICAgICBzZXR0aW5ncy5jbGlja1JpZ2h0KGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuY2xpY2sgIT0gXCJcIikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBzZXR0aW5ncy5jbGljayhjb29yZE8yQShjb29yZCksIFwibGVmdFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogc2V0dGluZ3MuY2xpY2soY29vcmRPMkEoY29vcmQpLCBcInJpZ2h0XCIsIF9rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKiAgZGlzYWJsZSB0aGUgZGVmYXVsdCBkcmFnZ2FiaWxpdHkgb2YgdGhlIHVuZGVybHlpbmcgbWFwIHdoZW4gc3RhcnRpbmcgdG8gZHJhZyBhIG1hcmtlciBvYmplY3QgKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSC5tYXAuTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGJlaGF2aW9yLmRpc2FibGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKiAgIHJlIC0gZW5hYmxlIHRoZSBkZWZhdWx0IGRyYWdnYWJpbGl0eSBvZiB0aGUgdW5kZXJseWluZyBtYXAgd2hlbiBkcmFnZ2luZyBoYXMgY29tcGxldGVkICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2VuZFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICBiZWhhdmlvci5lbmFibGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQuZHJhZ2dlZCAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgICAgICAodGFyZ2V0LmRyYWdnZWQpKHRhcmdldCwgY29vcmRPMkEoY29vcmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogIExpc3RlbiB0byB0aGUgZHJhZyBldmVudCBhbmQgbW92ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBhcyBuZWNlc3NhcnkgKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldCxcclxuICAgICAgICAgICAgcG9pbnRlciA9IGV2LmN1cnJlbnRQb2ludGVyO1xyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBtYXBzanMubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuc2V0UG9zaXRpb24oX21hcC5zY3JlZW5Ub0dlbyhwb2ludGVyLnZpZXdwb3J0WCwgcG9pbnRlci52aWV3cG9ydFkpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqICBkZXRlY3QgbWFwIHJlc2l6ZSBhbmQgYWRqdXN0IGFjY29yaWRuZ2x5ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfbWFwLmdldFZpZXdQb3J0KCkucmVzaXplKCk7XHJcblxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBsaXN0IG9mIGFsbCBhdmFpbGFibGUgbWFwIHN0eWxlcyBub3JtYWwuZGF5LCBuaWdodC4uLi4gXHJcbiAqIEBhbGlhcyBobTpnZXRBdmFpbGFibGVNYXBTdHlsZVxyXG4gKiBAcmV0dXJuIHtqc29ufSBsaXN0IG9mIG1hcCBzdHlsZXMgYXMganNvblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTWFwU3R5bGUoKSB7XHJcbiAgICAvLyBodHRwczovLzEuYmFzZS5tYXBzLmFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvP3hubHA9Q0xfSlNNdjMuMC4xNy4wJmFwcF9pZD1uT1NoMjEyMTRKRk1TRVBRa3FubyZhcHBfY29kZT1yWF9sN1l2QUx0TmtxVTJieDVGV0VBJm91dHB1dD1qc29uXHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgb3V0cHV0OiBcImpzb25cIlxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCIxLmJhc2UubWFwc1wiLCBcImFwaS5oZXJlLmNvbS9tYXB0aWxlLzIuMS9pbmZvXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgc2V0dGluZ3MpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcy5ib2R5LnJlc3BvbnNlO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogZGVmaW5lIHRoZSBzY2hlbWUuIExpc3Qgb2Ygc2NoZW1lIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHtobS5nZXRBdmFpbGFibGVNYXBTdHlsZSgpfVxyXG4gKiBAYWxpYXMgaG06c2V0U2NoZW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWUgc2NoZW1lIG5hbWVcclxuICovXHJcbmZ1bmN0aW9uIHNldFNjaGVtZShzY2hlbWUpIHtcclxuICAgIF9zY2hlbWUgPSBzY2hlbWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJDcmVhdGVcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgIC0gbmFtZSBvZiBsYXllclxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgIC0gaW5pdGlhbCBzdGF0dXNcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogaG0ubGF5ZXJDcmVhdGUoXCJsYXllcjFcIik7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyQ3JlYXRlKG5hbWUsIHZpc2libGUpIHtcclxuICAgIGdyb3VwID0gbmV3IEgubWFwLkdyb3VwKCk7XHJcbiAgICBncm91cC5uYW1lID0gbmFtZTtcclxuICAgIF9tYXAuYWRkT2JqZWN0KGdyb3VwKTtcclxuXHJcbiAgICAvLyBwdXNoIGludG8gbGlzdCBvZiBsYXllcnNcclxuICAgIF9sYXllcnMucHVzaChncm91cCk7XHJcblxyXG4gICAgLy8gY2FuIGJlIHZpc2libGUgb3IgaGlkZGVuXHJcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICBncm91cC5zZXRWaXNpYmlsaXR5KHZpc2libGUpO1xyXG5cclxuICAgIHJldHVybiBncm91cDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRlbGV0ZSBhIGxheWVyXHJcbiAqIEBhbGlhcyBobTpsYXllckRlbGV0ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIGxheWVyXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckRlbGV0ZShuYW1lKSB7XHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQobmFtZSk7XHJcbiAgICBpZiAoIWxheWVyKVxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICBsYXllci5uYW1lID0gbnVsbDtcclxuICAgIF9tYXAucmVtb3ZlT2JqZWN0KGxheWVyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVtcHR5IGEgbGF5ZXIsIGFjdHVhbGx5IGRlbGV0ZXMgaXQgYW5kIHJlY3JlYXRlIGl0XHJcbiAqIEBhbGlhcyBobTpsYXllckVtcHR5XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyRW1wdHkobmFtZSkge1xyXG4gICAgbGF5ZXJEZWxldGUobmFtZSk7XHJcbiAgICBsYXllckNyZWF0ZShuYW1lKTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBmaW5kIGxheWVyIGJ5IGl0cyBuYW1lIG9yIHJldHVybiBudWxsIFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJGaW5kXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJGaW5kKG5hbWUpIHtcclxuICAgIGxldCBsID0gX2xheWVycy5maW5kKGxheWVyID0+IHtcclxuICAgICAgICByZXR1cm4gbGF5ZXIubmFtZSA9PSBuYW1lO1xyXG4gICAgfSk7XHJcbiAgICBpZiAodHlwZW9mIGwgPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gbDtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBzZXQgY2VudGVyIG9mIHRoZSBtYXBcclxuKiBAYWxpYXMgaG06c2V0Q2VudGVyXHJcbiAqIEBwYXJhbSB7QXJyYXl9IC0gY29vcmQgYXMgW2xhdCxsbmddXHJcbiAqICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogaG0uc2V0Q2VudGVyKFs0OC44LDIuM10pO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRDZW50ZXIoY29vcmQpIHtcclxuICAgIF9tYXAuc2V0Q2VudGVyKGNvb3JkQTJPKGNvb3JkKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXBcclxuICogQGFsaWFzIGhtOmdldENlbnRlclxyXG4gKiBAcmV0dXJucyB7Y29vcmR9IGNvb3JkIG9mIHRoZSBjZW50ZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2VudGVyKCkge1xyXG4gICAgbGV0IGJvdW5kID0gX21hcC5nZXRWaWV3Qm91bmRzKCk7XHJcbiAgICAvL19ITS5sb2coXCJ2aWV3Ym91bmRcIixib3VuZCk7XHJcblxyXG4gICAgbGV0IGxuZyA9IChib3VuZC5nYSArIGJvdW5kLmhhKSAvIDI7XHJcbiAgICBsZXQgbGF0ID0gKGJvdW5kLmthICsgYm91bmQuamEpIC8gMjtcclxuICAgIHJldHVybiBbbGF0LCBsbmddO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiBib3VuZGluZyBib3ggb2YgdmlzaWJsZSBwYXJ0IG9mIG1hcFxyXG4gKiBAYWxpYXMgaG06Z2V0Vmlld0JCXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IGJvdWRpbmcgYm94IG9mIHZpc2libGUgcGFydCBvZiB0aGUgbWFwLCBhcyBcXFtsYXRtLGxhdE0sbG9uZ20sbG5nTVxcXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Vmlld0JCKCkge1xyXG4gICAgbGV0IGJiID0gX21hcC5nZXRWaWV3Qm91bmRzKCk7XHJcblxyXG4gICAgbGV0IGJiMiA9IHtcclxuICAgICAgICBsYXRtOiBiYi5qYSxcclxuICAgICAgICBsYXRNOiBiYi5rYSxcclxuICAgICAgICBsbmdtOiBiYi5nYSxcclxuICAgICAgICBsbmdNOiBiYi5oYVxyXG4gICAgfTtcclxuICAgIHJldHVybiBiYjI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzZXRzIGJvdWRpbmcgYm94IHRvIGJlIGRpc3BsYXllZFxyXG4gKiBAYWxpYXMgaG06c2V0Vmlld0JCXHJcbiAqIEBwYXJhbSBvcHQge09iamVjdHwgc3RyaW5nfSAgZWl0aGVyIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGhvdyB0byBzZXQgYm91bmRpbmcgYm94LCBvciAgYSBTdHJpbmcgYmVpbmcgdGhlIG5hbWUgb2YgYSBsYXllclxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge3N0cmluZ30gYm91ZGluZyBib3ggYXJvdWQgYWxsIG9iamVjdHMgb2YgdGhlIGxheWVyXHJcbiAqIEBwYXJhbSBbb3B0LnBvaXNdIHthcnJheX0gYm91ZGluZyBib3ggYXJvdWQgYWxsIGNvb3JkcyBkZWZpbmVkIGFzIFxcW2Nvb3JkLGNvb3JkLi4uXFxdXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAgKiBobS5zZXRWaWV3QkIoXCJsYXllcjFcIik7XHJcbiAqXHJcbiAqIGhtLnNldFZpZXdCQih7XHJcbiAgICAqICAgIHBvaXM6IGNvb3Jkc1xyXG4gICAgKiB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Vmlld0JCKG9wdCkge1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0ID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgb3B0ID0geyBsYXllcjogb3B0IH07XHJcblxyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBudWxsLFxyXG4gICAgICAgIHBvaXM6IG51bGwgLy8gYXJyYXkgb2YgW2xhdCxsbmddXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgYmJveDtcclxuXHJcbiAgICAvL3NldCBCQiBiYXNlZCBvbiBsYXllclxyXG4gICAgaWYgKHNldHRpbmdzLmxheWVyKSB7XHJcbiAgICAgICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgICAgICBpZiAoIWxheWVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vIGdldCB2aWV3IGJvdW5kIGFuZCBhZGQgYSBiaXQgYXJvdW5kLCBsaWtlIDEvNVxyXG4gICAgICAgIGxldCBiYiA9IGxheWVyLmdldEJvdW5kcygpO1xyXG4gICAgICAgIGlmICghYmIpIC8vIGFzIGlmIG5vdGhpbmcgaW4gbGF5ZXJcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGJiLmxhdG0gPSBiYi5qYTtcclxuICAgICAgICBiYi5sYXRNID0gYmIua2E7XHJcbiAgICAgICAgYmIubG5nbSA9IGJiLmdhO1xyXG4gICAgICAgIGJiLmxuZ00gPSBiYi5oYTtcclxuICAgICAgICBsZXQgZHggPSBiYi5sbmdNIC0gYmIubG5nbTtcclxuICAgICAgICBsZXQgZHkgPSBiYi5sYXRNIC0gYmIubGF0bTtcclxuICAgICAgICBkeCA9IGR4IC8gNTtcclxuICAgICAgICBkeSA9IGR5IC8gNTtcclxuICAgICAgICBiYi5sYXRNICs9IGR5O1xyXG4gICAgICAgIGJiLmxuZ20gLT0gZHg7XHJcbiAgICAgICAgYmIubGF0bSAtPSBkeTtcclxuICAgICAgICBiYi5sbmdNICs9IGR4O1xyXG4gICAgICAgIGJib3ggPSBuZXcgSC5nZW8uUmVjdChiYi5sYXRNLCBiYi5sbmdtLCBiYi5sYXRtLCBiYi5sbmdNKTtcclxuICAgICAgICBfbWFwLnNldFZpZXdCb3VuZHMoYmJveCwgdHJ1ZSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGVsc2UgaWYgKHNldHRpbmdzLnBvaXMpIHtcclxuICAgICAgICBsZXQgYmIgPSB7XHJcbiAgICAgICAgICAgIGxhdE06IDAsXHJcbiAgICAgICAgICAgIGxuZ206IDE4MCxcclxuICAgICAgICAgICAgbGF0bTogOTAsXHJcbiAgICAgICAgICAgIGxuZ006IC0xODAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgYXJyID0gc2V0dGluZ3MucG9pcztcclxuICAgICAgICBhcnIuZm9yRWFjaCgocG9pKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwb2lbMF0gPiBiYi5sYXRNKSBiYi5sYXRNID0gcG9pWzBdO1xyXG4gICAgICAgICAgICBpZiAocG9pWzFdID4gYmIubG5nTSkgYmIubG5nTSA9IHBvaVsxXTtcclxuICAgICAgICAgICAgaWYgKHBvaVswXSA8IGJiLmxhdG0pIGJiLmxhdG0gPSBwb2lbMF07XHJcbiAgICAgICAgICAgIGlmIChwb2lbMV0gPCBiYi5sbmdtKSBiYi5sbmdtID0gcG9pWzFdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJib3ggPSBuZXcgSC5nZW8uUmVjdChiYi5sYXRNLCBiYi5sbmdtLCBiYi5sYXRtLCBiYi5sbmdNKTtcclxuICAgICAgICBfbWFwLnNldFZpZXdCb3VuZHMoYmJveCwgdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogcmV0dXJuIHpvb20gdmFsdWVcclxuICogQGFsaWFzIGhtOmdldFpvb21cclxuICogQHJldHVybnMge251bWJlcn0gem9vbSBsZXZlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Wm9vbSgpIHtcclxuICAgIHJldHVybiBfbWFwLmdldFpvb20oKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHNldCB6b29tIGxldmVsXHJcbiAqIEBhbGlhcyBoZXJlbWFwOnNldFpvb21cclxuICogQHBhcmFtIHtudW1iZXJ9IHpvb20gXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRab29tKHpvb20pIHtcclxuICAgIF9tYXAuc2V0Wm9vbSh6b29tKTtcclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlIGFuIGljb24sIHRvIGJlIHVzZWQgZm9yIGEgbWFya2VyXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06YnVpbGRJY29uXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBzcGVjaWZ5IHRoZSBpY29uXHJcbiAqIEBwYXJhbSBbb3B0LmltZ10ge3N0cmluZ30gIHVzZSBhIHBuZy9qcGcgaW1hZ2UuIFNwZWNpZnkgdGhlIHVybCBcclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgdXJsIGEgc3ZnLiBUaGlzIGNhbiBiZSBhbiBpbmxpbmUgc3ZnLCBhIHVybCwgb3IgYSBzdmcgZnJvbSBoZXJlbWFwXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdF0ge29iamVjdH0gICBzdHlsZSBvYmplY3RcclxuICogQHBhcmFtIFtvcHQub3B0LnNpemVdIHtudW1iZXJ8c3RyaW5nfSAgIHNpemUgb2YgaWNvbiwgYXMgMjQgb3IgMjR4MzJcclxuICogQHBhcmFtIFtvcHQub3B0LmFuY2hvcl0ge251bWJlcnxzdHJpbmd9ICAgYW5jaG9yIG9mIGljb24sIGFzIDI0IG9yIDI0eDMyLiBCeSBkZWZhdWx0LCBib3R0b20tY2VudGVyXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC50YWddIHtzdHJpbmd9ICAgZm9yIHN2ZywgYW55IHRhZyBsaWtle3RhZ30uIHdpbGwgYmUgcmVwbGFjZWQgYnkgYXNzb2NpYXRlZCB2YWx1ZVxyXG4gKiBAcmV0dXJuIHtILm1hcC5JY29ufSB0aGUgY3JlYXRlZCBpY29uXHJcbiAqIEBleGFtcGxlIFxyXG4gKiBgYGBqc1xyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBpbWc6IFwiaHR0cDovL3doYXRldmVyLmNvbS9pbWFnZS5wbmdcIixcclxuICogICAgb3B0OiB7c2l6ZToyNH1cclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IFwiaHR0cDovL3doYXRldmVyLmNvbS9pbWFnZS5zdmdcIixcclxuICogICAgb3B0OiB7XHJcbiAqICAgICAgIHNpemU6MjQsXHJcbiAqICAgICAgIGFuY2hvcjoyNHgzMlxyXG4gKiAgICB9XHJcbiAqIH0pO1xyXG4gKiAgXHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2ZzogXCJzdmcvY2x1c3Rlci5zdmdcIixcclxuICogICAgb3B0OiB7XHJcbiAqICAgICAgIHNpemU6MjQsXHJcbiAqICAgICAgIGNvbG9yOlwicmVkXCJcclxuICogICAgfVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGNvbnN0IHN2ZyA9IGA8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4gPGVsbGlwc2Ugc3Ryb2tlPVwibnVsbFwiIHJ5PVwiOFwiIHJ4PVwiNy42MTg4OTZcIiBpZD1cInN2Z18xXCIgY3k9XCI4XCIgY3g9XCI3LjgzNzQyN1wiIGZpbGw9XCJ7Y29sb3J9XCIgZmlsbC1vcGFjaXR5PVwiMC45XCIvPjwvc3ZnPmA7XHJcbiAqIGhtLmJ1aWxkSWNvbih7XHJcbiAqICAgIHN2Zzogc3ZnLFxyXG4gKiAgICBvcHQ6IHtcclxuICogICAgICAgc2l6ZToyNCxcclxuICogICAgICAgY29sb3I6XCJyZWRcIlxyXG4gKiAgICB9IFxyXG4gKiB9KTtcclxuICogIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gYnVpbGRJY29uKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGltZzogbnVsbCwgICAgICAgICAgICAgLy8gICBwbmcsIGpwZy4gaWYgbm90IGh0dHAgaW4gdGhlIGJlZ2lubmluZywgbG9vayBsb2NhbGx5XHJcbiAgICAgICAgc3ZnOiBudWxsLCAgICAgICAgICAgICAvLyBzdmcgZmlsZTogIGlzIGEgdXJsIG9yIGEgc3RyaW5nXHJcbiAgICAgICAgb3B0OiBudWxsLCAgICAgICAgICAgICAgLy8gc2l6ZSwgY29sb3IsIGFuY2hvciwgdGV4dC4uLnNcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmltZyAmJiAhc2V0dGluZ3Muc3ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGljb24sIGljb25TcmM7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmltZykge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwic2V0dGluZ3MuaW1nXCIsIHNldHRpbmdzLmltZyk7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbWcuc3Vic3RyKDAsIDQpID09IFwiaHR0cFwiKSAvLyB1cmxcclxuICAgICAgICAgICAgaWNvblNyYyA9IHNldHRpbmdzLmltZztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGljb25TcmMgPSBjbS5nZXRQcm90b2NvbCgpICsgc2V0dGluZ3MuaW1nOyAvLyBsb2NhbCBmaWxlXHJcblxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2V0dGluZ3Muc3ZnKSB7XHJcblxyXG4gICAgICAgIGxldCB1cmwgPSBudWxsO1xyXG4gICAgICAgIGljb25TcmMgPSBzZXR0aW5ncy5zdmc7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnN2Zy5zdWJzdHIoMCwgNCkgPT0gXCJodHRwXCIpIC8vIHVybFxyXG4gICAgICAgICAgICB1cmwgPSBzZXR0aW5ncy5zdmc7XHJcbiAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3Muc3ZnLnN1YnN0cigwLCA0KSA9PSBcIjxzdmdcIikgLy8gdXJsXHJcbiAgICAgICAgICAgIHVybCA9IG51bGw7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB1cmwgPSBjbS5nZXRIb21lKCkgKyBzZXR0aW5ncy5zdmc7IC8vbWlzc2luZyBwcm90b2NvbCwgbm90IGFuIGVtYmVkZGVkIHN0cmluZywgbG9vayBpbiBsb2NhbCBoZXJlbWFwIG1vZHVsZVxyXG5cclxuICAgICAgICBpZiAodXJsKSAvLyBhbiB1cmwgdG8gZG93bmxvYWRcclxuICAgICAgICAgICAgaWNvblNyYyA9IGF3YWl0IGZldGNoKHVybClcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT0gMjAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpY29uT3B0ID0geyBjcm9zc09yaWdpbjogdHJ1ZSB9OyAvLyB0byBhdm9pZCBpc3N1ZWQgd2l0aCBjYXB0dXJlXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5zaXplKSB7XHJcbiAgICAgICAgbGV0IHcsIGg7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5vcHQuc2l6ZSA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB3ID0gaCA9IHNldHRpbmdzLm9wdC5zaXplO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgW3csIGhdID0gc2V0dGluZ3Mub3B0LnNpemUuc3BsaXQoXCJ4XCIpO1xyXG5cclxuICAgICAgICBpY29uT3B0LnNpemUgPSB7IHc6IHcsIGg6IGggfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0ICYmIHNldHRpbmdzLm9wdC5hbmNob3IpIHtcclxuICAgICAgICBsZXQgdywgaDtcclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLm9wdC5hbmNob3IgPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgdyA9IGggPSBzZXR0aW5ncy5vcHQuYW5jaG9yO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgW3csIGhdID0gc2V0dGluZ3Mub3B0LmFuY2hvci5zcGxpdChcInhcIik7XHJcbiAgICAgICAgaWNvbk9wdC5hbmNob3IgPSBuZXcgSC5tYXRoLlBvaW50KHcsIGgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsbCBvdGhlciBmaWVsZHMgYXJlIHRyZWF0ZWQgYXMgZ3JhcGhpYyBlbmhhbmNlZW50XHJcbiAgICBpZiAoc2V0dGluZ3Mub3B0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzZXR0aW5ncy5vcHQpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJmaWxlXCIgfHwgbmFtZSA9PSBcInNpemVcIiB8fCBuYW1lID09IFwiYW5jaG9yXCIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwie1wiICsgbmFtZSArIFwifVwiLCBcImdcIik7XHJcbiAgICAgICAgICAgIGljb25TcmMgPSBpY29uU3JjLnJlcGxhY2UocmUsIHNldHRpbmdzLm9wdFtuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnNvbGUubG9nKFwiaWNvblNyY1wiLCBpY29uU3JjKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwiaWNvbk9wdFwiLCBpY29uT3B0KTtcclxuICAgIGljb24gPSBuZXcgSC5tYXAuSWNvbihpY29uU3JjLCBpY29uT3B0KTtcclxuXHJcbiAgICByZXR1cm4gaWNvbjtcclxuXHJcbn0gLy9lbmQgb2YgaWNvblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBhZGQgYSBtYXJrZXIgaW4gYSBsYXllclxyXG4gKiBzdmcgZmlsZXMgY2FuIGJlIGNyZWF0ZWQgd2l0aCBodHRwczovL2VkaXRvci5tZXRob2QuYWMvIFxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOm1hcmtlclxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBtYXJrZXJcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9ICAgbGF5ZXIgbmFtZVxyXG4gKiBAcGFyYW0gW29wdC5jb29yZF0ge2Nvb3JkfSAgIGNvb3JkIG9mIHRoZSBtYXJrZXIgYXMgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gW29wdC5pY29uXSB7c3RyaW5nfSAgIGNyZWF0ZWQgZnJvbSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQuc3ZnXSB7c3RyaW5nfSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIFtvcHQub3B0XSB7T2JqZWN0fSAgIHNlZSBobS5idWlsZEljb25cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJlbnRlciAgaWYgZW50ZXIsIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LnBvaW50ZXJDbGljayAgaWYgY2xpY2ssIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICogQHBhcmFtIHtzdHJpbmd9IG9wdC5kYXRhICBvcHRpb25hbCBkYXRhXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0LmJ1YmJsZSAgaWYgdHJ1ZSwgc2hvdyBidWJsZSBvbiBjbGljayB3aXRoIGRhdGFcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuZHJhZ2dhYmxlICBkcmFnZ2FibGUgbWFya2VyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdC5kcmFnZ2VkICBpZiBkcmFnZ2VkLCBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAqIEBleGFtcGxlIFxyXG4gKiBgYGBqc1xyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXSxcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gICAgKiAgIHN2ZzogXCJzdmcvbWFya2VyLnN2Z1wiLFxyXG4gICAgKiAgIGNvbG9yOlwicmVkXCIsXHJcbiAgICAqICAgc2l6ZToxNlxyXG4gICAgKiB9KTtcclxuICAgICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGltZzogXCJodHRwOi8vd2hhdGV2ZXIuY29tL2ltYWdlLnBuZ1wiLFxyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXVxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiAgICBkYXRhOlwiSGVsbG8gd29ybGRcIixcclxuICogICAgYnViYmxlOiB0cnVlXHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0ubWFya2VyKHtcclxuICogICAgY29vcmQ6IFs0OC44LDIuM10sXHJcbiAqICAgIGRyYWdnYWJsZTp0cnVlLFxyXG4gKiAgICBkcmFnZ2VkOiBmdW5jdGlvbih0YXJnZXQsY29vcmQpIHtjb25zb2xlLmxvZyhcImRyYWdnZWQgdG9cIixjb29yZCk7fVxyXG4gKiB9KTtcclxuKiAgYGBgXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBtYXJrZXIob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLCAgICAgICAvLyAgbGF5ZXIgaW4gd2hpY2ggdG8gYWRkIG1hcmtlclxyXG4gICAgICAgIGNvb3JkOiBudWxsLCAgICAgICAgICAgIC8vICBjb29yZCBvZiB0aGUgbWFya2VyXHJcbiAgICAgICAgaW1nOiBudWxsLCAgICAgICAgICAgICAvLyAgaW1hZ2UgY2FuIGJlIHVybCwgcG5nLCBqcGcuLlxyXG4gICAgICAgIHN2ZzogbnVsbCwgICAgICAgICAgICAgLy8gc3ZnIGZpbGVcclxuICAgICAgICBpY29uOiBudWxsLCAgICAgICAgICAgICAgLy8gaWNvbiBwcmV2aW91c2x5IGNyZWF0ZWRcclxuICAgICAgICBvcHQ6IHt9LCAgICAgICAgICAgICAgIC8vIG9wdCBmb3IgaWNvblxyXG4gICAgICAgIHBvaW50ZXJFbnRlcjogbnVsbCwgICAgIC8vICBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXYpXHJcbiAgICAgICAgcG9pbnRlckNsaWNrOiBudWxsLCAgICAgLy8gIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICAgICAgICBkYXRhOiBudWxsLCAgICAgICAgICAgICAvLyAgdXNlciBkYXRhXHJcbiAgICAgICAgYnViYmxlOiBmYWxzZSwgICAgICAgICAgLy8gIHNob3cgYSBidWJibGUgd2l0aCB1c2VyIGRhdGFcclxuICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLCAgICAgICAvLyAgaWNvbiBpcyBkcmFnZ2FsYmVcclxuICAgICAgICBkcmFnZ2VkOiBudWxsICAgICAgICAgICAvLyAgY2FsbGJhY2sodGFyZ2V0LGNvb3JkKVxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR0aW5ncy5jb29yZCA9IHsgbGF0OiBzZXR0aW5ncy5jb29yZFswXSwgbG5nOiBzZXR0aW5ncy5jb29yZFsxXSB9O1xyXG5cclxuICAgIC8vIHRoZXNlIHBhcmFtZXRlcnMgY2FuIGJlIGluIG9wdC5vcHQgb3IgZGlyZWN0bHkgaW4gb3B0XHJcbiAgICBpZiAoc2V0dGluZ3MuY29sb3IpIHNldHRpbmdzLm9wdC5jb2xvciA9IHNldHRpbmdzLmNvbG9yO1xyXG4gICAgaWYgKHNldHRpbmdzLnNpemUpIHNldHRpbmdzLm9wdC5zaXplID0gc2V0dGluZ3Muc2l6ZTtcclxuICAgIGlmIChzZXR0aW5ncy5hbmNob3IpIHNldHRpbmdzLm9wdC5zaXplID0gc2V0dGluZ3MuYW5jaG9yO1xyXG5cclxuICAgIGxldCBtYXJrZXJPcHQgPSBudWxsO1xyXG4gICAgaWYgKHNldHRpbmdzLmltZyB8fCBzZXR0aW5ncy5zdmcpIHtcclxuICAgICAgICBsZXQgaWNvbiA9IGF3YWl0IGJ1aWxkSWNvbihzZXR0aW5ncyk7XHJcbiAgICAgICAgbWFya2VyT3B0ID0geyBpY29uOiBpY29uIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzZXR0aW5ncy5pY29uKSB7XHJcbiAgICAgICAgbWFya2VyT3B0ID0geyBpY29uOiBzZXR0aW5ncy5pY29uIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIm1hcmtlciBzZXR0aW5ncy5jb29yZFwiLCBzZXR0aW5ncy5jb29yZCk7XHJcbiAgICBsZXQgbWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihzZXR0aW5ncy5jb29yZCwgbWFya2VyT3B0KTtcclxuXHJcbiAgICBtYXJrZXIuZHJhZ2dhYmxlID0gc2V0dGluZ3MuZHJhZ2dhYmxlO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kcmFnZ2VkKSBtYXJrZXIuZHJhZ2dlZCA9IHNldHRpbmdzLmRyYWdnZWQ7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmRhdGEpXHJcbiAgICAgICAgbWFya2VyLnNldERhdGEoc2V0dGluZ3MuZGF0YSk7XHJcblxyXG4gICAgLy8gZ2V0IGNsaWNrIGZyb20gbW91c2VcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKiAgY2FsbGJhY2sgd2hlbiBjbGljayBvbiBtYXJrZXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKSB7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKiAgc2hvdyBhIGJ1YmJsZSB3aGVuIGNsaWNraW5nIG9uIG1hcmtlciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGlmIChzZXR0aW5ncy5idWJibGUpIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcblxyXG4gICAgICAgICAgICBidWJibGVVbmlxdWUoY29vcmRPMkEoY29vcmQpLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QobWFya2VyKTtcclxuICAgIHJldHVybiBtYXJrZXI7XHJcblxyXG59IC8vZW5kIG9mIG1hcmtlclxyXG5cclxuLyoqXHJcbiAqIGRpc3BsYXkgYSB1bmlxdWUgYnViYmxlLiBBc3NvY2lhdGVkIENTUyBzdHlsZSBpcyAuSF9pYl9ib2R5XHJcbiAqIEBhbGlhcyBobTpidWJibGVVbmlxdWVcclxuICogQHBhcmFtIHtBcnJheX0gY29vcmQgb2YgdGhlIGJ1YmJsZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHh0IGh0bWwgdGV4dCB0byBkaXNwbGF5XHJcbiAqL1xyXG5mdW5jdGlvbiBidWJibGVVbmlxdWUoY29vcmQsIHR4dCkge1xyXG5cclxuICAgIGlmICghX2J1YmJsZU1hcmtlcikge1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIgPSBuZXcgSC51aS5JbmZvQnViYmxlKFxyXG4gICAgICAgICAgICBjb29yZEEyTyhjb29yZCksIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHR4dFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3VpLmFkZEJ1YmJsZShfYnViYmxlTWFya2VyKTtcclxuICAgICAgICBfYnViYmxlTWFya2VyLmFkZENsYXNzKFwiYnViYmxlVW5pcXVlXCIpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5zZXRQb3NpdGlvbihjb29yZEEyTyhjb29yZCkpO1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIuc2V0Q29udGVudCh0eHQpO1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIub3BlbigpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBoaWRlIGEgdW5pcXVlIGJ1YmJsZVxyXG4gKiBAYWxpYXMgaG06YnViYmxlVW5pcXVlSGlkZVxyXG4gKi9cclxuZnVuY3Rpb24gYnViYmxlVW5pcXVlSGlkZSgpIHtcclxuICAgIGlmICghX2J1YmJsZU1hcmtlcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICBfYnViYmxlTWFya2VyLmNsb3NlKCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEcmF3IGEgcG9seWxpbmUuIFxyXG4gKiBAYWxpYXMgaG06cG9seWxpbmVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSAgIG9wdGlvbnMgdG8gZHJhdyBwb2x5bGluZVxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge1N0cmluZ30gb3B0aW9uYWwgbGF5ZXIgdG8gdXNlIFxyXG4gKiBAcGFyYW0gW29wdC5jb29yZHNdIHthcnJheX0gYXJyYXkgb2YgY29vcmRzLCBhcyBcXFtcXFs0OC44LDIuM1xcXSxcXFs0OC44NSwyLjRcXF0sLi4uIFxcXVxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBzdHlsZVxyXG4gKiBAcGFyYW0gW29wdC5saW5lV2lkdGg9NF0ge251bWJlcn0gbGluZSB3aWR0aFxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5zdHJva2VDb2xvcj1yZ2JhKDAsIDEyOCwgMjU1LCAwLjcpXSB7c3RyaW5nfSBsaW5lIGNvbG9yXHJcbiAqIEBwYXJhbSBbb3B0LmFycm93c10ge29iamVjdH0gb3B0aW9uYWwgYXJyb3dcclxuICogQHBhcmFtIFtvcHQuZGF0YV0ge1N0cmluZ30gb3B0aW9uYWwgdXNlciBkYXRhXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJDbGlja10ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBjbGljayBvbiBsaW5lLiBmb3JtYXQgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2ZW50KVxyXG4gKiBAcGFyYW0gW29wdC5wb2ludGVyZW50ZXJdIHtmdW5jdGlvbn0gb3B0aW9uYWwgY2FsbGJhY2sgaWYgbW91c2UgZW50ZXJzIG9uIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJMZWF2ZV0ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBtb3VzZSBsZWF2ZXMgdGhlIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnpdIHtudW1iZXJ9IG9wdGlvbmFsIHogbGV2ZWxcclxuKiBgYGBqc1xyXG4qIGhtLnBvbHlsaW5lKHtcclxuICAgICogICAgY29vcmRzOiBbWzQ4LjgsMi4zXSxbNDguODUsMi40XSxbNDguOSwyLjZdXSxcclxuICAgICogICAgbGF5ZXI6XCJsYXllcjFcIlxyXG4gICAgKiB9KTtcclxuICAgICogXHJcbiAgICAqIGhtLnBvbHlsaW5lKHtcclxuICAgICogICAgY29vcmRzOiBjb29yZHMsXHJcbiAgICAqICAgIHN0eWxlOiB7XHJcbiAgICAqICAgICAgICBsaW5lV2lkdGg6IDQsXHJcbiAgICAqICAgICAgICBzdHJva2VDb2xvcjogXCJyZWRcIlxyXG4gICAgKiAgICB9LFxyXG4gICAgKiB9KTtcclxuICAgICogXHJcbiAgICAqIGhtLnBvbHlsaW5lKHtcclxuICAgICAgICAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gICAgICAgICogICAgZGF0YTpcIkhlbGxvIFdvcmxkXCIsXHJcbiAgICAgICAgKiB9KTtcclxuICAgICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWxpbmUob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkczogbnVsbCwgLy8gY29vcmRzIGlzIGxpc3Qgb2YgYXJyYXkgb2YgW2xhdCxsbmddIG9yIGFycmF5IG9mIG9iamVjdCB3aXRoIHtsYXQ6LGxuZzp9XHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgbGluZVdpZHRoOiA0LFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMjU1LCAwLjcpXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFycm93czogbnVsbCxcclxuICAgICAgICBkYXRhOiBudWxsLCAgICAgICAgIC8vIG9wdGlvbmFsIHVzZXIgZGF0YSBcclxuICAgICAgICB6OiBudWxsLFxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgLy8gY2xpY2tcclxuICAgICAgICBwb2ludGVyRW50ZXI6IG51bGwsIC8vIGNhbGwgYmFja1xyXG4gICAgICAgIHBvaW50ZXJMZWF2ZTogbnVsbCAvLyBjYWxsIGJhY2tcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5jb29yZHMpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlBvbHlsaW5lOiBjb29yZHMgbm90IGZvdW5kOlwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdHJpcCA9IG5ldyBILmdlby5TdHJpcCgpO1xyXG5cclxuICAgIHNldHRpbmdzLmNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHN0cmlwLnB1c2hMYXRMbmdBbHQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBwb2x5bGluZSA9IG5ldyBILm1hcC5Qb2x5bGluZShzdHJpcCwge1xyXG4gICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZSxcclxuICAgICAgICBkYXRhOiBzZXR0aW5ncy5kYXRhLFxyXG4gICAgICAgIGFycm93czogc2V0dGluZ3MuYXJyb3dzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBaIGluZGV4XHJcbiAgICBpZiAoc2V0dGluZ3MueikgcG9seWxpbmUuc2V0WkluZGV4KHNldHRpbmdzLnopO1xyXG4gICAgLy8gdXNlciBkYXRhXHJcbiAgICBpZiAoc2V0dGluZ3MuZGF0YSkgcG9seWxpbmUuc2V0RGF0YShzZXR0aW5ncy5kYXRhKTtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckVudGVyKVxyXG4gICAgICAgIHBvbHlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyTGVhdmUpXHJcbiAgICAgICAgcG9seWxpbmUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJMZWF2ZSh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJDbGljaylcclxuICAgICAgICBwb2x5bGluZS5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KHBvbHlsaW5lKTtcclxuXHJcbiAgICByZXR1cm4gcG9seWxpbmU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogRHJhdyBhIHBvbHlnb25cclxuICogQGFsaWFzIGhtOnBvbHlnb25cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdCAgb3B0aW9ucyB0byBkcmF3IGEgcG9seWdvbi4gU2FtZSBvcHRpb25zIGFzIGhtLnBvbHlsaW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZHM6IFwiXCIsIC8vIGNvb3JkcyBpcyBhcnJheSBvZiBbbGF0LGxuZ10gb3IgYXJyYXkgb2Yge2xhdDosbG5nOn1cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDQsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBcInJnYmEoMCwgMTI4LCAyNTUsIDAuNylcIixcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAyNTUsIDAuNylcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGVIb3ZlcjogbnVsbCwgLy8gc3R5bGUgc2kgbW91c2Ugb3ZlclxyXG4gICAgICAgIGFycm93czogbnVsbCxcclxuICAgICAgICBkYXRhOiBudWxsLCAvLyBhZGRpdGlvbmFsIGRhdGEgdG8gY2FycnlcclxuICAgICAgICB6OiBudWxsLFxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgLy8gY2xpY2tcclxuICAgICAgICBwb2ludGVyRW50ZXI6IG51bGwsIC8vIGNhbGwgYmFja1xyXG4gICAgICAgIHBvaW50ZXJMZWF2ZTogbnVsbCAvLyBjYWxsIGJhY2tcclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNvb3Jkcykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUG9seWxpbmU6IGNvb3JkcyBub3QgZm91bmQ6XCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmlwID0gbmV3IEguZ2VvLlN0cmlwKCk7XHJcbiAgICBzZXR0aW5ncy5jb29yZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICBzdHJpcC5wdXNoTGF0TG5nQWx0KHBvaW50WzBdLCBwb2ludFsxXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgcG9seWdvbiA9IG5ldyBILm1hcC5Qb2x5Z29uKHN0cmlwLCB7XHJcbiAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlLFxyXG4gICAgICAgIGRhdGE6IHNldHRpbmdzLmRhdGEsXHJcbiAgICAgICAgYXJyb3dzOiBzZXR0aW5ncy5hcnJvd3NcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSBwb2x5Z29uLnNldERhdGEoc2V0dGluZ3MuZGF0YSk7XHJcbiAgICAvLyBaIGluZGV4XHJcbiAgICBpZiAoc2V0dGluZ3MueikgcG9seWxpbmUuc2V0WkluZGV4KHNldHRpbmdzLnopO1xyXG5cclxuICAgIC8vIHNpIHVuIHN0eWxlIGRlIGhvdmVyXHJcbiAgICBpZiAoc2V0dGluZ3Muc3R5bGVIb3Zlcikge1xyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldFN0eWxlKHNldHRpbmdzLnN0eWxlSG92ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldFN0eWxlKHNldHRpbmdzLnN0eWxlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckVudGVyKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckVudGVyKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckxlYXZlKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckxlYXZlKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KHBvbHlnb24pO1xyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59IC8vIGVuZCBvZiBwb2x5Z29uXHJcblxyXG4vKipcclxuICogZHJhdyBhIGNpcmNsZVxyXG4gKiBAYWxpYXMgaG06Y2lyY2xlXHJcbiAqIEBwYXJhbSBvcHQgeyp9ICAgb3B0aW9uIGZvciBjaXJjbGVcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtTdHJpbmd9IG9wdGlvbmFsIGxheWVyIHRvIHVzZSBcclxuICogQHBhcmFtIFtvcHQuY29vcmRdIHthcnJheX0gY2VudGVyIG9mIHRoZSBjaXJjbGUsIGFzIFxcWzQ4LjgsMi4zXFxdXHJcbiAqIEBwYXJhbSBbb3B0LnJhZGl1c10ge251bWJlcn0gcmFkaXVzIGluIG1ldGVyXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlXSB7b2JqZWN0fSBvcHRpb25hbCBncmFwaGljIHN0eWxlXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLnN0cm9rZUNvbG9yXSB7c3RyaW5nfSBjb2xvciBvZiBwZXJpbWV0ZXJcclxuICogQHBhcmFtIFtvcHQuc3R5bGUubGluZVdpZHRoXSB7bnVtYmVyfSBsaW5lIHdpZHRoXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLmZpbGxDb2xvcl0ge3N0cmluZ30gZmlsbCBjb2xvclxyXG4gKi9cclxuZnVuY3Rpb24gY2lyY2xlKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZDogbnVsbCxcclxuICAgICAgICByYWRpdXM6IDEwMCwgLy8gbWV0ZXJzXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSg1NSwgODUsIDE3MCwgMC4yKVwiLCAvLyBDb2xvciBvZiB0aGUgcGVyaW1ldGVyXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAwLCAwLjEpXCIgIC8vIENvbG9yIG9mIHRoZSBjaXJjbGVcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNpcmNsZSA9IG5ldyBILm1hcC5DaXJjbGUoXHJcbiAgICAgICAgLy8gVGhlIGNlbnRyYWwgcG9pbnQgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgIGNvb3JkQTJPKHNldHRpbmdzLmNvb3JkKSxcclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgaW4gbWV0ZXJzXHJcbiAgICAgICAgc2V0dGluZ3MucmFkaXVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QoY2lyY2xlKTtcclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiB3YXRjaCBwb3NpdGlvbiBvbiBIVE1MNSBwb3NpdGlvbi4gcmVxdWlyZXMgSFRUUFNcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpsb2NhdGVNZVxyXG4gKiBAcGFyYW0gY2FsbGJhY2sge2Z1bmN0aW9ufSAgY2FsbGJhY2sgd2hlbiBjb29yZCBjaGFuZ2VzLiBGb3JtYXQ6IGNhbGxiYWNrKGNvb3JkLGFjY3VyYWN5KSBcclxuICogQHBhcmFtIG9wdCB7T2JqZWN0fSBvcHRpb25hbCBncmFwaGljIG9wdGlvbnNcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb25dIHtvYmplY3R9ICBncmFwaGljIG9wdGlvbnMgZm9yIGNlbnRlci4gU2VlIGJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5zdmddIHtzdHJpbmd9ICBzdmcgZmlsZVxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5jb2xvcl0ge3N0cmluZ30gIGNvbG9yIGZvciAge2NvbG9yfSB0YWdcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uc2l6ZV0ge251bWJlcn0gIHNpemUgb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5hbmNob3JdIHtudW1iZXJ9ICBhbmNob3Igb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeV0ge29iamVjdH0gIGdyYXBoaWMgb3B0aW9ucyBmb3IgYWNjdXJhY3kgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kuc3Ryb2tlQ29sb3JdIHtTdHJpbmd9ICBjb2xvciBvZiBjaXJjbGUgbGluZSByZXByZXNlbnRpbmcgYWNjdXJhY3kgYXJlYVxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeS5saW5lV2lkdGhdIHtudW1iZXJ9ICB3aWR0aCBvZiBsaW5lIG9mIGNpcmNsZVxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeS5maWxsQ29sb3JdIHtTdHJpbmd9ICBmaWxsIGNvbG9yIG9mIGNpcmNsZSByZXByZXNlbnRpbmcgYWNjdXJhY3kgYXJlYVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbG9jYXRlTWUoY2FsbGJhY2ssIG9wdCkge1xyXG5cclxuICAgIC8vIGlmIG5vIGNhbGxiYWNrLCByZW1vdmUgdGhlIHdhdGNoXHJcbiAgICBpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBfbG9jYXRlTWUpIHtcclxuICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2goX2xvY2F0ZU1lKTtcclxuICAgICAgICAgICAgX2xvY2F0ZU1lID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgc3ZnOiBcInN2Zy9jcm9zc2hhaXIuc3ZnXCIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMjQsXHJcbiAgICAgICAgICAgICAgICBhbmNob3I6IDEyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjY3VyYWN5OiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMCwgMC44KVwiLCAvLyBDb2xvciBvZiB0aGUgcGVyaW1ldGVyXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDAsIDAuNClcIiAgLy8gQ29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgICAgICBsZXQgaWNvbkNyb3NzSGFpciA9IGF3YWl0IGJ1aWxkSWNvbih7XHJcbiAgICAgICAgICAgIHN2Zzogc2V0dGluZ3MucG9zaXRpb24uc3ZnLFxyXG4gICAgICAgICAgICBpbWc6IHNldHRpbmdzLnBvc2l0aW9uLmltZyxcclxuICAgICAgICAgICAgb3B0OiBzZXR0aW5ncy5wb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy9uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKGZ1bmN0aW9uIHBvcyhwb3NpdGlvbikge1xyXG4gICAgICAgIF9sb2NhdGVNZSA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3BzID0gW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV07XHJcblxyXG4gICAgICAgICAgICBsYXllckVtcHR5KFwiX2dwc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNpcmNsZSBzaG93aW5nIHRoZSBhY2N1cmFjeSByYWRpdXMqL1xyXG4gICAgICAgICAgICBjaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IFwiX2dwc1wiLFxyXG4gICAgICAgICAgICAgICAgY29vcmQ6IGdwcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLmFjY3VyYWN5XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWFya2VyKHtcclxuICAgICAgICAgICAgICAgIGxheWVyOiBcIl9ncHNcIixcclxuICAgICAgICAgICAgICAgIGNvb3JkOiBncHMsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uQ3Jvc3NIYWlyXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soZ3BzLCBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kpO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gXCJcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlBFUk1JU1NJT05fREVOSUVEOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIlVzZXIgZGVuaWVkIHRoZSByZXF1ZXN0IGZvciBHZW9sb2NhdGlvbi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuUE9TSVRJT05fVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiTG9jYXRpb24gaW5mb3JtYXRpb24gaXMgdW5hdmFpbGFibGUuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlRJTUVPVVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwidGltZWQgb3V0LlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5VTktOT1dOX0VSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJIVE1MNSBsb2NhdGlvbiBlcnJvcjpcIiArIG1zZyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJubyBIVE1MNSBnZW9sb2NhdGlvbiBjYXBhYmlsaXRpZXNcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIGEgc2NyZWVuc2hvdCBvZiB0aGUgbWFwIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSBkYXRhXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bG9jYXRlTWVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBzY3JlZW5zaG90XHJcbiAqIEBwYXJhbSBbb3B0Lm5hbWVdIHtzdHJpbmd9IGZpbGVuYW1lIGZvciBkb3dubG9hZFxyXG4gKiBAcGFyYW0gW29wdC51aV0ge2Jvb2xlYW59IHRydWUgdG8gc2F2ZSB1aSAoc2NhbGUsIGV0Yy4uKVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIHNjcmVlbnNob3RcclxuICogXHJcbiAqIEByZXR1cm5zIHtkYXRhfSBiaW5hcnkgZGF0YSBvZiBpbWFnZVxyXG4gKiBcclxuICovXHJcbmZ1bmN0aW9uIHNjcmVlbnNob3Qob3B0KSB7XHJcbiAgICBsZXQgcGFyYSA9IG51bGw7XHJcbiAgICBpZiAob3B0ICYmIG9wdC51aSlcclxuICAgICAgICBwYXJhID0gW191aV07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFxyXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgX21hcC5jYXB0dXJlKGZ1bmN0aW9uIChjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FudmFzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJNYXAgc2NyZWVuc2hvdCBub3Qgc3VwcG9ydGVkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHQgJiYgb3B0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhyZWYgPSBkYXRhVVJMO1xyXG4gICAgICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5kb3dubG9hZCA9IG9wdC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVVJMKTtcclxuXHJcblxyXG4gICAgICAgICAgICB9LCBwYXJhKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE1hcCgpIHtcclxuICAgIHJldHVybiBfbWFwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRVSSgpIHtcclxuICAgIHJldHVybiBfdWk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29vcmRPMkE6IGNvb3JkTzJBLFxyXG4gICAgY29vcmRBMk86IGNvb3JkQTJPLFxyXG4gICAgZ2V0TWFwOiBnZXRNYXAsXHJcbiAgICBnZXRVSTogZ2V0VUksXHJcbiAgICBtYXA6IG1hcCxcclxuICAgIGdldEF2YWlsYWJsZU1hcFN0eWxlOiBnZXRBdmFpbGFibGVNYXBTdHlsZSxcclxuICAgIHNldFNjaGVtZTogc2V0U2NoZW1lLFxyXG4gICAgbGF5ZXJDcmVhdGU6IGxheWVyQ3JlYXRlLFxyXG4gICAgbGF5ZXJGaW5kOiBsYXllckZpbmQsXHJcbiAgICBsYXllckRlbGV0ZTogbGF5ZXJEZWxldGUsXHJcbiAgICBsYXllckVtcHR5OiBsYXllckVtcHR5LFxyXG4gICAgYnVpbGRJY29uOiBidWlsZEljb24sXHJcbiAgICBidWJibGVVbmlxdWU6IGJ1YmJsZVVuaXF1ZSxcclxuICAgIGJ1YmJsZVVuaXF1ZUhpZGU6IGJ1YmJsZVVuaXF1ZUhpZGUsXHJcbiAgICBtYXJrZXI6IG1hcmtlcixcclxuICAgIGNpcmNsZTogY2lyY2xlLFxyXG4gICAgcG9seWxpbmU6IHBvbHlsaW5lLFxyXG4gICAgcG9seWdvbjogcG9seWdvbixcclxuICAgIGdldENlbnRlcjogZ2V0Q2VudGVyLFxyXG4gICAgc2V0Q2VudGVyOiBzZXRDZW50ZXIsXHJcbiAgICBnZXRab29tOiBnZXRab29tLFxyXG4gICAgc2V0Wm9vbTogc2V0Wm9vbSxcclxuICAgIGdldHZpZXdCQjogZ2V0Vmlld0JCLFxyXG4gICAgc2V0Vmlld0JCOiBzZXRWaWV3QkIsXHJcbiAgICBsb2NhdGVNZTogbG9jYXRlTWUsXHJcbiAgICBzY3JlZW5zaG90OiBzY3JlZW5zaG90XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgcm91dGUgd2l0aCBvcHRpb25hbCB3YXlwb29pbnRzLiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiAgQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpyb3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIC0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIHtvYmplY3R9IGRlc3QgLSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSByb3V0ZSBvcHRpb25zIFxyXG4gKiBAcGFyYW0gW29wdC5tb2RlPWZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRdIHtzdHJpbmd9ICByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQucm91dGVhdHRyaWJ1dGVzPXdheXBvaW50cyxzdW1tYXJ5LHNoYXBlXSB7c3RyaW5nfSAgcm91dGUgYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0gW29wdC5tYW5ldXZlcmF0dHJpYnV0ZXM9ZGlyZWN0aW9uLGFjdGlvbl0ge3N0cmluZ30gIG1hbm9ldXZlciBhdHRyaWJ1dGVzXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IHJldHVybnMgeyBzdW1tYXJ5OiBvYmplY3QsIGNvb3JkczphcnJheSxyb3V0ZTogb2JqZWN0LCBib2R5Om9iamVjdH0uIGNvb3JkcyBpcyBhcnJheSBvZiBjb29yZCwgdG8gYmUgdXNlZCB3aXRoIGhtLnBvbHlsaW5lLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICAqIGBgYGpzXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLFs0OC43LDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTtcclxuICAqIFxyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoW1s0OC44LDIuM10sWzQ4LjksMi43XV0sIFs0OS4zLDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5yb3V0ZSk7IFxyXG4gICogXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLCBbWzQ4LjksMi43XSwgWzQ5LjMsMi41XV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTsgXHJcbiAgKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJvdXRlKHNvdXJjZSwgZGVzdCwgb3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIsXHJcbiAgICAgICAgcmVwcmVzZW50YXRpb246IFwibGlua1BhZ2luZ1wiLFxyXG4gICAgICAgIHJvdXRlYXR0cmlidXRlczogXCJ3YXlwb2ludHMsc3VtbWFyeSxzaGFwZVwiLFxyXG4gICAgICAgIG1hbmV1dmVyYXR0cmlidXRlczogXCJkaXJlY3Rpb24sYWN0aW9uXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgLy8gMSBzZXVsIHNvdXJjZSBvdSBhcnJheSBkZSBzb3VyY2UgP1xyXG4gICAgbGV0IGlkID0gMDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVswXSkpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHBhcmFtc1tcIndheXBvaW50XCIgKyBpZCsrXSA9IHNvdXJjZVswXSArIFwiLFwiICsgc291cmNlWzFdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RbMF0pKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gZGVzdFtpXTtcclxuICAgICAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBkZXN0WzBdICsgXCIsXCIgKyBkZXN0WzFdO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlcm91dGUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcmVzLmJvZHkucmVzcG9uc2Uucm91dGVbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSByb3V0ZS5zdW1tYXJ5O1xyXG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSByb3V0ZS5zaGFwZS5tYXAoKGxhdGxuZyA9PiBsYXRsbmcuc3BsaXQoXCIsXCIpKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBzdW1tYXJ5LCBjb29yZHM6IGNvb3Jkcywgcm91dGU6IHJvdXRlLCBib2R5OiByZXMuYm9keSB9O1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhbiBpc29saW5lLiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmlzb2xpbmVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb24gZm9yIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuc3RhcnRdIHtjb29yZH0gY29vcmQgZm9yIHN0YXJ0aW5nIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuZGVzdGluYXRpb25dIHtjb29yZH0gY29vcmQgZm9yIGRlc3RpbmF0aW9uIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQucmFuZ2VUeXBlPVwidGltZVwiXSB7c3RyaW5nfSB0aW1lIG9yIGRpc3RhbmNlXHJcbiAqIEBwYXJhbSBbb3B0LnJhbmdlXSB7bnVtYmVyfSByYW5nZSBpbiBzZWNvbmRzIG9yIGluIG1ldGVyc1xyXG4gKiBAcGFyYW0gW29wdC5tb2RlPVwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiXSB7U3RyaW5nfSByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQubGlua2F0dHJpYnV0ZXM9c2hdIHtTdHJpbmd9IGF0dHJpYnV0ZXMgdG8gYmUgcmV0dXJuZWRcclxuICogXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9ICByZXR1cm5zIHsgcG9seTphcnJheSwgYm9keTpvYmplY3QgfS4gUG9seSBpcyBhcnJheSBvZiBjb29yZHMsIGJvZHkgaXMgZnVsbCBhbnN3ZXJcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlzb2xpbmUob3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgc3RhcnQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBkaXJlY3QgaXNvbGluZVxyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmV2ZXJzZSBpc29saW5lXHJcbiAgICAgICAgcmFuZ2VUeXBlOiBcInRpbWVcIiwgICAgICAgICAgICAgICAgICAgICAgLy8gdGltZSBvciBkaXN0YW5jZVxyXG4gICAgICAgIHJhbmdlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBzZWNvbmRzIG9yIG1ldGVyc1xyXG4gICAgICAgIGxpbmthdHRyaWJ1dGVzOiBcInNoXCIsICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCB0aGUgc2hhcGVcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiwgICAvL3Nob3J0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkIFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhcnQpXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0ID0gXCJnZW8hXCIgKyBwYXJhbXMuc3RhcnRbMF0gKyBcIixcIiArIHBhcmFtcy5zdGFydFsxXTtcclxuICAgIGlmIChwYXJhbXMuZGVzdGluYXRpb24pXHJcbiAgICAgICAgcGFyYW1zLmRlc3RpbmF0aW9uID0gXCJnZW8hXCIgKyBwYXJhbXMuZGVzdGluYXRpb25bMF0gKyBcIixcIiArIHBhcmFtcy5kZXN0aW5hdGlvblsxXTtcclxuXHJcbiAgICBpZiAoIXBhcmFtcy5zdGFydCAmJiAhcGFyYW1zLmRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJJc29saW5lIHJvdXRpbmcgOiBtaXNzaW5nIHN0YXJ0IG9yIGRlc3RpbmF0aW9uXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmFtcy5yYW5nZSkge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiSXNvbGluZSByb3V0aW5nIDogbWlzc2luZyByYW5nZVwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiaXNvbGluZS5yb3V0ZVwiLCBcImFwaS5oZXJlLmNvbS9yb3V0aW5nLzcuMi9jYWxjdWxhdGVpc29saW5lLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwicG9zdFwiKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBvZiBsYXQsbG5nLCB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHJlcy5ib2R5LnJlc3BvbnNlLmlzb2xpbmVbMF0uY29tcG9uZW50WzBdLnNoYXBlO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gc2hhcGUubWFwKHBvaW50ID0+IHBvaW50LnNwbGl0KFwiLFwiKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBwb2x5OiBwb2x5LCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgbWF0cml4LiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiBcclxuICogTWF0cml4IHNpemUgaXMgbGltaXRlZCB0byAxeDEwMCwxMDBYMSBvciAxNSpOXHJcbiAqICBAYXN5bmNcclxuICogQGFsaWFzIGhtOm1hdHJpeFxyXG4gKiBAcGFyYW0gc291cmNlIHtvYmplY3R9IHNvdXJjZSBhcyBcXFtsYXQsbG5nXFxdLiBDYW4gYmUgYXJyYXkgb2YgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gZGVzdCB7b2JqZWN0fSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gYWRkaXRpb25hbCBvcHRpb25hbCBwYXJhbWV0ZXJzIGxpa2UgIG1vZGUsIHN1bW1hcnlBdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9XCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmVuYWJsZWRcIl0ge3N0cmluZ30gcm91dGluZyBtb2RlIHRvIGNvbXB1dGUgbWF0cml4XHJcbiAqIEBwYXJhbSBbb3B0LnN1bW1hcnlBdHRyaWJ1dGVzPVwidHQsZGlcIl0ge3N0cmluZ30gYXR0cmlidXRlcyBpbiB0aGUgYW5zd2VyXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7IGVudHJpZXM6IG9iamVjdCwgYm9keTpvYmplY3QgfS4gZW50cmllcyBpcyB0aGUgYXJyYXkgb2Yge3N0YXJ0LHN0b3B9IGluZm9ybWF0aW9uLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgcmVzID0gYXdhaXQgaG0ubWF0cml4KHtcclxuICogICAgICBzb3VyY2U6WzQ4LjgsMi4zXVxyXG4gKiAgICAgIGRlc3Q6W1s0OC43LDIuNV0sWzQ4LjEsMi4wXSxbNDQuMiwyLjNdXVxyXG4gKiB9KTtcclxuICogY29uc29sZS5sb2cgKHJlcy5lbnRyaWVzKTsgXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIG1hdHJpeChzb3VyY2UsIGRlc3QsIG9wdCkge1xyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IHtcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZW5hYmxlZFwiLFxyXG4gICAgICAgIHN1bW1hcnlBdHRyaWJ1dGVzOiBcInR0LGRpXCJcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyhzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlWzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcclxuICAgIHNvdXJjZS5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcInN0YXJ0XCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZXN0WzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBkZXN0ID0gW2Rlc3RdO1xyXG4gICAgZGVzdC5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcImRlc3RpbmF0aW9uXCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwibWF0cml4LnJvdXRlXCIsIFwiYXBpLmhlcmUuY29tL3JvdXRpbmcvNy4yL2NhbGN1bGF0ZW1hdHJpeC5qc29uXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcInBvc3RcIilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4geyBlbnRyaWVzOiByZXMuYm9keS5yZXNwb25zZS5tYXRyaXhFbnRyeSwgYm9keTogcmVzLmJvZHkgfTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBkZXRvdXIgZm9yIGVhY2ggd2F5cG9pbnQgcHJvdmlkZWQsIGNvbXBhcmVkIHRvIG5vcm1hbCByb3V0ZSBmcm9tIEEgdG8gQlxyXG4gKiBcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpkZXRvdXJcclxuICogQHBhcmFtIHN0YXJ0IHtjb29yZH0gIHN0YXJ0aW5nIHBvaW50IGZvciByb3V0ZVxyXG4gKiBAcGFyYW0gc3RvcCB7Y29vcmR9ICAgZGVzdGluYXRpb24gcG9pbnQgb2Ygcm91dGVcclxuICogQHBhcmFtIHdheXBvaW50cyB7YXJyYXl9ICBsaXN0IG9mIHdhdHlwb2ludHMgdG8gdGVzdCBcclxuICogQHJldHVybnMge29iamVjdH0gcmV0dXJucyB7cmVmZXJlbmNlLHdheXBvaW50czpbIHtjb29yZCxkaXN0QSx0aW1lQSxkaXN0Qix0aW1lQn1dfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGV0b3VyKHN0YXJ0LCBzdG9wLCB3YXlwb2ludHMpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgIG5vLXVuZGVmXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvL2xldCB0U3RhcnQgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGFydCkgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgc3RhcnQgcG9pbnRcIik7XHJcbiAgICAgICAgICAgIGlmICghc3RvcCkgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgc3RvcCBwb2ludFwiKTtcclxuICAgICAgICAgICAgaWYgKCF3YXlwb2ludHMpIHJldHVybiByZWplY3QoXCJtaXNzaW5nIHdheXBvaW50c1wiKTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KSByZXR1cm4gcmVqZWN0KFwid2F5cG9pbnRzIHNob3VsZCBiZSBhbiBhcnJheVwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXNlIGxlIHJlc3VsdGF0IFxyXG4gICAgICAgICAgICBsZXQgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiB7fSxcclxuICAgICAgICAgICAgICAgIHdheXBvaW50czogW11cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bCBsZXMgY29vcmRzIG5vblBvc3RHcmVzLCBjcmVlciBsJ2FycmF5IGRlIGNvb3JkIGRlcyB3YXlwb2ludHMuXHJcbiAgICAgICAgICAgIGxldCBkZXN0ID0gW3N0b3BdOyAvLyBzbyB3ZSBoYXZlIGEgZGlzdGFuY2UvdGltZSByZWZlcmVuY2UsIG5vdCBzYW1lIGFzIGZyb20gcm91dGluZyAxOjFcclxuICAgICAgICAgICAgd2F5cG9pbnRzLmZvckVhY2god2F5cG9pbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVzdC5wdXNoKHdheXBvaW50KTtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICB7IGNvb3JkOiB3YXlwb2ludCB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gaW5zcGVjdChkZXN0LCBcImRlc3QgZnJvbSBkZXRvdXJcIilcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgdG8gYWxsIHdheXBvaW50LCAxc3Qgd2F5cG9pbnQgaXMgc3RvcCB0byBnZXQgYSByZWZlcmVuY2VcclxuICAgICAgICAgICAgbGV0IHAxID0gbWF0cml4KHN0YXJ0LCBkZXN0LCB7IG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBmcm9tIGFsbCB3YXlwb2ludCB0byBzdG9wLCAxc3Qgd2F5cG9pbnQgaXMgc3RhcnQgdG8gZ2V0IGFub3RoZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSBzdGFydDtcclxuICAgICAgICAgICAgbGV0IHAyID0gbWF0cml4KGRlc3QsIHN0b3AsIHsgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIgfSk7XHJcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGJvdGggbWF0cml4IHRvIGNvbXBsZXRlXHJcblxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgICBuby11bmRlZlxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChbcDEsIHAyXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGZpcnN0IHBhcnQ6IHN0YXJ0ID0+IE4gd2F5cG9pbnRzXHJcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gcmVzdWx0WzBdLmVudHJpZXM7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IGVudHJ5IGlzIHN0YXJ0IHN0b3BcclxuICAgICAgICAgICAgbGV0IGRpc3QgPSBlbnRyaWVzWzBdLnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lID0gZW50cmllc1swXS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2Uuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5zdG9wID0gc3RvcDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5kaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UudGltZSA9IHRpbWU7IC8vIHRoZSByZWZlcmVuY2Ugc2FucyB3YXlwb2ludFxyXG5cclxuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgcmV0dXJuOyAvLyBza2lwIHRoZSBmaXJzdCB3aGljaCBpcyBzdGFydCBzdG9wXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXR1cyA9PSBcImZhaWxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlbnRyeSwgXCJlcnJvciBvbiBtYXRyaXhBXCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHN0YXJ0LCBcImFzc29jaWF0ZWQgc3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkZXN0W2ldLCBcImFzc29jaWF0ZWQgZGVzdFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpZCA9IGVudHJ5LmRlc3RpbmF0aW9uSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IGVudHJ5LnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZSA9IGVudHJ5LnN1bW1hcnkudHJhdmVsVGltZTtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS5kaXN0QSA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0udGltZUEgPSB0aW1lO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHNlY29uZCBwYXJ0OiBOIHdheXBvaW50cyA9PiBzdG9wXHJcbiAgICAgICAgICAgIGVudHJpZXMgPSByZXN1bHRbMV0uZW50cmllcztcclxuICAgICAgICAgICAgLy9pbnNwZWN0KGVudHJpZXNbMF0sIFwibWF0cml4QjBcIik7XHJcblxyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLmRpc3RhbmNlMiA9IGVudHJpZXNbMF0uc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS50aW1lMiA9IGVudHJpZXNbMF0uc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG5cclxuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgcmV0dXJuOyAvLyBza2lwIHRoZSBmaXJzdCB3aGljaCBpcyBzdGFydCBzdG9wXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXR1cyA9PSBcImZhaWxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlbnRyeSwgXCJlcnJvciBvbiBtYXRyaXhCXCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImFzc29jaWF0ZWQgc3RhcnRcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RvcCwgXCJhc3NvY2lhdGVkIHN0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gZW50cnkuc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gZW50cnkuc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lID0gZW50cnkuc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLmRpc3RCID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS50aW1lQiA9IHRpbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgbWF0cml4OiBtYXRyaXgsXHJcbiAgICByb3V0ZTogcm91dGUsXHJcbiAgICBpc29saW5lOiBpc29saW5lLFxyXG4gICAgZGV0b3VyOiBkZXRvdXJcclxufTtcclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLypcclxuICogQG1vZHVsZSBIRVJFTUFQXHJcbiAqIEB0eXBpY2FsbmFtZSBobVxyXG4gKi9cclxuXHJcbmxldCBtb2R1bGVzID0ge307XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9yb3V0aW5nLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9nZW9jb2RpbmcuanNcIikpO1xyXG5cclxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9tYXAuanNcIikpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9jbHVzdGVyLmpzXCIpKTtcclxufVxyXG4vLyBleHBvcnQgYWxsIHRoZSBhYm92ZVxyXG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZXM7XHJcblxyXG4vL2NvbnNvbGUubG9nKFwibW9kdWxlLmV4cG9ydHNcIiwgbW9kdWxlLmV4cG9ydHMpO1xyXG4vL2NvbnNvbGUubG9nKFwicHJvY2Vzcy5icm93c2VyXCIsIHByb2Nlc3MuYnJvd3Nlcik7Il19
