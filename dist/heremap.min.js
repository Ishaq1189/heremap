(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.heremap = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(fn => {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(...args) {
    this._defaults.push({fn, args});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(def => {
      req[def.fn].apply(req, def.args);
    });
};

module.exports = Agent;

},{}],3:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

let root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

const Emitter = require('component-emitter');
const RequestBase = require('./request-base');
const isObject = require('./is-object');
const ResponseBase = require('./response-base');
const Agent = require('./agent-base');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

const request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = () => {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

const trim = ''.trim
  ? s => s.trim()
  : s => s.replace(/(^\s*|\s*$)/g, '');

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  const pairs = [];
  for (const key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(v => {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(const subkey in val) {
        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  const obj = {};
  const pairs = str.split('&');
  let pair;
  let pos;

  for (let i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  const lines = str.split(/\r?\n/);
  const fields = {};
  let index;
  let line;
  let field;
  let val;

  for (let i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  let status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  let parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  const req = this.req;
  const method = req.method;
  const url = req.url;

  const msg = `cannot ${method} ${url} (${this.status})`;
  const err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  const self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', () => {
    let err = null;
    let res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    let new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  const encoder = string => {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  const fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  const err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = () => {
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  this._end();
};

Request.prototype._end = function() {
  if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));

  const self = this;
  const xhr = (this.xhr = request.getXHR());
  let data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = () => {
    const readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    let status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  const handleProgress = (direction, e) => {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    const contentType = this._header['content-type'];
    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (const field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
};

request.agent = () => new Agent();

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(method => {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    const req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = (url, data, fn) => {
  const req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = (url, data, fn) => {
  const req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = (url, data, fn) => {
  const req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  const req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = (url, data, fn) => {
  const req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = (url, data, fn) => {
  const req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = (url, data, fn) => {
  const req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./agent-base":2,"./is-object":4,"./request-base":5,"./response-base":6,"component-emitter":8}],4:[function(require,module,exports){
'use strict';

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],5:[function(require,module,exports){
'use strict';

/**
 * Module of mixed-in functions shared between node and client code
 */
const isObject = require('./is-object');

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(const option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

const ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      const override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    const self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {
      self.on('error', innerReject);
      self.end((err, res) => {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (const key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (const key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (const i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', `Bearer ${user}`);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  const isObj = isObject(data);
  let type = this._header['content-type'];

  if (this._formData) {
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (const key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? `${this._data}&${data}`
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  const query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    const index = this.url.indexOf('?');
    if (index >= 0) {
      const queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = () => {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  const err = new Error(`${reason + timeout}ms exceeded`);
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  const self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(() => {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(() => {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

},{"./is-object":4}],6:[function(require,module,exports){
'use strict';

/**
 * Module dependencies.
 */

const utils = require('./utils');

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (const key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    const ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    const params = utils.params(ct);
    for (const key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    const type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};

},{"./utils":7}],7:[function(require,module,exports){
'use strict';

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = str => str.split(/ *; */).shift();

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = str => str.split(/ *; */).reduce((obj, str) => {
  const parts = str.split(/ *= */);
  const key = parts.shift();
  const val = parts.shift();

  if (key && val) obj[key] = val;
  return obj;
}, {});

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {
  const parts = str.split(/ *; */);
  const url = parts[0].slice(1, -1);
  const rel = parts[1].split(/ *= */)[1].slice(1, -1);
  obj[rel] = url;
  return obj;
}, {});

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = (header, changesOrigin) => {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};

},{}],8:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],9:[function(require,module,exports){
/* global H, fetch */
"use strict";
const m = require("map");

let map = null;

let clusterLayer = null;


/**
 * creates a cluster of points
 * @async
 * @alias hm:cluster
 * @param coords {Array}  array of \[lat,lng,payload\]
 * @param opt {object} options for cluster
 * @param [opt.minZoom] {number} min zoom for cluster to be visible
 * @param [opt.maxZoom] {number} max zoom for cluster to be visible
 * @param [opt.noise] {array} graphic to represent stand-alone point. format: [url,size]
 * @param [opt.clusterIcon] {string} url of svg file representing a cluster
 * @param [opt.style] {object} define for each minium aggregation level the color and size of the icon. See example
 * @param {function} cb callback to be called if click on item. Format cb(event, coord, payload, weigth). 
 * `coord` is coord of icon
 * `payload` is payload associated to point. 
 * `weight` is number of points aggregated, when clicking on a cluster icon, 1 if single point
 * 
 * @return {H.map.layer.ObjectLayer}  layer created
 * 
  * @example
  * ```js
  * let pois = [[48.8,2.3,"Hello world"],[48.5,2.4,"How are you"],[45.2,2.93,"Very well"]];
  * 
  * hm.cluster(pois);
  * 
  * // with more graphic options and callback defined
 *  hm.cluster(pois, {
 *           noise: ["mcdo.png", 24],
 *           clusterIcon: '../svg/cluster2.svg',    //  icon for cluster
 *           style: {
 *               200: { color: "#B50015", size: 64 }  // for 200 or more points aggrregated, drag red big icon
 *               75: { color: "#FF6900", size: 58 },  // for 75 or more points aggregated. orange middle size icon
 *               2: { color: "#7BD30A", size: 46 },   // for 2 or more points aggregated. green small icon
 *           }
 *       },
 *           (event, coordinate, data, weight) => {
 *               if (data)
 *                   console.log("click on point ", data);
 *               else
 *                   console.log("click on cluster with weight", weight);
 *           });
* ```
 */
async function cluster(coords, opt, cb = null) {

    let dataPoints = [];
    map = m.getMap();

    let settings = {
        minZoom: 1,     // min zoom
        maxZoom: 24,    // max zoom
        noise: ["http:svg/bluedot.svg", 16],  //  icon+size for noise, can be svg or image
        clusterIcon: "http:svg/cluster.svg",    //  icon for cluster
        style: {
            75: { color: "#FF6900", size: 36 },
            3: { color: "#7BD30A", size: 32 },
            200: { color: "#B50015", size: 48 }
        }
    };
    if (opt)
        Object.assign(settings, opt);


    coords.forEach(coord => {
        // use op_weight of 1 for each coord
        // provides all coord as data
        let dp = new H.clustering.DataPoint(coord[0], coord[1], 1, coord);
        dataPoints.push(dp);

    });


    // noise icon : if SVG, needs to fetch it
    let noiseIcon = settings.noise[0];
    let noiseSize = settings.noise[1];

    if (noiseIcon.substr(-3) == "svg") {
        noiseIcon = await fetch(noiseIcon)
            .then(res => {
                if (res.status != 200)
                    return null;
                return res.text();
            });

    }

    if (!noiseIcon) return; // if no result, let's quit

    // to speed up, create only once the icon for noise
    const iconNoise = new H.map.Icon(noiseIcon, { size: { w: noiseSize, h: noiseSize } });

    // let's now fetch cluster icon
    let svgCluster = await fetch(settings.clusterIcon)
        .then(res => {
            if (res.status != 200)
                return null;
            return res.text();
        });

    if (!svgCluster)
        return;


    // to speed display display, we will cache the various cluster icons
    // from the base svg, we will create different icons with different size/color/text
    let cacheIcon = {}; // cache of icons

    // order style by size descending
    let styleSize = Object.keys(settings.style).sort(function (a, b) { return b - a; });

    // this function  cretaes the icon for a cluster
    function getClusterPresentation(cluster) {

        // building data object which will be returned when clicking on the icon
        var data = {};
        data.isCluster = () => { return true; };  // so we know it is a cluster
        let weight = cluster.getWeight();
        data.getWeight = () => { return weight; }; // number of individual item clustered together

        // let's find the relevant color and size
        let entry = styleSize.find(elt => (weight >= elt));
        let color = settings.style[entry].color;
        let size = settings.style[entry].size;

        // let's create and cache the needed icons
        let key = color + "-" + weight + "-" + size;
        if (typeof cacheIcon[key] == "undefined") {
            let svg = svgCluster.replace("{text}", weight).replace(/{color}/g, color);
            cacheIcon[key] = new H.map.Icon(svg, { size: { w: size, h: size } });
        }

        // create a marker for the Cluster
        var clusterMarker = new H.map.Marker(cluster.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: cluster.getMinZoom(),
            max: cluster.getMaxZoom(),
            icon: cacheIcon[key],

        });

        // Link data from the from the cluster to the marker,
        // to make it accessible on callback
        clusterMarker.setData(data);

        return clusterMarker;
    }

    // function to represent a single item
    function getNoisePresentation(noisePoint) {

        // data to be sent on callback
        const data = {
            getData: () => { return noisePoint.getData(); },
            isCluster: () => { return false; },
            getWeight: () => { return 1; }
        };

        // Create a marker for the noisePoint
        var noiseMarker = new H.map.Marker(noisePoint.getPosition(), {
            // Use min zoom from a noise point
            // to show it correctly at certain zoom levels:
            min: noisePoint.getMinZoom(),
            icon: iconNoise
        });


        // Link a data from the point to the marker
        // to make it accessible on callback
        noiseMarker.setData(data);

        return noiseMarker;
    }


    // create cluster provider
    let clusteredDataProvider = new H.clustering.Provider(dataPoints, {
        clusteringOptions: {
            // Maximum radius of the neighborhood
            eps: 64,
            // minimum weight of points required to form a cluster
            minWeight: styleSize[styleSize.length - 1] // minimum clustering is defined by minsize in Style
        },
        min: settings.minZoom, // min zoom
        max: settings.maxZoom, // max zoom
        theme: { getClusterPresentation: getClusterPresentation, getNoisePresentation: getNoisePresentation }
    });

    // Create a layer that includes the data provider and its data points:
    let layer = new H.map.layer.ObjectLayer(clusteredDataProvider);
    // Add the layer to the map:
    map.addLayer(layer);

    // if a callback is defined, add event listener
    if (cb) {
        clusteredDataProvider.addEventListener("tap", function (ev) {
            // Log data bound to the marker that has been tapped:
            let data = ev.target.getData();
            let coord = map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            let isCluster = data.isCluster();

            if (isCluster) {
                let weigth = data.getWeight();
                cb(ev, m.coordO2A(coord), null, weigth);
            }

            else {
                let userData = data.getData(); // lat,lng, payload
                cb(ev, m.coordO2A(coord), userData[2], 1);
            }
        });
    }

    return layer;
}

function hide() {
    clusterLayer.setMax(0);
    clusterLayer.setMin(0);
}

function show() {
    clusterLayer.setMax(24);
    clusterLayer.setMin(0);

}


module.exports = {
    cluster: cluster,
    clusterShow: show,
    clusterHide: hide
};


},{"map":12}],10:[function(require,module,exports){
(function (process){
/* global document */
"use strict";

const request = require("superagent");

// by default, unless specified fby calling config
// environment usable with node
let APP_ID = process.env.APP_ID;
let APP_CODE = process.env.APP_CODE;
let CIT = ""; // production by default
let PROTOCOL = "https:"; // by default
let _useHTTPS = true; // by default
let _home = ".";


// find out where we are and relative position for png/svg files
// pay attention if library is build in ./dist
if (process.browser) {
    let _script = document.getElementsByTagName("script");
    let _file = _script[_script.length - 1].src;
    let _path = _file.substring(0, _file.lastIndexOf("/"));

    _home = _path + "/../"; // a bit dirty but ...
}

/**
 * To configure app_id, app_code and optionally use CIT and http
 * @alias hm:config
 *
 * @param opt {Object}  - `opt` with parameters.
 * @param [opt.app_id] {string} - the app_id from developer.here.com
 * @param [opt.app_code] {string} - the app_code from developer.here.com
 * @param [opt.useCIT=false] {boolean} - true to use CIT environment. 
 * @param [opt.useHTTP=false] {string} - true to use HTTP. 
 * @param [opt.useHTTPS=true] {string} - true to use HTTPS. 
 *
 * @example
 * ```js
 *  hm.config({
 *      app_id: "YOUR APP_ID",
 *      app_code: "YOUR APP_CODE",
*   });
*  ```
 */
function config(opt) {
    if (opt.app_id) APP_ID = opt.app_id;
    if (opt.app_code) APP_CODE = opt.app_code;
    if (opt.useCIT) CIT = ".cit";
    if (opt.useHTTP) {
        PROTOCOL = "http:";
        _useHTTPS = false;
    }
    if (opt.useHTTPS) {
        PROTOCOL = "https:";
        _useHTTPS = true;
    }
}

/**
 * return URL of module home directory
 * @ignore
 *  @alias hm:getHome
 * @return {string} url of home directory including http or https
 */
function getHome() {
    return _home;
}

/**
 * returns app_id
 * @ignore
 *  @alias hm:getAppId
 * @return {string} app_id
*/
function getAppId() {
    return APP_ID;
}

/**
 * return app_code
 *  @ignore
 *  @alias hm:getHome
 *  @alias hm:getAppCode
  * @return {string} app_code
*/
function getAppCode() {
    return APP_CODE;
}

/**
 * return true if using CIT
 * @ignore
 * @alias hm:getCIT
 * @return {booolean} true if using CIT
*/
function getCIT() {
    return CIT;
}

/**
 * return protocol used, http:// or https://
 * @ignore
 * @alias hm:getProtocol
 * @return {string} - protocol
*/
function getProtocol() {
    return PROTOCOL;
}

/**
 * return true is https is used
 * @ignore
 *  @alias hm:useHTTPS
 * @return {boolean} - true if https is used
*/
function useHTTPS() {
    return _useHTTPS;
}

/**
 * add credentials to object provided
  * @ignore
 *  @alias hm:addCredentials
 * @param  {...objects} list of `objects` 
 * @return {object} object with all input objectconcatenated, and app_id/app_code inserted
 */
function addCredentials(...obj) {
    return Object.assign({
        app_id: APP_ID,
        app_code: APP_CODE
    }, ...obj);
}

/**
 * build HERE REST full url, taking in account protocol and cit. for instance  cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json"
 * @ignore
 * @alias hm:buildUrl
 * @param {string} base - base name
 * @param {string} endpoint - end point
 * @return {string} full url
 */
function buildUrl(base, endpoint) {
    return PROTOCOL + "//" + base + CIT + "." + endpoint;
}

/**
 * does get/post request to HERE RESDT backend and manage main errors
 * @ignore
 * @alias hm:hereRest
 * @param {string} url  - url to call , for instance from buildUrl
 * @param {object} settings - settings to add in request
 * @param  {string} mode=get - mode "get" or "post"
 * @return {promise} - promise to resolve/reject
 */
async function hereRest(url, settings, mode = "get") {

    let p = request.get(url);
    if (mode == "post")
        p = request.post(url);

    return p
        .query(settings)
        .then(res => {
            // res.body, res.headers, res.status
            if (res.status != "200") {
                let e = new Error("Error " + res.status + ":" + res.body); // e.message
                throw (e);
            }


            if (!res.body.Response && !res.body.response) { // one of the two should be in the answer
                console.error(res.body);
                let e = new Error("Query error:" + res.body); // e.message
                throw (e);
            }

            if (res.body.response && res.body.response.type == "ApplicationError") {
                console.error(res.body);
                let e = new Error("Error" + res.body.response.details); // e.message
                throw (e);
            }

            return res;
        });
}

module.exports = {
    config: config,
    buildUrl: buildUrl,
    getAppId: getAppId,
    getAppCode: getAppCode,
    getCIT: getCIT,
    getProtocol: getProtocol,
    getHome: getHome,
    useHTTPS: useHTTPS,
    addCredentials: addCredentials,
    hereRest: hereRest
};
}).call(this,require('_process'))

},{"_process":1,"superagent":3}],11:[function(require,module,exports){
/**
 * @file Geocoding functions : addresses <--> [lat,lng]
 * @author Devbab 
 */

"use strict";
const cm = require("./common.js");

/**
 * geocode an address
 * @async
 * @alias hm:geocode
 * @param {string} address - address as string
 * @returns {Object} returns  {coord,body}. coord is geocode as \[lat,lng\]. body is full json answer
 * 
 * @example
 * ```js
 * const res = await hm.geocode("avenue des chaps elysees, paris");
 * console.log (res.coord);
 * ```
 */
async function geocode(address) {

    const settings = cm.addCredentials({
        searchText: address
    });

    const url = cm.buildUrl("geocoder", "api.here.com/6.2/geocode.json");
    return cm.hereRest(url, settings)
        .then(res => {

            if (res.body.Response.View.length == 0) {
                let e = new Error("Geocode Address not found: " + address); // e.message
                throw (e);
            }

            var location = res.body.Response.View[0].Result[0].Location;
            var coord = [location.NavigationPosition[0].Latitude, location.NavigationPosition[0].Longitude];
            return { coord: coord, body: res.body };
        });
}


/**
 * reverse geocode a coordinate
 * @async
 * @alias hm:reverseGeocode
 * @param {Coord} coord - coord \[lat,lng\] to reverse geocode
 * @returns {object} returns { location:object, address:object, body:object}. 
 */
async function reverseGeocode(coord) {

    const settings = cm.addCredentials({
        mode: "retrieveAddresses",
        prox: coord[0] + "," + coord[1]
    });

    const url = cm.buildUrl("reverse.geocoder", "api.here.com/6.2/reversegeocode.json");

    return cm.hereRest(url, settings)
        .then(res => {
            // res.body, res.headers, res.status
            var location = res.body.Response.View[0].Result[0].Location;
            return ({ location: location, address: location.Address, body: res.body });
        });
}


module.exports = {
    geocode: geocode,
    reverseGeocode: reverseGeocode
};


},{"./common.js":10}],12:[function(require,module,exports){
/* global H, fetch, document, navigator, mapsjs, window APP_ID_JAPAN,APP_CODE_JAPAN,APP_ID_KOREA,APP_CODE_KOREA*/

"use strict";
const cm = require("./common.js");

let _platform = null;
let _provider = null;
let _defaultLayers = null;
let _ui = null;
let _map = null;
let group = null;
let _layers = []; // list all layers
let _key = {};     // keys  
let _bubbleMarker = null;     // bubble de mamrker
let _scheme = "normal.day.grey";
let _locateMe = null;         // id when locate is active



function coordO2A(obj) {
    return [obj.lat, obj.lng];
}

function coordA2O(arr) {
    return { lat: arr[0], lng: arr[1] };
}


/**
 * create a map area within the specified item
  * @alias hm:map

 * @param htmlItem {string}  - identifier of html div item on which to insert map
 * @param opt {object}  - options
 * @param [opt.zoom=10] {number}  - zoom factor
 * @param [opt.center=[48.86, 2.3]] {Coord}  - Coord of the center
 * @param [opt.scheme=normal.day.grey] {string}  - any scheme defined by HERE, plus "japan", "korea", "black", "white", "transparent". For japan/korea, one needs special credentials as APP_[ID|CODE]_JAPAN APP_[ID|CODE]_KOREA
 * @param [opt.click=null] {function()}  - callback on mouse click: callback(coord,button,key)
 * @param [opt.dbClick=null] {function()}  - callback on mouse double click: callback(coord,button,key)
 * @param [opt.clickLeft=null] {function}  - callback on mouse click left: callback(coord,button,key)
 * @param [opt.clickRight=null] {function()}  - callback on mouse click right.: callback(coord,button,key)
 * @param [opt.keyDown=null] {function}  - callback on key down : callback(key)
 * @param [opt.viewChange=null] {function}  - callback if map is panned or zoomed : callback(zoom,coordCenter)
 * @param [opt.loadTile=null] {function}  - callback when a tile is loaded : callback(z,x,y,url)
 *
 * @example
 * ```js
 * const hm = window.heremap;
 * 
 * hm.config({
 *    app_id: "YOUR APP_ID",
 *    app_code: "YOUR APP_CODE",
 * });
 *
 * hm.map("map", {
 *    zoom:5,
 *    center: [48.8,2.3],
 *    click: function(coord,button,key) {console.log("clicked on",coord,"with button",button);}
 * });
*  ```
*/
function map(htmlItem, opt) {

    let settings = {
        zoom: 10,
        center: [48.86, 2.3],
        clickLeft: null,
        clickRight: null,
        keyDown: null,  // keyboard event
        click: null,
        dbClick: null,
        viewChange: null, // (zoom,coord)
        loadTile: null // quand une tile est affichée
    };

    let mps = 1;

    let app_id = cm.getAppId();
    let app_code = cm.getAppCode();

    if (!app_id || !app_code) {
        console.log("app_id/app_code not initialised");
        document.getElementById(htmlItem).innerHTML = "app_id/app_code not initialised";
        return;
    }

    _platform = new H.service.Platform({
        app_id: app_id,
        app_code: app_code,
        useCIT: cm.getCIT(),
        useHTTPS: cm.useHTTPS()
    });

    Object.assign(settings, opt);
    if (settings.scheme) _scheme = settings.scheme; // store scheme if defined

    _defaultLayers = _platform.createDefaultLayers();
    console.log(_defaultLayers);

    // http://heremaps.github.io/examples/explorer.html#map-tiles__base-map-styles-and-modes
    _provider = new H.map.provider.ImageTileProvider({
        label: "Base Provider",
        descr: "",
        min: 0,
        max: 20,
        crossOrigin: "anonymous",
        getURL: function (col, row, level) {
            mps++; if (mps > 4) mps = 1;
            let url = [cm.getProtocol(), "//", mps, ".base.maps" + cm.getCIT() + ".api.here.com/maptile/", "2.1",
                "/", "maptile", "/", "newest", "/",
                _scheme, "/", level, "/", col, "/", row, "/", "256",
                "/", "png", "?lg=", "FRE",
                "&app_code=", app_code, "&app_id=",
                app_id].join("");

            if (_scheme == "japan")
                url = [cm.getProtocol(), "//", "m.lbs" + cm.getCIT() + ".api.heremaps.jp/v1/map?app_id=",
                    APP_ID_JAPAN,
                    "&app_code=",
                    APP_CODE_JAPAN,
                    "&tilematrix=EPSG:900913:",
                    level,
                    "&tilecol=",
                    col,
                    "&tilerow=",
                    row].join("");

            else if (_scheme == "korea")
                url = [cm.getProtocol(), "//", "3.base.maps" + cm.getCIT() + ".api.heremaps.kr/maptile/2.1/maptile/34439348c3/normal.day/",
                    "/", level, "/", col, "/", row, "/", "256",
                    "/", "png", "?lg=", "FRE",
                    "&app_code=", APP_CODE_KOREA, "&app_id=",
                    APP_ID_KOREA].join("");

            else if (_scheme == "black")
                url = cm.getHome() + "png/black.png";
            else if (_scheme == "white")
                url = cm.getHome() + "png/white.png";
            else if (_scheme == "transparent")
                url = cm.getHome() + "png/transparent.png";


            if (settings.loadTile)
                settings.loadTile(level, col, row, url);

            return url;
        }


    });

    let __layer = new H.map.layer.TileLayer(_provider);

    //console.log("normal map");
    //Step 2: initialize a HEREMap 
    _map = new H.Map(document.getElementById(htmlItem),
        __layer, {
            center: coordA2O(settings.center),
            zoom: settings.zoom
        });

    let behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(_map));

    // Create the default UI components
    _ui = H.ui.UI.createDefault(_map, _defaultLayers);

    // create default layer
    layerCreate("default");

    _map.addEventListener("", function () {

    })

    // if callback on zoom Change
    if (settings.viewChange) {
        _map.addEventListener("mapviewchangeend", function () {
            let bound = _map.getViewBounds();
            let lat = (bound.ka + bound.ja) / 2;
            let lng = (bound.ga + bound.ha) / 2;

            //console.log("viewChange center " + lat + " " + lng);
            settings.viewChange(_map.getZoom(), [lat, lng]);
        });
    }

    /***********************           to handle keyboard while mouse in map        ***********************/
    let kup = function () {
        _key.ctrl = false;
        _key.shift = false;
        _key.alt = false;
        _key.key = "";
    };

    let kdown = function (e) {
        _key.ctrl = ((e.key == "Control") || (e.keyIdentifier == "Control") || (e.ctrlKey == true));
        _key.shift = ((e.key == "Shift") || (e.keyIdentifier == "Shift") || (e.shiftKey == true));
        _key.alt = ((e.key == "Alt") || (e.keyIdentifier == "Alt") || (e.shiftKey == true));
        _key.key = e.key;
        if (settings.keyDown) settings.keyDown(_key);
    };

    _map.addEventListener("mouseenter", function () {
        // console.log("map mouse enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });

    _map.addEventListener("pointerenter", function () {
        //console.log("map pointer enter");
        document.addEventListener("keydown", kdown);
        document.addEventListener("keyup", kup);
    });
    _map.addEventListener("mouseleave", function () {
        // console.log("map mouse leave");
        document.removeEventListener("keydown", kdown);
        document.removeEventListener("keyup", kup);
    });

    /***********************           to handle double click         ***********************/
    _map.addEventListener("dbltap", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) return; // don't do anything if click on marker

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;
        if (settings.dbClick != "") {
            switch (button) {
                case 0: settings.dbClick(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.dbClick(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /***********************           to handle simple click         ***********************/
    _map.addEventListener("tap", function (ev) {
        let target = ev.target;

        if (target instanceof H.map.Marker) return;

        let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
        let button = ev.currentPointer.button;

        if ((button == 0) && (settings.clickLeft))
            settings.clickLeft(coordO2A(coord), "left", _key);
        if ((button == 2) && (settings.clickRight))
            settings.clickRight(coordO2A(coord), "right", _key);
        if (settings.click != "") {
            switch (button) {
                case 0: settings.click(coordO2A(coord), "left", _key);
                    break;
                case 2: settings.click(coordO2A(coord), "right", _key);
                    break;
            }
        }
    });

    /*********  disable the default draggability of the underlying map when starting to drag a marker object *****************/
    _map.addEventListener("dragstart", function (ev) {
        let target = ev.target;
        if (target instanceof H.map.Marker) {
            behavior.disable();
        }
    }, false);

    /************   re - enable the default draggability of the underlying map when dragging has completed ***********************/
    _map.addEventListener("dragend", function (ev) {
        let target = ev.target;
        if (target instanceof mapsjs.map.Marker) {
            behavior.enable();
            if (typeof target.dragged !== "undefined") {
                let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
                (target.dragged)(target, coordO2A(coord));
            }
        }
    }, false);

    /***********************  Listen to the drag event and move the position of the marker as necessary *******************/
    _map.addEventListener("drag", function (ev) {
        let target = ev.target,
            pointer = ev.currentPointer;
        if (target instanceof mapsjs.map.Marker) {
            target.setPosition(_map.screenToGeo(pointer.viewportX, pointer.viewportY));
        }
    }, false);


    /****************  detect map resize and adjust accoridngly ******************************/
    window.addEventListener("resize", function () {
        _map.getViewPort().resize();

    });
}

/**
 * list of all available map styles normal.day, night.... 
 * @alias hm:getAvailableMapStyle
 * @return {json} list of map styles as json
 */
function getAvailableMapStyle() {
    // https://1.base.maps.api.here.com/maptile/2.1/info?xnlp=CL_JSMv3.0.17.0&app_id=nOSh21214JFMSEPQkqno&app_code=rX_l7YvALtNkqU2bx5FWEA&output=json

    const settings = cm.addCredentials({
        output: "json"
    });

    const url = cm.buildUrl("1.base.maps", "api.here.com/maptile/2.1/info");
    return cm.hereRest(url, settings)
        .then(res => {
            return res.body.response;
        });
}

/**
 * define the scheme. List of scheme can be obtained from {hm.getAvailableMapStyle()}
 * @alias hm:setScheme
 * @param {string} scheme scheme name
 */
function setScheme(scheme) {
    _scheme = scheme;
}

/**
 * create a layer
 * @alias hm:layerCreate
 * @param {string} name  - name of layer
 * @param {boolean} visible  - initial status
 * @example
 * ```js
 * hm.layerCreate("layer1");
 *  ```
 */
function layerCreate(name, visible) {
    group = new H.map.Group();
    group.name = name;
    _map.addObject(group);

    // push into list of layers
    _layers.push(group);

    // can be visible or hidden
    if (typeof visible != "undefined")
        group.setVisibility(visible);

    return group;
}

/**
 * delete a layer
 * @alias hm:layerDelete
 * @param {String} name name of layer
 */
function layerDelete(name) {
    let layer = layerFind(name);
    if (!layer)
        return;

    layer.name = null;
    _map.removeObject(layer);
}

/**
 * Empty a layer, actually deletes it and recreate it
 * @alias hm:layerEmpty
 * @param {string} layer 
 */
function layerEmpty(name) {
    layerDelete(name);
    layerCreate(name);
}


/**
 * find layer by its name or return null 
 * @alias hm:layerFind
 * @param {string} name 
 */
function layerFind(name) {
    let l = _layers.find(layer => {
        return layer.name == name;
    });
    if (typeof l == "undefined") return null;
    return l;
}


/**
 * set center of the map
* @alias hm:setCenter
 * @param {Array} - coord as [lat,lng]
 * * @example
 * ```js
 * hm.setCenter([48.8,2.3]);
 *  ```
 */
function setCenter(coord) {
    _map.setCenter(coordA2O(coord));
}

/**
 * return coordinate of the center of the map
 * @alias hm:getCenter
 * @returns {coord} coord of the center as \[lat,lng\]
 */
function getCenter() {
    let bound = _map.getViewBounds();
    //_HM.log("viewbound",bound);

    let lng = (bound.ga + bound.ha) / 2;
    let lat = (bound.ka + bound.ja) / 2;
    return [lat, lng];

}

/**
 * return bounding box of visible part of map
 * @alias hm:getViewBB
 * @returns {Object} bouding box of visible part of the map, as \[latm,latM,longm,lngM\]
 */
function getViewBB() {
    let bb = _map.getViewBounds();

    let bb2 = {
        latm: bb.ja,
        latM: bb.ka,
        lngm: bb.ga,
        lngM: bb.ha
    };
    return bb2;
}

/**
 * sets bouding box to be displayed
 * @alias hm:setViewBB
 * @param opt {Object| string}  either an object specifying how to set bounding box, or  a String being the name of a layer
 * @param [opt.layer] {string} bouding box aroud all objects of the layer
 * @param [opt.pois] {array} bouding box aroud all coords defined as \[coord,coord...\]
 * @example
 * ```js
  * hm.setViewBB("layer1");
 *
 * hm.setViewBB({
    *    pois: coords
    * });
 *  ```
 */
function setViewBB(opt) {

    if (typeof opt == "string")
        opt = { layer: opt };

    let settings = {
        layer: null,
        pois: null // array of [lat,lng]
    };
    Object.assign(settings, opt);

    let bbox;

    //set BB based on layer
    if (settings.layer) {
        let layer = layerFind(settings.layer);
        if (!layer) return;

        // get view bound and add a bit around, like 1/5
        let bb = layer.getBounds();
        if (!bb) // as if nothing in layer
            return;
        bb.latm = bb.ja;
        bb.latM = bb.ka;
        bb.lngm = bb.ga;
        bb.lngM = bb.ha;
        let dx = bb.lngM - bb.lngm;
        let dy = bb.latM - bb.latm;
        dx = dx / 5;
        dy = dy / 5;
        bb.latM += dy;
        bb.lngm -= dx;
        bb.latm -= dy;
        bb.lngM += dx;
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);

    }

    else if (settings.pois) {
        let bb = {
            latM: 0,
            lngm: 180,
            latm: 90,
            lngM: -180,
        };
        let arr = settings.pois;
        arr.forEach((poi) => {
            if (poi[0] > bb.latM) bb.latM = poi[0];
            if (poi[1] > bb.lngM) bb.lngM = poi[1];
            if (poi[0] < bb.latm) bb.latm = poi[0];
            if (poi[1] < bb.lngm) bb.lngm = poi[1];
        });
        bbox = new H.geo.Rect(bb.latM, bb.lngm, bb.latm, bb.lngM);
        _map.setViewBounds(bbox, true);
    }
}


/**
 * return zoom value
 * @alias hm:getZoom
 * @returns {number} zoom level
 */
function getZoom() {
    return _map.getZoom();
}

/**
 * set zoom level
 * @alias heremap:setZoom
 * @param {number} zoom 
 */
function setZoom(zoom) {
    _map.setZoom(zoom);
}



/**
 * create an icon, to be used for a marker
 * @async
 * @alias hm:buildIcon
 * @param opt {object} options to specify the icon
 * @param [opt.img] {string}  use a png/jpg image. Specify the url 
 * @param [opt.svg] {string}  url a svg. This can be an inline svg, a url, or a svg from heremap
 * @param [opt.opt] {object}   style object
 * @param [opt.opt.size] {number|string}   size of icon, as 24 or 24x32
 * @param [opt.opt.ratio] {number}   for svg files, ratio of size. 0.5 = half
 * @param [opt.opt.anchor] {number|string}   anchor of icon, as 24 or 24x32. By default, bottom-center
 * @param [opt.opt.tag] {string}   for svg, any tag like{tag}. will be replaced by associated value
 * @return {H.map.Icon} the created icon
 * @example 
 * ```js
 * hm.buildIcon({
 *    img: "http://whatever.com/image.png",
 *    opt: {size:24}
 * });
 * 
 * hm.buildIcon({
 *    svg: "http://whatever.com/image.svg",
 *    opt: {
 *       size:24,
 *       anchor:24x32
 *    }
 * });
 *  
 * hm.buildIcon({
 *    svg: "svg/cluster.svg",
 *    opt: {
 *       size:24,
 *       color:"red"
 *    }
 * });
 * 
 * const svg = `<svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"> <ellipse stroke="null" ry="8" rx="7.618896" id="svg_1" cy="8" cx="7.837427" fill="{color}" fill-opacity="0.9"/></svg>`;
 * hm.buildIcon({
 *    svg: svg,
 *    opt: {
 *       size:24,
 *       color:"red"
 *    } 
 * });
 *  ```
 */
async function buildIcon(opt) {
    let settings = {
        img: null,             //   png, jpg. if not http in the beginning, look locally
        svg: null,             // svg file:  is a url or a string
        opt: null,              // size, color, anchor, text...s
    };

    Object.assign(settings, opt);

    if (!settings.img && !settings.svg) {
        return null;
    }

    let icon, iconSrc;

    if (settings.img) {
        // console.log("settings.img", settings.img);

        if (settings.img.substr(0, 4) == "http") // url
            iconSrc = settings.img;
        else
            iconSrc = cm.getProtocol() + settings.img; // local file

    }
    else if (settings.svg) {

        let url = null;
        iconSrc = settings.svg;
        if (settings.svg.substr(0, 4) == "http") // url
            url = settings.svg;
        else if (settings.svg.substr(0, 4) == "<svg") // url
            url = null;
        else
            url = cm.getHome() + settings.svg; //missing protocol, not an embedded string, look in local heremap module

        if (url) // an url to download
            iconSrc = await fetch(url)
                .then(res => {
                    if (res.status != 200)
                        return null;
                    return res.text();
                });
    }

    let iconOpt = { crossOrigin: true }; // to avoid issued with capture
    if (settings.opt && settings.opt.size) {
        let w, h;
        if (typeof settings.opt.size == "number")
            w = h = settings.opt.size;
        else
            [w, h] = settings.opt.size.split("x");

        iconOpt.size = { w: w, h: h };
    }
    if (settings.svg && settings.opt && settings.opt.ratio) {
        let w = null, h = null, match = null;

        let r = /width="(\d+)"/;
        match = iconSrc.match(r);
        if (match) w = match[1];

        r = /height="(\d+)"/;
        match = iconSrc.match(r);
        if (match) h = match[1];
        iconOpt.size = { w: Math.floor(w * settings.opt.ratio), h: Math.floor(h * settings.opt.ratio) };
    }

    if (settings.opt && settings.opt.anchor) {
        let w, h;
        if (typeof settings.opt.anchor == "number")
            w = h = settings.opt.anchor;
        else
            [w, h] = settings.opt.anchor.split("x");
        iconOpt.anchor = new H.math.Point(w, h);
    }

    // all other fields are treated as graphic enhanceent
    if (settings.opt) {
        for (let name in settings.opt) {
            if (name == "file" || name == "size" || name == "anchor") continue;
            let re = new RegExp("{" + name + "}", "g");
            iconSrc = iconSrc.replace(re, settings.opt[name]);
        }
    }

    // console.log("iconSrc", iconSrc);
    // console.log("iconOpt", iconOpt);
    icon = new H.map.Icon(iconSrc, iconOpt);

    return icon;

} //end of icon





/**
 * add a marker in a layer
 * svg files can be created with https://editor.method.ac/ 
 * @async
 * @alias hm:marker
 * @param opt {object} options to create the marker
 * @param [opt.layer] {string}   layer name
 * @param [opt.coord] {coord}   coord of the marker as \[lat,lng\]
 * @param [opt.icon] {string}   created from hm.buildIcon
 * @param [opt.svg] {string}   see hm.buildIcon
 * @param [opt.opt] {Object}   see hm.buildIcon
 * @param {function} opt.pointerenter  if enter, callback(target,coord,ev)
 * @param {function} opt.pointerClick  if click, callback(target,coord,ev)
 * @param {string} opt.data  optional data
 * @param {boolean} opt.bubble  if true, show buble on click with data
 * @param {boolean} opt.draggable  draggable marker
 * @param {function} opt.dragged  if dragged, callback(target,coord)
 * @example 
 * ```js
 * hm.marker({
 *    coord: [48.8,2.3],
 * });
 * 
 * hm.marker({
    *   svg: "svg/marker.svg",
    *   color:"red",
    *   size:16
    * });
    * 
 * hm.marker({
 *    img: "http://whatever.com/image.png",
 *    coord: [48.8,2.3]
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    data:"Hello world",
 *    bubble: true
 * });
 * 
 * hm.marker({
 *    coord: [48.8,2.3],
 *    draggable:true,
 *    dragged: function(target,coord) {console.log("dragged to",coord);}
 * });
*  ```
 */
async function marker(opt) {
    let settings = {
        layer: "default",       //  layer in which to add marker
        coord: null,            //  coord of the marker
        img: null,             //  image can be url, png, jpg..
        svg: null,             // svg file
        icon: null,              // icon previously created
        opt: {},               // opt for icon
        pointerEnter: null,     //  callback(target,coord,ev)
        pointerClick: null,     //  callback(target,coord,ev)
        data: null,             //  user data
        bubble: false,          //  show a bubble with user data
        draggable: false,       //  icon is draggalbe
        dragged: null           //  callback(target,coord)
    };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    settings.coord = { lat: settings.coord[0], lng: settings.coord[1] };

    // these parameters can be in opt.opt or directly in opt
    if (settings.color) settings.opt.color = settings.color;
    if (settings.size) settings.opt.size = settings.size;
    if (settings.ratio) settings.opt.ratio = settings.ratio;
    if (settings.anchor) settings.opt.size = settings.anchor;

    let markerOpt = null;
    if (settings.img || settings.svg) {
        let icon = await buildIcon(settings);
        markerOpt = { icon: icon };
    }
    else if (settings.icon) {
        markerOpt = { icon: settings.icon };
    }

    //console.log("marker settings.coord", settings.coord);
    let marker = new H.map.Marker(settings.coord, markerOpt);

    marker.draggable = settings.draggable;

    if (settings.dragged) marker.dragged = settings.dragged;

    if (settings.data)
        marker.setData(settings.data);

    // get click from mouse
    if (settings.pointerEnter) {
        marker.addEventListener("pointerenter", function (ev) {

            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);

        });
    }

    /************  callback when click on marker *****************************/
    if (settings.pointerClick) {
        marker.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);

        });
    }

    /************  show a bubble when clicking on marker *****************************/
    if (settings.bubble) {
        marker.addEventListener("tap", function (ev) {

            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);

            bubbleUnique(coordO2A(coord), data);
        });
    }

    layer.addObject(marker);
    return marker;

} //end of marker

/**
 * display a unique bubble. Associated CSS style is .H_ib_body
 * @alias hm:bubbleUnique
 * @param {Array} coord of the bubble
 * @param {String} txt html text to display
 */
function bubbleUnique(coord, txt) {

    if (!_bubbleMarker) {
        _bubbleMarker = new H.ui.InfoBubble(
            coordA2O(coord), {
                content: txt
            });

        _ui.addBubble(_bubbleMarker);
        _bubbleMarker.addClass("bubbleUnique");

    } else {
        _bubbleMarker.setPosition(coordA2O(coord));
        _bubbleMarker.setContent(txt);
        _bubbleMarker.open();
    }

}


/**
 * hide a unique bubble
 * @alias hm:bubbleUniqueHide
 */
function bubbleUniqueHide() {
    if (!_bubbleMarker)
        return;
    _bubbleMarker.close();
}




/**
 * Draw a polyline. 
 * @alias hm:polyline
 * @param opt {object}   options to draw polyline
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coords] {array} array of coords, as \[\[48.8,2.3\],\[48.85,2.4\],... \]
 * @param [opt.style] {object} optional graphic style
 * @param [opt.lineWidth=4] {number} line width
 * @param [opt.style.strokeColor=rgba(0, 128, 255, 0.7)] {string} line color
 * @param [opt.arrows] {object} optional arrow
 * @param [opt.data] {String} optional user data
 * @param [opt.pointerClick] {function} optional callback if click on line. format callback(target,coord,event)
 * @param [opt.pointerenter] {function} optional callback if mouse enters on line. format callback(target,coord,event)
 * @param [opt.pointerLeave] {function} optional callback if mouse leaves the line. format callback(target,coord,event)
 * @param [opt.z] {number} optional z level
* ```js
* hm.polyline({
    *    coords: [[48.8,2.3],[48.85,2.4],[48.9,2.6]],
    *    layer:"layer1"
    * });
    * 
    * hm.polyline({
    *    coords: coords,
    *    style: {
    *        lineWidth: 4,
    *        strokeColor: "red"
    *    },
    * });
    * 
    * hm.polyline({
        *    coords: coords,
        *    data:"Hello World",
        * });
    *  ```
 */
function polyline(opt) {
    let settings = {
        layer: "default",
        coords: null, // coords is list of array of [lat,lng] or array of object with {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)"
        },
        arrows: null,
        data: null,         // optional user data 
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };

    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();

    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polyline = new H.map.Polyline(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    // Z index
    if (settings.z) polyline.setZIndex(settings.z);
    // user data
    if (settings.data) polyline.setData(settings.data);

    if (settings.pointerEnter)
        polyline.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev);
        });
    if (settings.pointerLeave)
        polyline.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev);
        });
    if (settings.pointerClick)
        polyline.addEventListener("tap", function (ev) {
            let target = ev.target;
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev);
        });

    layer.addObject(polyline);

    return polyline;
}


/**
 * Draw a polygon
 * @alias hm:polygon
 * @param {Object} opt  options to draw a polygon. Same options as hm.polyline
 */
function polygon(opt) {
    let settings = {
        layer: "default",
        coords: "", // coords is array of [lat,lng] or array of {lat:,lng:}
        style: {
            lineWidth: 4,
            strokeColor: "rgba(0, 128, 255, 0.7)",
            fillColor: "rgba(0, 128, 255, 0.7)"
        },
        styleHover: null, // style si mouse over
        arrows: null,
        data: null, // additional data to carry
        z: null,
        pointerClick: null, // click
        pointerEnter: null, // call back
        pointerLeave: null // call back
    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }

    if (!settings.coords) {
        let e = new Error("Polyline: coords not found:"); // e.message
        throw (e);
    }

    let strip = new H.geo.Strip();
    settings.coords.forEach(function (point) {
        strip.pushLatLngAlt(point[0], point[1]);
    });

    let polygon = new H.map.Polygon(strip, {
        style: settings.style,
        data: settings.data,
        arrows: settings.arrows
    });

    if (settings.data) polygon.setData(settings.data);
    // Z index
    if (settings.z) polyline.setZIndex(settings.z);

    // si un style de hover
    if (settings.styleHover) {
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            target.setStyle(settings.styleHover);
        });
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            target.setStyle(settings.style);
        });
    }

    if (settings.pointerEnter)
        polygon.addEventListener("pointerenter", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerEnter(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerLeave)
        polygon.addEventListener("pointerleave", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerLeave(target, coordO2A(coord), ev, data);
        });
    if (settings.pointerClick)
        polygon.addEventListener("tap", function (ev) {
            let target = ev.target;
            let data = target.getData();
            let coord = _map.screenToGeo(ev.currentPointer.viewportX, ev.currentPointer.viewportY);
            settings.pointerClick(target, coordO2A(coord), ev, data);
        });

    layer.addObject(polygon);

    return polygon;
} // end of polygon

/**
 * draw a circle
 * @alias hm:circle
 * @param opt {*}   option for circle
 * @param [opt.layer] {String} optional layer to use 
 * @param [opt.coord] {array} center of the circle, as \[48.8,2.3\]
 * @param [opt.radius] {number} radius in meter
 * @param [opt.style] {object} optional graphic style
 * @param [opt.style.strokeColor] {string} color of perimeter
 * @param [opt.style.lineWidth] {number} line width
 * @param [opt.style.fillColor] {string} fill color
 */
function circle(opt) {
    let settings = {
        layer: "default",
        coord: null,
        radius: 100, // meters
        style: {
            strokeColor: "rgba(55, 85, 170, 0.2)", // Color of the perimeter
            lineWidth: 2,
            fillColor: "rgba(0, 128, 0, 0.1)"  // Color of the circle
        }

    };
    Object.assign(settings, opt);

    let layer = layerFind(settings.layer);
    if (!layer) {
        let e = new Error("layer not found:" + settings.layer); // e.message
        throw (e);
    }
    let circle = new H.map.Circle(
        // The central point of the circle
        coordA2O(settings.coord),
        // The radius of the circle in meters
        settings.radius,
        {
            style: settings.style
        }
    );

    layer.addObject(circle);
    return circle;
}




/**
 * watch position on HTML5 position. requires HTTPS
 * @async
 * @alias hm:locateMe
 * @param callback {function}  callback when coord changes. Format: callback(coord,accuracy) 
 * @param opt {Object} optional graphic options
 * @param [opt.position] {object}  graphic options for center. See buildIcon
 * @param [opt.position.svg] {string}  svg file
 * @param [opt.position.color] {string}  color for  {color} tag
 * @param [opt.position.size] {number}  size of icon
 * @param [opt.position.anchor] {number}  anchor of icon
 * @param [opt.accuracy] {object}  graphic options for accuracy representation
 * @param [opt.accuracy.strokeColor] {String}  color of circle line representing accuracy area
 * @param [opt.accuracy.lineWidth] {number}  width of line of circle
 * @param [opt.accuracy.fillColor] {String}  fill color of circle representing accuracy area
 */
async function locateMe(callback, opt) {

    // if no callback, remove the watch
    if (navigator.geolocation) {
        if (!callback && _locateMe) {
            navigator.geolocation.clearWatch(_locateMe);
            _locateMe = null;
            return;
        }

        let settings = {
            position: {
                svg: "svg/crosshair.svg",
                color: "black",
                size: 24,
                anchor: 12
            },
            accuracy: {
                strokeColor: "rgba(0, 128, 0, 0.8)", // Color of the perimeter
                lineWidth: 2,
                fillColor: "rgba(0, 128, 0, 0.4)"  // Color of the circle
            }
        };
        Object.assign(settings, opt);

        let iconCrossHair = await buildIcon({
            svg: settings.position.svg,
            img: settings.position.img,
            opt: settings.position
        });


        //navigator.geolocation.getCurrentPosition(function pos(position) {
        _locateMe = navigator.geolocation.watchPosition((position) => {
            let gps = [position.coords.latitude, position.coords.longitude];

            layerEmpty("_gps");

            /* circle showing the accuracy radius*/
            circle({
                layer: "_gps",
                coord: gps,
                radius: position.coords.accuracy,
                style: settings.accuracy
            });

            marker({
                layer: "_gps",
                coord: gps,
                icon: iconCrossHair
            });

            callback(gps, position.coords.accuracy);
        }, (error) => {
            let msg = "";
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    msg += "User denied the request for Geolocation.";
                    break;
                case error.POSITION_UNAVAILABLE:
                    msg += "Location information is unavailable.";
                    break;
                case error.TIMEOUT:
                    msg += "timed out.";
                    break;
                case error.UNKNOWN_ERROR:
                    msg += "An unknown error occurred.";
                    break;
            }
            let e = new Error("HTML5 location error:" + msg); // e.message
            throw (e);
        }, {
                enableHighAccuracy: true
            }
        );
    }
    else {
        let e = new Error("no HTML5 geolocation capabilities"); // e.message
        throw (e);
    }
}


/**
 * perform a screenshot of the map and returns a promise with the data
 * @async
 * @alias hm:locateMe
 * @param opt {object} options for screenshot
 * @param [opt.name] {string} filename for download
 * @param [opt.ui] {boolean} true to save ui (scale, etc..)
 * @param opt {object} options for screenshot
 * 
 * @returns {data} binary data of image
 * 
 */
function screenshot(opt) {
    let para = null;
    if (opt && opt.ui)
        para = [_ui];

    return new Promise(
        (resolve, reject) => {
            _map.capture(function (canvas) {
                if (!canvas)
                    return reject("Map screenshot not supported");

                let dataURL = canvas.toDataURL();

                if (opt && opt.name) {
                    let a = document.createElement('a');
                    a.href = dataURL;
                    a.target = '_blank';
                    a.download = opt.name;
                    document.body.appendChild(a);
                    a.click();
                }
                resolve(dataURL);


            }, para);
        });
}


function getMap() {
    return _map;
}

function getUI() {
    return _ui;
}

module.exports = {
    coordO2A: coordO2A,
    coordA2O: coordA2O,
    getMap: getMap,
    getUI: getUI,
    map: map,
    getAvailableMapStyle: getAvailableMapStyle,
    setScheme: setScheme,
    layerCreate: layerCreate,
    layerFind: layerFind,
    layerDelete: layerDelete,
    layerEmpty: layerEmpty,
    buildIcon: buildIcon,
    bubbleUnique: bubbleUnique,
    bubbleUniqueHide: bubbleUniqueHide,
    marker: marker,
    circle: circle,
    polyline: polyline,
    polygon: polygon,
    getCenter: getCenter,
    setCenter: setCenter,
    getZoom: getZoom,
    setZoom: setZoom,
    getviewBB: getViewBB,
    setViewBB: setViewBB,
    locateMe: locateMe,
    screenshot: screenshot

};






},{"./common.js":10}],13:[function(require,module,exports){
"use strict";
const cm = require("./common.js");

/**
 * compute a route with optional waypooints. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 *  @async
 * @alias hm:route
 * @param {object} source - source as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param {object} dest - dest as \[lat,lng\]. Can be array of \[lat,lng\] to define waypoints
 * @param opt {object} route options 
 * @param [opt.mode=fastest;car;traffic:disabled] {string}  routing mode
 * @param [opt.routeattributes=waypoints,summary,shape] {string}  route attributes
 * @param [opt.maneuverattributes=direction,action] {string}  manoeuver attributes
 * @returns {object} returns { summary: object, coords:array,route: object, body:object}. coords is array of coord, to be used with hm.polyline. 
 *
 * @example
  * ```js
  * const res = await hm.route([48.8,2.3],[48.7,2.5]);
  * console.log (res.summary);
  * 
  * const res = await hm.route([[48.8,2.3],[48.9,2.7]], [49.3,2.5]);
  * console.log (res.route); 
  * 
  * const res = await hm.route([48.8,2.3], [[48.9,2.7], [49.3,2.5]]);
  * console.log (res.summary); 
  * ```
 */
async function route(source, dest, opt) {

    const settings = {
        mode: "fastest;car;traffic:disabled",
        representation: "linkPaging",
        routeattributes: "waypoints,summary,shape",
        maneuverattributes: "direction,action"
    };

    const params = cm.addCredentials(settings, opt);

    // 1 seul source ou array de source ?
    let id = 0;
    if (Array.isArray(source[0]))
        for (var i = 0; i < source.length; i++) {
            let coord = source[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = source[0] + "," + source[1];

    if (Array.isArray(dest[0]))

        for (let i = 0; i < dest.length; i++) {
            let coord = dest[i];
            params["waypoint" + id++] = coord[0] + "," + coord[1];
        }
    else
        params["waypoint" + id++] = dest[0] + "," + dest[1];

    const url = cm.buildUrl("route", "api.here.com/routing/7.2/calculateroute.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            const route = res.body.response.route[0];
            const summary = route.summary;
            const coords = route.shape.map((latlng => latlng.split(",")));

            return { summary: summary, coords: coords, route: route, body: res.body };

        });

}


/**
 * compute an isoline. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * @async
 * @alias hm:isoline
 * @param opt {object} option for isoline
 * @param [opt.start] {coord} coord for starting point of isoline
 * @param [opt.destination] {coord} coord for destination point of isoline
 * @param [opt.rangeType="time"] {string} time or distance
 * @param [opt.range] {number} range in seconds or in meters
 * @param [opt.mode="fastest;car;traffic:disabled"] {String} routing mode
 * @param [opt.linkattributes=sh] {String} attributes to be returned
 * 
 * @returns {object}  returns { poly:array, body:object }. Poly is array of coords, body is full answer
 */
async function isoline(opt) {

    const settings = {
        start: null,                            // for direct isoline
        destination: null,                      // for reverse isoline
        rangeType: "time",                      // time or distance
        range: null,                            // in seconds or meters
        linkattributes: "sh",                   // to get the shape
        mode: "fastest;car;traffic:disabled",   //shortest;car;traffic:disabled 
    };
    const params = cm.addCredentials(settings, opt);

    if (params.start)
        params.start = "geo!" + params.start[0] + "," + params.start[1];
    if (params.destination)
        params.destination = "geo!" + params.destination[0] + "," + params.destination[1];

    if (!params.start && !params.destination) {
        let e = new Error("Isoline routing : missing start or destination"); // e.message
        throw (e);
    }
    if (!params.range) {
        let e = new Error("Isoline routing : missing range"); // e.message
        throw (e);
    }

    const url = cm.buildUrl("isoline.route", "api.here.com/routing/7.2/calculateisoline.json");
    return cm.hereRest(url, params, "post")
        .then(res => {

            // array of lat,lng, to be transformed into array of [lat,lng]
            const shape = res.body.response.isoline[0].component[0].shape;
            const poly = shape.map(point => point.split(","));

            return { poly: poly, body: res.body };
        });

}


/**
 * compute a matrix. [see more info on optional parameters] (http://documentation.developer.here.com/pdf/routing_hlp/7.2.100/Routing%20API%20v7.2.100%20Developer's%20Guide.pdf)
 * 
 * Matrix size is limited to 1x100,100X1 or 15*N
 *  @async
 * @alias hm:matrix
 * @param source {object} source as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param dest {object} dest as \[lat,lng\]. Can be array of \[lat,lng\]
 * @param opt {object} additional optional parameters like  mode, summaryAttributes
 * @param [opt.mode="fastest;car;traffic:enabled"] {string} routing mode to compute matrix
 * @param [opt.summaryAttributes="tt,di"] {string} attributes in the answer
 * 
 * @returns {object} { entries: object, body:object }. entries is the array of {start,stop} information. body is full json answer
 * @example
 * ```js
 * const res = await hm.matrix({
 *      source:[48.8,2.3]
 *      dest:[[48.7,2.5],[48.1,2.0],[44.2,2.3]]
 * });
 * console.log (res.entries); 
 * ```
 */

async function matrix(source, dest, opt) {

    var settings = {
        mode: "fastest;car;traffic:enabled",
        summaryAttributes: "tt,di"
    };
    const params = cm.addCredentials(settings, opt);

    if (!Array.isArray(source[0])) // if only one coord
        source = [source];
    source.forEach((coord, i) => {
        params["start" + i] = coord[0] + "," + coord[1];
    });

    if (!Array.isArray(dest[0])) // if only one coord
        dest = [dest];
    dest.forEach((coord, i) => {
        params["destination" + i] = coord[0] + "," + coord[1];
    });

    const url = cm.buildUrl("matrix.route", "api.here.com/routing/7.2/calculatematrix.json");
    return cm.hereRest(url, params, "post")
        .then(res => {
            return { entries: res.body.response.matrixEntry, body: res.body };
        });


}



/**
 * Compute the detour for each waypoint provided, compared to normal route from A to B
 * 
 * @async
 * @alias hm:detour
 * @param start {coord}  starting point for route
 * @param stop {coord}   destination point of route
 * @param waypoints {array}  list of watypoints to test 
 * @returns {object} returns {reference,waypoints:[ {coord,distA,timeA,distB,timeB}]}
 */
async function detour(start, stop, waypoints) {
    // eslint-disable-next-line   no-undef
    return new Promise(
        async (resolve, reject) => {
            //let tStart = new Date();

            if (!start) return reject("missing start point");
            if (!stop) return reject("missing stop point");
            if (!waypoints) return reject("missing waypoints");
            if (!Array.isArray) return reject("waypoints should be an array");


            // initialise le resultat 
            let res = {
                reference: {},
                waypoints: []
            };

            // calcul les coords nonPostGres, creer l'array de coord des waypoints.
            let dest = [stop]; // so we have a distance/time reference, not same as from routing 1:1
            waypoints.forEach(waypoint => {
                dest.push(waypoint);
                res.waypoints.push(
                    { coord: waypoint }
                );
            });
            // inspect(dest, "dest from detour")

            // compute start to all waypoint, 1st waypoint is stop to get a reference
            let p1 = matrix(start, dest, { mode: "fastest;car;traffic:disabled" });

            // compute from all waypoint to stop, 1st waypoint is start to get another reference
            dest[0] = start;
            let p2 = matrix(dest, stop, { mode: "fastest;car;traffic:disabled" });
            // wait for both matrix to complete

            // eslint-disable-next-line   no-undef
            const result = await Promise.all([p1, p2]);

            // process first part: start => N waypoints
            let entries = result[0].entries;
            // first entry is start stop
            let dist = entries[0].summary.distance;
            let time = entries[0].summary.travelTime;
            res.reference.start = start;
            res.reference.stop = stop;
            res.reference.distance = dist;
            res.reference.time = time; // the reference sans waypoint

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixA" + i);
                    //console.log(start, "associated start");
                    //console.log(dest[i], "associated dest" + i);
                    return;
                }

                let id = entry.destinationIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distA = dist;
                res.waypoints[id - 1].timeA = time;
            });


            // process second part: N waypoints => stop
            entries = result[1].entries;
            //inspect(entries[0], "matrixB0");

            res.reference.distance2 = entries[0].summary.distance;
            res.reference.time2 = entries[0].summary.travelTime;

            entries.forEach((entry, i) => {
                if (i == 0) return; // skip the first which is start stop

                if (entry.status == "failed") {
                    //console.log(entry, "error on matrixB" + i);
                    //console.log(entry, "associated start" + i);
                    //console.log(stop, "associated stop");
                    return;
                }
                let id = entry.startIndex;
                let dist = entry.summary.distance;
                let time = entry.summary.travelTime;
                res.waypoints[id - 1].distB = dist;
                res.waypoints[id - 1].timeB = time;
            });
            return resolve(res);
        });

}


module.exports = {
    matrix: matrix,
    route: route,
    isoline: isoline,
    detour: detour
};


},{"./common.js":10}],"heremap.js":[function(require,module,exports){
(function (process){
"use strict";

/*
 * @module HEREMAP
 * @typicalname hm
 */

let modules = {};
Object.assign(modules, require("./common.js"));
Object.assign(modules, require("./routing.js"));
Object.assign(modules, require("./geocoding.js"));

if (process.browser) {
    Object.assign(modules, require("./map.js"));
    Object.assign(modules, require("./cluster.js"));
}
// export all the above
module.exports = modules;

//console.log("module.exports", module.exports);
//console.log("process.browser", process.browser);
}).call(this,require('_process'))

},{"./cluster.js":9,"./common.js":10,"./geocoding.js":11,"./map.js":12,"./routing.js":13,"_process":1}]},{},[10,12,13,11,9])("heremap.js")
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy4uLy4uL0FwcERhdGEvUm9hbWluZy9ucG0vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2FnZW50LWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9jbGllbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXF1ZXN0LWJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9yZXNwb25zZS1iYXNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9BcHBEYXRhL1JvYW1pbmcvbnBtL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsImNsdXN0ZXIuanMiLCJjb21tb24uanMiLCJnZW9jb2RpbmcuanMiLCJtYXAuanMiLCJyb3V0aW5nLmpzIiwiaGVyZW1hcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2NUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJmdW5jdGlvbiBBZ2VudCgpIHtcbiAgdGhpcy5fZGVmYXVsdHMgPSBbXTtcbn1cblxuW1widXNlXCIsIFwib25cIiwgXCJvbmNlXCIsIFwic2V0XCIsIFwicXVlcnlcIiwgXCJ0eXBlXCIsIFwiYWNjZXB0XCIsIFwiYXV0aFwiLCBcIndpdGhDcmVkZW50aWFsc1wiLCBcInNvcnRRdWVyeVwiLCBcInJldHJ5XCIsIFwib2tcIiwgXCJyZWRpcmVjdHNcIixcbiBcInRpbWVvdXRcIiwgXCJidWZmZXJcIiwgXCJzZXJpYWxpemVcIiwgXCJwYXJzZVwiLCBcImNhXCIsIFwia2V5XCIsIFwicGZ4XCIsIFwiY2VydFwiXS5mb3JFYWNoKGZuID0+IHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHRoaXMuX2RlZmF1bHRzLnB1c2goe2ZuLCBhcmdzfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuX3NldERlZmF1bHRzID0gZnVuY3Rpb24ocmVxKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaChkZWYgPT4ge1xuICAgICAgcmVxW2RlZi5mbl0uYXBwbHkocmVxLCBkZWYuYXJncyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50O1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG5sZXQgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxuY29uc3QgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5jb25zdCBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5jb25zdCBSZXNwb25zZUJhc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlLWJhc2UnKTtcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbmNvbnN0IHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufTtcblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gKCkgPT4ge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgdHJpbSA9ICcnLnRyaW1cbiAgPyBzID0+IHMudHJpbSgpXG4gIDogcyA9PiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpO1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIGNvbnN0IHBhaXJzID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIG9ialtrZXldKTtcbiAgfVxuICByZXR1cm4gcGFpcnMuam9pbignJicpO1xufVxuXG4vKipcbiAqIEhlbHBzICdzZXJpYWxpemUnIHdpdGggc2VyaWFsaXppbmcgYXJyYXlzLlxuICogTXV0YXRlcyB0aGUgcGFpcnMgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICovXG5cbmZ1bmN0aW9uIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXksIHZhbCkge1xuICBpZiAodmFsICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGZvcihjb25zdCBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBgJHtrZXl9WyR7c3Via2V5fV1gLCB2YWxbc3Via2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBjb25zdCBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuICBsZXQgcGFpcjtcbiAgbGV0IHBvcztcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBwYWlyID0gcGFpcnNbaV07XG4gICAgcG9zID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKHBvcyA9PSAtMSkge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyKV0gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKDAsIHBvcykpXSA9XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnNsaWNlKHBvcyArIDEpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEV4cG9zZSBwYXJzZXIuXG4gKi9cblxucmVxdWVzdC5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuXG4vKipcbiAqIERlZmF1bHQgTUlNRSB0eXBlIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKi9cblxucmVxdWVzdC50eXBlcyA9IHtcbiAgaHRtbDogJ3RleHQvaHRtbCcsXG4gIGpzb246ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgeG1sOiAndGV4dC94bWwnLFxuICB1cmxlbmNvZGVkOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgJ2Zvcm0tZGF0YSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG4vKipcbiAqIERlZmF1bHQgc2VyaWFsaXphdGlvbiBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQuc2VyaWFsaXplWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKG9iail7XG4gKiAgICAgICByZXR1cm4gJ2dlbmVyYXRlZCB4bWwgaGVyZSc7XG4gKiAgICAgfTtcbiAqXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemUgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcbn07XG5cbi8qKlxuICAqIERlZmF1bHQgcGFyc2Vycy5cbiAgKlxuICAqICAgICBzdXBlcmFnZW50LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IGZ1bmN0aW9uKHN0cil7XG4gICogICAgICAgcmV0dXJuIHsgb2JqZWN0IHBhcnNlZCBmcm9tIHN0ciB9O1xuICAqICAgICB9O1xuICAqXG4gICovXG5cbnJlcXVlc3QucGFyc2UgPSB7XG4gICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBwYXJzZVN0cmluZyxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBoZWFkZXIgYHN0cmAgaW50b1xuICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1hcHBlZCBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XG4gIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGZpZWxkcyA9IHt9O1xuICBsZXQgaW5kZXg7XG4gIGxldCBsaW5lO1xuICBsZXQgZmllbGQ7XG4gIGxldCB2YWw7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgbGV0IHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICBsZXQgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHJlcSA9IHRoaXMucmVxO1xuICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kO1xuICBjb25zdCB1cmwgPSByZXEudXJsO1xuXG4gIGNvbnN0IG1zZyA9IGBjYW5ub3QgJHttZXRob2R9ICR7dXJsfSAoJHt0aGlzLnN0YXR1c30pYDtcbiAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBlcnIgPSBuZXcgRXJyb3IoJ1BhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlJyk7XG4gICAgICBlcnIucGFyc2UgPSB0cnVlO1xuICAgICAgZXJyLm9yaWdpbmFsID0gZTtcbiAgICAgIC8vIGlzc3VlICM2NzU6IHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgICAgLy8gaWU5IGRvZXNuJ3QgaGF2ZSAncmVzcG9uc2UnIHByb3BlcnR5XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IHR5cGVvZiBzZWxmLnhoci5yZXNwb25zZVR5cGUgPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLnhoci5yZXNwb25zZVRleHQgOiBzZWxmLnhoci5yZXNwb25zZTtcbiAgICAgICAgLy8gaXNzdWUgIzg3NjogcmV0dXJuIHRoZSBodHRwIHN0YXR1cyBjb2RlIGlmIHRoZSByZXNwb25zZSBwYXJzaW5nIGZhaWxzXG4gICAgICAgIGVyci5zdGF0dXMgPSBzZWxmLnhoci5zdGF0dXMgPyBzZWxmLnhoci5zdGF0dXMgOiBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IGVyci5zdGF0dXM7IC8vIGJhY2t3YXJkcy1jb21wYXQgb25seVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1cyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG5cbiAgICBsZXQgbmV3X2VycjtcbiAgICB0cnkge1xuICAgICAgaWYgKCFzZWxmLl9pc1Jlc3BvbnNlT0socmVzKSkge1xuICAgICAgICBuZXdfZXJyID0gbmV3IEVycm9yKHJlcy5zdGF0dXNUZXh0IHx8ICdVbnN1Y2Nlc3NmdWwgSFRUUCByZXNwb25zZScpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goY3VzdG9tX2Vycikge1xuICAgICAgbmV3X2VyciA9IGN1c3RvbV9lcnI7IC8vIG9rKCkgY2FsbGJhY2sgY2FuIHRocm93XG4gICAgfVxuXG4gICAgLy8gIzEwMDAgZG9uJ3QgY2F0Y2ggZXJyb3JzIGZyb20gdGhlIGNhbGxiYWNrIHRvIGF2b2lkIGRvdWJsZSBjYWxsaW5nIGl0XG4gICAgaWYgKG5ld19lcnIpIHtcbiAgICAgIG5ld19lcnIub3JpZ2luYWwgPSBlcnI7XG4gICAgICBuZXdfZXJyLnJlc3BvbnNlID0gcmVzO1xuICAgICAgbmV3X2Vyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgc2VsZi5jYWxsYmFjayhuZXdfZXJyLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBNaXhpbiBgRW1pdHRlcmAgYW5kIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5SZXF1ZXN0QmFzZShSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0IENvbnRlbnQtVHlwZSB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy54bWwgPSAnYXBwbGljYXRpb24veG1sJztcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgnYXBwbGljYXRpb24veG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdDb250ZW50LVR5cGUnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEFjY2VwdCB0byBgdHlwZWAsIG1hcHBpbmcgdmFsdWVzIGZyb20gYHJlcXVlc3QudHlwZXNgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgc3VwZXJhZ2VudC50eXBlcy5qc29uID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odHlwZSl7XG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IEF1dGhvcml6YXRpb24gZmllbGQgdmFsdWUgd2l0aCBgdXNlcmAgYW5kIGBwYXNzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXNzXSBvcHRpb25hbCBpbiBjYXNlIG9mIHVzaW5nICdiZWFyZXInIGFzIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGggJ3R5cGUnIHByb3BlcnR5ICdhdXRvJywgJ2Jhc2ljJyBvciAnYmVhcmVyJyAoZGVmYXVsdCAnYmFzaWMnKVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zKXtcbiAgaWYgKDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHBhc3MgPSAnJztcbiAgaWYgKHR5cGVvZiBwYXNzID09PSAnb2JqZWN0JyAmJiBwYXNzICE9PSBudWxsKSB7IC8vIHBhc3MgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZXBsYWNlZCB3aXRoIG9wdGlvbnNcbiAgICBvcHRpb25zID0gcGFzcztcbiAgICBwYXNzID0gJyc7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hID8gJ2Jhc2ljJyA6ICdhdXRvJyxcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgZW5jb2RlciA9IHN0cmluZyA9PiB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICBjb25zdCBmbiA9IHRoaXMuX2NhbGxiYWNrO1xuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIGlmIChlcnIpIHtcbiAgICBpZiAodGhpcy5fbWF4UmV0cmllcykgZXJyLnJldHJpZXMgPSB0aGlzLl9yZXRyaWVzIC0gMTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIGZuKGVyciwgcmVzKTtcbn07XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggeC1kb21haW4gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24oKXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSAoKSA9PiB7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHRoaXMuX2VuZCgpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fYWJvcnRlZCkgcmV0dXJuIHRoaXMuY2FsbGJhY2soRXJyb3IoXCJUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGV2ZW4gYmVmb3JlIC5lbmQoKSB3YXMgY2FsbGVkXCIpKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcbiAgY29uc3QgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIGxldCBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIGxldCBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICBjb25zdCBoYW5kbGVQcm9ncmVzcyA9IChkaXJlY3Rpb24sIGUpID0+IHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gc2VlICMxMTQ5XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmICdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgY29uc3QgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGxldCBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yIChjb25zdCBmaWVsZCBpbiB0aGlzLmhlYWRlcikge1xuICAgIGlmIChudWxsID09IHRoaXMuaGVhZGVyW2ZpZWxkXSkgY29udGludWU7XG5cbiAgICBpZiAodGhpcy5oZWFkZXIuaGFzT3duUHJvcGVydHkoZmllbGQpKVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XG4gIH1cblxuICBpZiAodGhpcy5fcmVzcG9uc2VUeXBlKSB7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMuX3Jlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8vIHNlbmQgc3R1ZmZcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XG5cbiAgLy8gSUUxMSB4aHIuc2VuZCh1bmRlZmluZWQpIHNlbmRzICd1bmRlZmluZWQnIHN0cmluZyBhcyBQT1NUIHBheWxvYWQgKGluc3RlYWQgb2Ygbm90aGluZylcbiAgLy8gV2UgbmVlZCBudWxsIGhlcmUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgeGhyLnNlbmQodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnID8gZGF0YSA6IG51bGwpO1xufTtcblxucmVxdWVzdC5hZ2VudCA9ICgpID0+IG5ldyBBZ2VudCgpO1xuXG5bXCJHRVRcIiwgXCJQT1NUXCIsIFwiT1BUSU9OU1wiLCBcIlBBVENIXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdLmZvckVhY2gobWV0aG9kID0+IHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICBjb25zdCByZXEgPSBuZXcgcmVxdWVzdC5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB0aGlzLl9zZXREZWZhdWx0cyhyZXEpO1xuICAgIGlmIChmbikge1xuICAgICAgcmVxLmVuZChmbik7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH07XG59KTtcblxuQWdlbnQucHJvdG90eXBlLmRlbCA9IEFnZW50LnByb3RvdHlwZVsnZGVsZXRlJ107XG5cbi8qKlxuICogR0VUIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5nZXQgPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdHRVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIEhFQUQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmhlYWQgPSAodXJsLCBkYXRhLCBmbikgPT4ge1xuICBjb25zdCByZXEgPSByZXF1ZXN0KCdIRUFEJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBPUFRJT05TIHF1ZXJ5IHRvIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5vcHRpb25zID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnT1BUSU9OUycsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBERUxFVEUgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlbCh1cmwsIGRhdGEsIGZuKSB7XG4gIGNvbnN0IHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufVxuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gKHVybCwgZGF0YSwgZm4pID0+IHtcbiAgY29uc3QgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBSZXF1ZXN0QmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ2xlYXIgcHJldmlvdXMgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKXtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKTtcbiAgZGVsZXRlIHRoaXMuX3RpbWVyO1xuICBkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlc3BvbnNlIGJvZHkgcGFyc2VyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGluY29taW5nIGRhdGEgaW50byByZXF1ZXN0LmJvZHlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShmbil7XG4gIHRoaXMuX3BhcnNlciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGZvcm1hdCBvZiBiaW5hcnkgcmVzcG9uc2UgYm9keS5cbiAqIEluIGJyb3dzZXIgdmFsaWQgZm9ybWF0cyBhcmUgJ2Jsb2InIGFuZCAnYXJyYXlidWZmZXInLFxuICogd2hpY2ggcmV0dXJuIEJsb2IgYW5kIEFycmF5QnVmZmVyLCByZXNwZWN0aXZlbHkuXG4gKlxuICogSW4gTm9kZSBhbGwgdmFsdWVzIHJlc3VsdCBpbiBCdWZmZXIuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAucmVzcG9uc2VUeXBlKCdibG9iJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVxdWVzdCBib2R5IHNlcmlhbGl6ZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgZGF0YSBzZXQgdmlhIC5zZW5kIG9yIC5hdHRhY2ggaW50byBwYXlsb2FkIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKGZuKXtcbiAgdGhpcy5fc2VyaWFsaXplciA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRpbWVvdXRzLlxuICpcbiAqIC0gcmVzcG9uc2UgdGltZW91dCBpcyB0aW1lIGJldHdlZW4gc2VuZGluZyByZXF1ZXN0IGFuZCByZWNlaXZpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIHJlc3BvbnNlLiBJbmNsdWRlcyBETlMgYW5kIGNvbm5lY3Rpb24gdGltZS5cbiAqIC0gZGVhZGxpbmUgaXMgdGhlIHRpbWUgZnJvbSBzdGFydCBvZiB0aGUgcmVxdWVzdCB0byByZWNlaXZpbmcgcmVzcG9uc2UgYm9keSBpbiBmdWxsLiBJZiB0aGUgZGVhZGxpbmUgaXMgdG9vIHNob3J0IGxhcmdlIGZpbGVzIG1heSBub3QgbG9hZCBhdCBhbGwgb24gc2xvdyBjb25uZWN0aW9ucy5cbiAqXG4gKiBWYWx1ZSBvZiAwIG9yIGZhbHNlIG1lYW5zIG5vIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBtcyBvciB7cmVzcG9uc2UsIGRlYWRsaW5lfVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gdGltZW91dChvcHRpb25zKXtcbiAgaWYgKCFvcHRpb25zIHx8ICdvYmplY3QnICE9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zO1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHRpbWVvdXQgb3B0aW9uXCIsIG9wdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiByZXRyeShjb3VudCwgZm4pe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmNvbnN0IEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG92ZXJyaWRlID0gdGhpcy5fcmV0cnlDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gdW5kZWZpbmVkIGZhbGxzIGJhY2sgdG8gZGVmYXVsdHNcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXMgJiYgcmVzLnN0YXR1cyAmJiByZXMuc3RhdHVzID49IDUwMCAmJiByZXMuc3RhdHVzICE9IDUwMSkgcmV0dXJuIHRydWU7XG4gIGlmIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgJiYgfkVSUk9SX0NPREVTLmluZGV4T2YoZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTdXBlcmFnZW50IHRpbWVvdXRcbiAgICBpZiAoZXJyLnRpbWVvdXQgJiYgZXJyLmNvZGUgPT0gJ0VDT05OQUJPUlRFRCcpIHJldHVybiB0cnVlO1xuICAgIGlmIChlcnIuY3Jvc3NEb21haW4pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cnkgcmVxdWVzdFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9yZXRyeSA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgLy8gbm9kZVxuICBpZiAodGhpcy5yZXEpIHtcbiAgICB0aGlzLnJlcSA9IG51bGw7XG4gICAgdGhpcy5yZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuXG4gIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aW1lZG91dCA9IGZhbHNlO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cbi8qKlxuICogUHJvbWlzZSBzdXBwb3J0XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICBpZiAoIXRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChpbm5lclJlc29sdmUsIGlubmVyUmVqZWN0KSA9PiB7XG4gICAgICBzZWxmLm9uKCdlcnJvcicsIGlubmVyUmVqZWN0KTtcbiAgICAgIHNlbGYuZW5kKChlcnIsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSBpbm5lclJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIGlubmVyUmVzb2x2ZShyZXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKGNiKSB7XG4gIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBjYik7XG59O1xuXG4vKipcbiAqIEFsbG93IGZvciBleHRlbnNpb25cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZuKSB7XG4gIGZuKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5vayA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgY2IpIHRocm93IEVycm9yKFwiQ2FsbGJhY2sgcmVxdWlyZWRcIik7XG4gIHRoaXMuX29rQ2FsbGJhY2sgPSBjYjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSyA9IGZ1bmN0aW9uKHJlcykge1xuICBpZiAoIXJlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl9va0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX29rQ2FsbGJhY2socmVzKTtcbiAgfVxuXG4gIHJldHVybiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwO1xufTtcblxuLyoqXG4gKiBHZXQgcmVxdWVzdCBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCl7XG4gIHJldHVybiB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxuICogVGhpcyBpcyBhIGRlcHJlY2F0ZWQgaW50ZXJuYWwgQVBJLiBVc2UgYC5nZXQoZmllbGQpYCBpbnN0ZWFkLlxuICpcbiAqIChnZXRIZWFkZXIgaXMgbm8gbG9uZ2VyIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgc3VwZXJhZ2VudCBjb2RlIGJhc2UpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldEhlYWRlciA9IFJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0IGhlYWRlciBgZmllbGRgIHRvIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0LlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAqICAgICAgICAuc2V0KCdYLUFQSS1LZXknLCAnZm9vYmFyJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmaWVsZCwgdmFsKXtcbiAgaWYgKGlzT2JqZWN0KGZpZWxkKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWw7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgdW5kZWZpbmVkID09PSBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLmZpZWxkKGtleSwgbmFtZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgZm9yIChjb25zdCBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcbiAgaWYgKG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsKSB7XG4gICAgdmFsID0gJycgKyB2YWw7XG4gIH1cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJhc2ljICR7YmFzZTY0RW5jb2RlcihgJHt1c2VyfToke3Bhc3N9YCl9YCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmVhcmVyJzogLy8gdXNhZ2Ugd291bGQgYmUgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3VzZXJ9YCk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aW5nIGluIGJyb3dzZXIgWEhSIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgfVxuICB0aGlzLl9tYXhSZXNwb25zZVNpemUgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICBsZXQgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiLnNlbmQoKSBjYW4ndCBiZSB1c2VkIGlmIC5hdHRhY2goKSBvciAuZmllbGQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqICYmICF0aGlzLl9kYXRhKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB7fTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YSAmJiB0aGlzLl9kYXRhICYmIHRoaXMuX2lzSG9zdCh0aGlzLl9kYXRhKSkge1xuICAgIHRocm93IEVycm9yKFwiQ2FuJ3QgbWVyZ2UgdGhlc2Ugc2VuZCBjYWxsc1wiKTtcbiAgfVxuXG4gIC8vIG1lcmdlXG4gIGlmIChpc09iaiAmJiBpc09iamVjdCh0aGlzLl9kYXRhKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAvLyBkZWZhdWx0IHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gYCR7dGhpcy5fZGF0YX0mJHtkYXRhfWBcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc29ydFF1ZXJ5ID0gZnVuY3Rpb24oc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgY29uc3QgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3QgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9zb3J0KSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnN1YnN0cmluZygwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFyci5qb2luKCcmJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdCBvbmx5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gKCkgPT4ge2NvbnNvbGUudHJhY2UoXCJVbnN1cHBvcnRlZFwiKTt9XG5cbi8qKlxuICogSW52b2tlIGNhbGxiYWNrIHdpdGggdGltZW91dCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3RpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKHJlYXNvbiwgdGltZW91dCwgZXJybm8pe1xuICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7cmVhc29uICsgdGltZW91dH1tcyBleGNlZWRlZGApO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1RpbWVvdXQgb2YgJywgc2VsZi5fdGltZW91dCwgJ0VUSU1FJyk7XG4gICAgfSwgdGhpcy5fdGltZW91dCk7XG4gIH1cbiAgLy8gcmVzcG9uc2UgdGltZW91dFxuICBpZiAodGhpcy5fcmVzcG9uc2VUaW1lb3V0ICYmICF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIFJlc3BvbnNlQmFzZS5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IFJlc3BvbnNlQmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIHRoaXMuaGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIHJlbGF0ZWQgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYC50eXBlYCB0aGUgY29udGVudCB0eXBlIHdpdGhvdXQgcGFyYW1zXG4gKlxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gKiB3aWxsIHByb3ZpZGUgeW91IHdpdGggYSBgLnR5cGVgIG9mIFwidGV4dC9wbGFpblwiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xuICAgIC8vIFRPRE86IG1vYXIhXG4gICAgLy8gVE9ETzogbWFrZSB0aGlzIGEgdXRpbFxuXG4gICAgLy8gY29udGVudC10eXBlXG4gICAgY29uc3QgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgY29uc3QgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHRoaXNba2V5XSA9IHBhcmFtc1trZXldO1xuXG4gICAgdGhpcy5saW5rcyA9IHt9O1xuXG4gICAgLy8gbGlua3NcbiAgICB0cnkge1xuICAgICAgICBpZiAoaGVhZGVyLmxpbmspIHtcbiAgICAgICAgICAgIHRoaXMubGlua3MgPSB1dGlscy5wYXJzZUxpbmtzKGhlYWRlci5saW5rKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59O1xuXG4vKipcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxuICpcbiAqIEZvciBleGFtcGxlIGEgMnh4IHJlc3BvbnNlIHdpbGwgZ2l2ZSB5b3UgYSBgLm9rYCBvZiBfX3RydWVfX1xuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxuICogYC5jbGllbnRFcnJvcmAgYW5kIGAuc2VydmVyRXJyb3JgIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBiZSBtb3JlXG4gKiBzcGVjaWZpYywgYW5kIGAuc3RhdHVzVHlwZWAgaXMgdGhlIGNsYXNzIG9mIGVycm9yIHJhbmdpbmcgZnJvbSAxLi41XG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cbiAqXG4gKiBcInN1Z2FyXCIgcHJvcGVydGllcyBhcmUgYWxzbyBkZWZpbmVkIGZvciBjb21tb24gY2FzZXMuIEN1cnJlbnRseSBwcm92aWRpbmc6XG4gKlxuICogICAtIC5ub0NvbnRlbnRcbiAqICAgLSAuYmFkUmVxdWVzdFxuICogICAtIC51bmF1dGhvcml6ZWRcbiAqICAgLSAubm90QWNjZXB0YWJsZVxuICogICAtIC5ub3RGb3VuZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlc3BvbnNlQmFzZS5wcm90b3R5cGUuX3NldFN0YXR1c1Byb3BlcnRpZXMgPSBmdW5jdGlvbihzdGF0dXMpe1xuICAgIGNvbnN0IHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuY3JlYXRlZCA9IDIwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzO1xuICAgIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gICAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IDQyMiA9PSBzdGF0dXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50eXBlID0gc3RyID0+IHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKChvYmosIHN0cikgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgvICo9ICovKTtcbiAgY29uc3Qga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgY29uc3QgdmFsID0gcGFydHMuc2hpZnQoKTtcblxuICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9IHN0ciA9PiBzdHIuc3BsaXQoLyAqLCAqLykucmVkdWNlKChvYmosIHN0cikgPT4ge1xuICBjb25zdCBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgY29uc3QgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICBjb25zdCByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gIG9ialtyZWxdID0gdXJsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIFN0cmlwIGNvbnRlbnQgcmVsYXRlZCBmaWVsZHMgZnJvbSBgaGVhZGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5jbGVhbkhlYWRlciA9IChoZWFkZXIsIGNoYW5nZXNPcmlnaW4pID0+IHtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2hvc3QnXTtcbiAgLy8gc2VjdWlydHlcbiAgaWYgKGNoYW5nZXNPcmlnaW4pIHtcbiAgICBkZWxldGUgaGVhZGVyWydhdXRob3JpemF0aW9uJ107XG4gICAgZGVsZXRlIGhlYWRlclsnY29va2llJ107XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG4iLCJcclxuLyoqXHJcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXHJcbiAqL1xyXG5cclxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xyXG59XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvKiBnbG9iYWwgSCwgZmV0Y2ggKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IG0gPSByZXF1aXJlKFwibWFwXCIpO1xyXG5cclxubGV0IG1hcCA9IG51bGw7XHJcblxyXG5sZXQgY2x1c3RlckxheWVyID0gbnVsbDtcclxuXHJcblxyXG4vKipcclxuICogY3JlYXRlcyBhIGNsdXN0ZXIgb2YgcG9pbnRzXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06Y2x1c3RlclxyXG4gKiBAcGFyYW0gY29vcmRzIHtBcnJheX0gIGFycmF5IG9mIFxcW2xhdCxsbmcscGF5bG9hZFxcXVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIGNsdXN0ZXJcclxuICogQHBhcmFtIFtvcHQubWluWm9vbV0ge251bWJlcn0gbWluIHpvb20gZm9yIGNsdXN0ZXIgdG8gYmUgdmlzaWJsZVxyXG4gKiBAcGFyYW0gW29wdC5tYXhab29tXSB7bnVtYmVyfSBtYXggem9vbSBmb3IgY2x1c3RlciB0byBiZSB2aXNpYmxlXHJcbiAqIEBwYXJhbSBbb3B0Lm5vaXNlXSB7YXJyYXl9IGdyYXBoaWMgdG8gcmVwcmVzZW50IHN0YW5kLWFsb25lIHBvaW50LiBmb3JtYXQ6IFt1cmwsc2l6ZV1cclxuICogQHBhcmFtIFtvcHQuY2x1c3Rlckljb25dIHtzdHJpbmd9IHVybCBvZiBzdmcgZmlsZSByZXByZXNlbnRpbmcgYSBjbHVzdGVyXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlXSB7b2JqZWN0fSBkZWZpbmUgZm9yIGVhY2ggbWluaXVtIGFnZ3JlZ2F0aW9uIGxldmVsIHRoZSBjb2xvciBhbmQgc2l6ZSBvZiB0aGUgaWNvbi4gU2VlIGV4YW1wbGVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGlmIGNsaWNrIG9uIGl0ZW0uIEZvcm1hdCBjYihldmVudCwgY29vcmQsIHBheWxvYWQsIHdlaWd0aCkuIFxyXG4gKiBgY29vcmRgIGlzIGNvb3JkIG9mIGljb25cclxuICogYHBheWxvYWRgIGlzIHBheWxvYWQgYXNzb2NpYXRlZCB0byBwb2ludC4gXHJcbiAqIGB3ZWlnaHRgIGlzIG51bWJlciBvZiBwb2ludHMgYWdncmVnYXRlZCwgd2hlbiBjbGlja2luZyBvbiBhIGNsdXN0ZXIgaWNvbiwgMSBpZiBzaW5nbGUgcG9pbnRcclxuICogXHJcbiAqIEByZXR1cm4ge0gubWFwLmxheWVyLk9iamVjdExheWVyfSAgbGF5ZXIgY3JlYXRlZFxyXG4gKiBcclxuICAqIEBleGFtcGxlXHJcbiAgKiBgYGBqc1xyXG4gICogbGV0IHBvaXMgPSBbWzQ4LjgsMi4zLFwiSGVsbG8gd29ybGRcIl0sWzQ4LjUsMi40LFwiSG93IGFyZSB5b3VcIl0sWzQ1LjIsMi45MyxcIlZlcnkgd2VsbFwiXV07XHJcbiAgKiBcclxuICAqIGhtLmNsdXN0ZXIocG9pcyk7XHJcbiAgKiBcclxuICAqIC8vIHdpdGggbW9yZSBncmFwaGljIG9wdGlvbnMgYW5kIGNhbGxiYWNrIGRlZmluZWRcclxuICogIGhtLmNsdXN0ZXIocG9pcywge1xyXG4gKiAgICAgICAgICAgbm9pc2U6IFtcIm1jZG8ucG5nXCIsIDI0XSxcclxuICogICAgICAgICAgIGNsdXN0ZXJJY29uOiAnLi4vc3ZnL2NsdXN0ZXIyLnN2ZycsICAgIC8vICBpY29uIGZvciBjbHVzdGVyXHJcbiAqICAgICAgICAgICBzdHlsZToge1xyXG4gKiAgICAgICAgICAgICAgIDIwMDogeyBjb2xvcjogXCIjQjUwMDE1XCIsIHNpemU6IDY0IH0gIC8vIGZvciAyMDAgb3IgbW9yZSBwb2ludHMgYWdncnJlZ2F0ZWQsIGRyYWcgcmVkIGJpZyBpY29uXHJcbiAqICAgICAgICAgICAgICAgNzU6IHsgY29sb3I6IFwiI0ZGNjkwMFwiLCBzaXplOiA1OCB9LCAgLy8gZm9yIDc1IG9yIG1vcmUgcG9pbnRzIGFnZ3JlZ2F0ZWQuIG9yYW5nZSBtaWRkbGUgc2l6ZSBpY29uXHJcbiAqICAgICAgICAgICAgICAgMjogeyBjb2xvcjogXCIjN0JEMzBBXCIsIHNpemU6IDQ2IH0sICAgLy8gZm9yIDIgb3IgbW9yZSBwb2ludHMgYWdncmVnYXRlZC4gZ3JlZW4gc21hbGwgaWNvblxyXG4gKiAgICAgICAgICAgfVxyXG4gKiAgICAgICB9LFxyXG4gKiAgICAgICAgICAgKGV2ZW50LCBjb29yZGluYXRlLCBkYXRhLCB3ZWlnaHQpID0+IHtcclxuICogICAgICAgICAgICAgICBpZiAoZGF0YSlcclxuICogICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGljayBvbiBwb2ludCBcIiwgZGF0YSk7XHJcbiAqICAgICAgICAgICAgICAgZWxzZVxyXG4gKiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNsaWNrIG9uIGNsdXN0ZXIgd2l0aCB3ZWlnaHRcIiwgd2VpZ2h0KTtcclxuICogICAgICAgICAgIH0pO1xyXG4qIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY2x1c3Rlcihjb29yZHMsIG9wdCwgY2IgPSBudWxsKSB7XHJcblxyXG4gICAgbGV0IGRhdGFQb2ludHMgPSBbXTtcclxuICAgIG1hcCA9IG0uZ2V0TWFwKCk7XHJcblxyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIG1pblpvb206IDEsICAgICAvLyBtaW4gem9vbVxyXG4gICAgICAgIG1heFpvb206IDI0LCAgICAvLyBtYXggem9vbVxyXG4gICAgICAgIG5vaXNlOiBbXCJodHRwOnN2Zy9ibHVlZG90LnN2Z1wiLCAxNl0sICAvLyAgaWNvbitzaXplIGZvciBub2lzZSwgY2FuIGJlIHN2ZyBvciBpbWFnZVxyXG4gICAgICAgIGNsdXN0ZXJJY29uOiBcImh0dHA6c3ZnL2NsdXN0ZXIuc3ZnXCIsICAgIC8vICBpY29uIGZvciBjbHVzdGVyXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgNzU6IHsgY29sb3I6IFwiI0ZGNjkwMFwiLCBzaXplOiAzNiB9LFxyXG4gICAgICAgICAgICAzOiB7IGNvbG9yOiBcIiM3QkQzMEFcIiwgc2l6ZTogMzIgfSxcclxuICAgICAgICAgICAgMjAwOiB7IGNvbG9yOiBcIiNCNTAwMTVcIiwgc2l6ZTogNDggfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAob3B0KVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG5cclxuICAgIGNvb3Jkcy5mb3JFYWNoKGNvb3JkID0+IHtcclxuICAgICAgICAvLyB1c2Ugb3Bfd2VpZ2h0IG9mIDEgZm9yIGVhY2ggY29vcmRcclxuICAgICAgICAvLyBwcm92aWRlcyBhbGwgY29vcmQgYXMgZGF0YVxyXG4gICAgICAgIGxldCBkcCA9IG5ldyBILmNsdXN0ZXJpbmcuRGF0YVBvaW50KGNvb3JkWzBdLCBjb29yZFsxXSwgMSwgY29vcmQpO1xyXG4gICAgICAgIGRhdGFQb2ludHMucHVzaChkcCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIG5vaXNlIGljb24gOiBpZiBTVkcsIG5lZWRzIHRvIGZldGNoIGl0XHJcbiAgICBsZXQgbm9pc2VJY29uID0gc2V0dGluZ3Mubm9pc2VbMF07XHJcbiAgICBsZXQgbm9pc2VTaXplID0gc2V0dGluZ3Mubm9pc2VbMV07XHJcblxyXG4gICAgaWYgKG5vaXNlSWNvbi5zdWJzdHIoLTMpID09IFwic3ZnXCIpIHtcclxuICAgICAgICBub2lzZUljb24gPSBhd2FpdCBmZXRjaChub2lzZUljb24pXHJcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPSAyMDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGlmICghbm9pc2VJY29uKSByZXR1cm47IC8vIGlmIG5vIHJlc3VsdCwgbGV0J3MgcXVpdFxyXG5cclxuICAgIC8vIHRvIHNwZWVkIHVwLCBjcmVhdGUgb25seSBvbmNlIHRoZSBpY29uIGZvciBub2lzZVxyXG4gICAgY29uc3QgaWNvbk5vaXNlID0gbmV3IEgubWFwLkljb24obm9pc2VJY29uLCB7IHNpemU6IHsgdzogbm9pc2VTaXplLCBoOiBub2lzZVNpemUgfSB9KTtcclxuXHJcbiAgICAvLyBsZXQncyBub3cgZmV0Y2ggY2x1c3RlciBpY29uXHJcbiAgICBsZXQgc3ZnQ2x1c3RlciA9IGF3YWl0IGZldGNoKHNldHRpbmdzLmNsdXN0ZXJJY29uKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzICE9IDIwMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBpZiAoIXN2Z0NsdXN0ZXIpXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuXHJcbiAgICAvLyB0byBzcGVlZCBkaXNwbGF5IGRpc3BsYXksIHdlIHdpbGwgY2FjaGUgdGhlIHZhcmlvdXMgY2x1c3RlciBpY29uc1xyXG4gICAgLy8gZnJvbSB0aGUgYmFzZSBzdmcsIHdlIHdpbGwgY3JlYXRlIGRpZmZlcmVudCBpY29ucyB3aXRoIGRpZmZlcmVudCBzaXplL2NvbG9yL3RleHRcclxuICAgIGxldCBjYWNoZUljb24gPSB7fTsgLy8gY2FjaGUgb2YgaWNvbnNcclxuXHJcbiAgICAvLyBvcmRlciBzdHlsZSBieSBzaXplIGRlc2NlbmRpbmdcclxuICAgIGxldCBzdHlsZVNpemUgPSBPYmplY3Qua2V5cyhzZXR0aW5ncy5zdHlsZSkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH0pO1xyXG5cclxuICAgIC8vIHRoaXMgZnVuY3Rpb24gIGNyZXRhZXMgdGhlIGljb24gZm9yIGEgY2x1c3RlclxyXG4gICAgZnVuY3Rpb24gZ2V0Q2x1c3RlclByZXNlbnRhdGlvbihjbHVzdGVyKSB7XHJcblxyXG4gICAgICAgIC8vIGJ1aWxkaW5nIGRhdGEgb2JqZWN0IHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBjbGlja2luZyBvbiB0aGUgaWNvblxyXG4gICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgZGF0YS5pc0NsdXN0ZXIgPSAoKSA9PiB7IHJldHVybiB0cnVlOyB9OyAgLy8gc28gd2Uga25vdyBpdCBpcyBhIGNsdXN0ZXJcclxuICAgICAgICBsZXQgd2VpZ2h0ID0gY2x1c3Rlci5nZXRXZWlnaHQoKTtcclxuICAgICAgICBkYXRhLmdldFdlaWdodCA9ICgpID0+IHsgcmV0dXJuIHdlaWdodDsgfTsgLy8gbnVtYmVyIG9mIGluZGl2aWR1YWwgaXRlbSBjbHVzdGVyZWQgdG9nZXRoZXJcclxuXHJcbiAgICAgICAgLy8gbGV0J3MgZmluZCB0aGUgcmVsZXZhbnQgY29sb3IgYW5kIHNpemVcclxuICAgICAgICBsZXQgZW50cnkgPSBzdHlsZVNpemUuZmluZChlbHQgPT4gKHdlaWdodCA+PSBlbHQpKTtcclxuICAgICAgICBsZXQgY29sb3IgPSBzZXR0aW5ncy5zdHlsZVtlbnRyeV0uY29sb3I7XHJcbiAgICAgICAgbGV0IHNpemUgPSBzZXR0aW5ncy5zdHlsZVtlbnRyeV0uc2l6ZTtcclxuXHJcbiAgICAgICAgLy8gbGV0J3MgY3JlYXRlIGFuZCBjYWNoZSB0aGUgbmVlZGVkIGljb25zXHJcbiAgICAgICAgbGV0IGtleSA9IGNvbG9yICsgXCItXCIgKyB3ZWlnaHQgKyBcIi1cIiArIHNpemU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYWNoZUljb25ba2V5XSA9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGxldCBzdmcgPSBzdmdDbHVzdGVyLnJlcGxhY2UoXCJ7dGV4dH1cIiwgd2VpZ2h0KS5yZXBsYWNlKC97Y29sb3J9L2csIGNvbG9yKTtcclxuICAgICAgICAgICAgY2FjaGVJY29uW2tleV0gPSBuZXcgSC5tYXAuSWNvbihzdmcsIHsgc2l6ZTogeyB3OiBzaXplLCBoOiBzaXplIH0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBDbHVzdGVyXHJcbiAgICAgICAgdmFyIGNsdXN0ZXJNYXJrZXIgPSBuZXcgSC5tYXAuTWFya2VyKGNsdXN0ZXIuZ2V0UG9zaXRpb24oKSwge1xyXG4gICAgICAgICAgICAvLyBVc2UgbWluIHpvb20gZnJvbSBhIG5vaXNlIHBvaW50XHJcbiAgICAgICAgICAgIC8vIHRvIHNob3cgaXQgY29ycmVjdGx5IGF0IGNlcnRhaW4gem9vbSBsZXZlbHM6XHJcbiAgICAgICAgICAgIG1pbjogY2x1c3Rlci5nZXRNaW5ab29tKCksXHJcbiAgICAgICAgICAgIG1heDogY2x1c3Rlci5nZXRNYXhab29tKCksXHJcbiAgICAgICAgICAgIGljb246IGNhY2hlSWNvbltrZXldLFxyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTGluayBkYXRhIGZyb20gdGhlIGZyb20gdGhlIGNsdXN0ZXIgdG8gdGhlIG1hcmtlcixcclxuICAgICAgICAvLyB0byBtYWtlIGl0IGFjY2Vzc2libGUgb24gY2FsbGJhY2tcclxuICAgICAgICBjbHVzdGVyTWFya2VyLnNldERhdGEoZGF0YSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbHVzdGVyTWFya2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGZ1bmN0aW9uIHRvIHJlcHJlc2VudCBhIHNpbmdsZSBpdGVtXHJcbiAgICBmdW5jdGlvbiBnZXROb2lzZVByZXNlbnRhdGlvbihub2lzZVBvaW50KSB7XHJcblxyXG4gICAgICAgIC8vIGRhdGEgdG8gYmUgc2VudCBvbiBjYWxsYmFja1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgICAgIGdldERhdGE6ICgpID0+IHsgcmV0dXJuIG5vaXNlUG9pbnQuZ2V0RGF0YSgpOyB9LFxyXG4gICAgICAgICAgICBpc0NsdXN0ZXI6ICgpID0+IHsgcmV0dXJuIGZhbHNlOyB9LFxyXG4gICAgICAgICAgICBnZXRXZWlnaHQ6ICgpID0+IHsgcmV0dXJuIDE7IH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBtYXJrZXIgZm9yIHRoZSBub2lzZVBvaW50XHJcbiAgICAgICAgdmFyIG5vaXNlTWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihub2lzZVBvaW50LmdldFBvc2l0aW9uKCksIHtcclxuICAgICAgICAgICAgLy8gVXNlIG1pbiB6b29tIGZyb20gYSBub2lzZSBwb2ludFxyXG4gICAgICAgICAgICAvLyB0byBzaG93IGl0IGNvcnJlY3RseSBhdCBjZXJ0YWluIHpvb20gbGV2ZWxzOlxyXG4gICAgICAgICAgICBtaW46IG5vaXNlUG9pbnQuZ2V0TWluWm9vbSgpLFxyXG4gICAgICAgICAgICBpY29uOiBpY29uTm9pc2VcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIC8vIExpbmsgYSBkYXRhIGZyb20gdGhlIHBvaW50IHRvIHRoZSBtYXJrZXJcclxuICAgICAgICAvLyB0byBtYWtlIGl0IGFjY2Vzc2libGUgb24gY2FsbGJhY2tcclxuICAgICAgICBub2lzZU1hcmtlci5zZXREYXRhKGRhdGEpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9pc2VNYXJrZXI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGNyZWF0ZSBjbHVzdGVyIHByb3ZpZGVyXHJcbiAgICBsZXQgY2x1c3RlcmVkRGF0YVByb3ZpZGVyID0gbmV3IEguY2x1c3RlcmluZy5Qcm92aWRlcihkYXRhUG9pbnRzLCB7XHJcbiAgICAgICAgY2x1c3RlcmluZ09wdGlvbnM6IHtcclxuICAgICAgICAgICAgLy8gTWF4aW11bSByYWRpdXMgb2YgdGhlIG5laWdoYm9yaG9vZFxyXG4gICAgICAgICAgICBlcHM6IDY0LFxyXG4gICAgICAgICAgICAvLyBtaW5pbXVtIHdlaWdodCBvZiBwb2ludHMgcmVxdWlyZWQgdG8gZm9ybSBhIGNsdXN0ZXJcclxuICAgICAgICAgICAgbWluV2VpZ2h0OiBzdHlsZVNpemVbc3R5bGVTaXplLmxlbmd0aCAtIDFdIC8vIG1pbmltdW0gY2x1c3RlcmluZyBpcyBkZWZpbmVkIGJ5IG1pbnNpemUgaW4gU3R5bGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1pbjogc2V0dGluZ3MubWluWm9vbSwgLy8gbWluIHpvb21cclxuICAgICAgICBtYXg6IHNldHRpbmdzLm1heFpvb20sIC8vIG1heCB6b29tXHJcbiAgICAgICAgdGhlbWU6IHsgZ2V0Q2x1c3RlclByZXNlbnRhdGlvbjogZ2V0Q2x1c3RlclByZXNlbnRhdGlvbiwgZ2V0Tm9pc2VQcmVzZW50YXRpb246IGdldE5vaXNlUHJlc2VudGF0aW9uIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIGxheWVyIHRoYXQgaW5jbHVkZXMgdGhlIGRhdGEgcHJvdmlkZXIgYW5kIGl0cyBkYXRhIHBvaW50czpcclxuICAgIGxldCBsYXllciA9IG5ldyBILm1hcC5sYXllci5PYmplY3RMYXllcihjbHVzdGVyZWREYXRhUHJvdmlkZXIpO1xyXG4gICAgLy8gQWRkIHRoZSBsYXllciB0byB0aGUgbWFwOlxyXG4gICAgbWFwLmFkZExheWVyKGxheWVyKTtcclxuXHJcbiAgICAvLyBpZiBhIGNhbGxiYWNrIGlzIGRlZmluZWQsIGFkZCBldmVudCBsaXN0ZW5lclxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgY2x1c3RlcmVkRGF0YVByb3ZpZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIC8vIExvZyBkYXRhIGJvdW5kIHRvIHRoZSBtYXJrZXIgdGhhdCBoYXMgYmVlbiB0YXBwZWQ6XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZXYudGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgbGV0IGlzQ2x1c3RlciA9IGRhdGEuaXNDbHVzdGVyKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNDbHVzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgd2VpZ3RoID0gZGF0YS5nZXRXZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIGNiKGV2LCBtLmNvb3JkTzJBKGNvb3JkKSwgbnVsbCwgd2VpZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdXNlckRhdGEgPSBkYXRhLmdldERhdGEoKTsgLy8gbGF0LGxuZywgcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgY2IoZXYsIG0uY29vcmRPMkEoY29vcmQpLCB1c2VyRGF0YVsyXSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhpZGUoKSB7XHJcbiAgICBjbHVzdGVyTGF5ZXIuc2V0TWF4KDApO1xyXG4gICAgY2x1c3RlckxheWVyLnNldE1pbigwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvdygpIHtcclxuICAgIGNsdXN0ZXJMYXllci5zZXRNYXgoMjQpO1xyXG4gICAgY2x1c3RlckxheWVyLnNldE1pbigwKTtcclxuXHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGNsdXN0ZXI6IGNsdXN0ZXIsXHJcbiAgICBjbHVzdGVyU2hvdzogc2hvdyxcclxuICAgIGNsdXN0ZXJIaWRlOiBoaWRlXHJcbn07XHJcblxyXG4iLCIvKiBnbG9iYWwgZG9jdW1lbnQgKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZShcInN1cGVyYWdlbnRcIik7XHJcblxyXG4vLyBieSBkZWZhdWx0LCB1bmxlc3Mgc3BlY2lmaWVkIGZieSBjYWxsaW5nIGNvbmZpZ1xyXG4vLyBlbnZpcm9ubWVudCB1c2FibGUgd2l0aCBub2RlXHJcbmxldCBBUFBfSUQgPSBwcm9jZXNzLmVudi5BUFBfSUQ7XHJcbmxldCBBUFBfQ09ERSA9IHByb2Nlc3MuZW52LkFQUF9DT0RFO1xyXG5sZXQgQ0lUID0gXCJcIjsgLy8gcHJvZHVjdGlvbiBieSBkZWZhdWx0XHJcbmxldCBQUk9UT0NPTCA9IFwiaHR0cHM6XCI7IC8vIGJ5IGRlZmF1bHRcclxubGV0IF91c2VIVFRQUyA9IHRydWU7IC8vIGJ5IGRlZmF1bHRcclxubGV0IF9ob21lID0gXCIuXCI7XHJcblxyXG5cclxuLy8gZmluZCBvdXQgd2hlcmUgd2UgYXJlIGFuZCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgcG5nL3N2ZyBmaWxlc1xyXG4vLyBwYXkgYXR0ZW50aW9uIGlmIGxpYnJhcnkgaXMgYnVpbGQgaW4gLi9kaXN0XHJcbmlmIChwcm9jZXNzLmJyb3dzZXIpIHtcclxuICAgIGxldCBfc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XHJcbiAgICBsZXQgX2ZpbGUgPSBfc2NyaXB0W19zY3JpcHQubGVuZ3RoIC0gMV0uc3JjO1xyXG4gICAgbGV0IF9wYXRoID0gX2ZpbGUuc3Vic3RyaW5nKDAsIF9maWxlLmxhc3RJbmRleE9mKFwiL1wiKSk7XHJcblxyXG4gICAgX2hvbWUgPSBfcGF0aCArIFwiLy4uL1wiOyAvLyBhIGJpdCBkaXJ0eSBidXQgLi4uXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUbyBjb25maWd1cmUgYXBwX2lkLCBhcHBfY29kZSBhbmQgb3B0aW9uYWxseSB1c2UgQ0lUIGFuZCBodHRwXHJcbiAqIEBhbGlhcyBobTpjb25maWdcclxuICpcclxuICogQHBhcmFtIG9wdCB7T2JqZWN0fSAgLSBgb3B0YCB3aXRoIHBhcmFtZXRlcnMuXHJcbiAqIEBwYXJhbSBbb3B0LmFwcF9pZF0ge3N0cmluZ30gLSB0aGUgYXBwX2lkIGZyb20gZGV2ZWxvcGVyLmhlcmUuY29tXHJcbiAqIEBwYXJhbSBbb3B0LmFwcF9jb2RlXSB7c3RyaW5nfSAtIHRoZSBhcHBfY29kZSBmcm9tIGRldmVsb3Blci5oZXJlLmNvbVxyXG4gKiBAcGFyYW0gW29wdC51c2VDSVQ9ZmFsc2VdIHtib29sZWFufSAtIHRydWUgdG8gdXNlIENJVCBlbnZpcm9ubWVudC4gXHJcbiAqIEBwYXJhbSBbb3B0LnVzZUhUVFA9ZmFsc2VdIHtzdHJpbmd9IC0gdHJ1ZSB0byB1c2UgSFRUUC4gXHJcbiAqIEBwYXJhbSBbb3B0LnVzZUhUVFBTPXRydWVdIHtzdHJpbmd9IC0gdHJ1ZSB0byB1c2UgSFRUUFMuIFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiAgaG0uY29uZmlnKHtcclxuICogICAgICBhcHBfaWQ6IFwiWU9VUiBBUFBfSURcIixcclxuICogICAgICBhcHBfY29kZTogXCJZT1VSIEFQUF9DT0RFXCIsXHJcbiogICB9KTtcclxuKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25maWcob3B0KSB7XHJcbiAgICBpZiAob3B0LmFwcF9pZCkgQVBQX0lEID0gb3B0LmFwcF9pZDtcclxuICAgIGlmIChvcHQuYXBwX2NvZGUpIEFQUF9DT0RFID0gb3B0LmFwcF9jb2RlO1xyXG4gICAgaWYgKG9wdC51c2VDSVQpIENJVCA9IFwiLmNpdFwiO1xyXG4gICAgaWYgKG9wdC51c2VIVFRQKSB7XHJcbiAgICAgICAgUFJPVE9DT0wgPSBcImh0dHA6XCI7XHJcbiAgICAgICAgX3VzZUhUVFBTID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0LnVzZUhUVFBTKSB7XHJcbiAgICAgICAgUFJPVE9DT0wgPSBcImh0dHBzOlwiO1xyXG4gICAgICAgIF91c2VIVFRQUyA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gVVJMIG9mIG1vZHVsZSBob21lIGRpcmVjdG9yeVxyXG4gKiBAaWdub3JlXHJcbiAqICBAYWxpYXMgaG06Z2V0SG9tZVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVybCBvZiBob21lIGRpcmVjdG9yeSBpbmNsdWRpbmcgaHR0cCBvciBodHRwc1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SG9tZSgpIHtcclxuICAgIHJldHVybiBfaG9tZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybnMgYXBwX2lkXHJcbiAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTpnZXRBcHBJZFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGFwcF9pZFxyXG4qL1xyXG5mdW5jdGlvbiBnZXRBcHBJZCgpIHtcclxuICAgIHJldHVybiBBUFBfSUQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gYXBwX2NvZGVcclxuICogIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTpnZXRIb21lXHJcbiAqICBAYWxpYXMgaG06Z2V0QXBwQ29kZVxyXG4gICogQHJldHVybiB7c3RyaW5nfSBhcHBfY29kZVxyXG4qL1xyXG5mdW5jdGlvbiBnZXRBcHBDb2RlKCkge1xyXG4gICAgcmV0dXJuIEFQUF9DT0RFO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIHRydWUgaWYgdXNpbmcgQ0lUXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmdldENJVFxyXG4gKiBAcmV0dXJuIHtib29vbGVhbn0gdHJ1ZSBpZiB1c2luZyBDSVRcclxuKi9cclxuZnVuY3Rpb24gZ2V0Q0lUKCkge1xyXG4gICAgcmV0dXJuIENJVDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiBwcm90b2NvbCB1c2VkLCBodHRwOi8vIG9yIGh0dHBzOi8vXHJcbiAqIEBpZ25vcmVcclxuICogQGFsaWFzIGhtOmdldFByb3RvY29sXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBwcm90b2NvbFxyXG4qL1xyXG5mdW5jdGlvbiBnZXRQcm90b2NvbCgpIHtcclxuICAgIHJldHVybiBQUk9UT0NPTDtcclxufVxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB0cnVlIGlzIGh0dHBzIGlzIHVzZWRcclxuICogQGlnbm9yZVxyXG4gKiAgQGFsaWFzIGhtOnVzZUhUVFBTXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiBodHRwcyBpcyB1c2VkXHJcbiovXHJcbmZ1bmN0aW9uIHVzZUhUVFBTKCkge1xyXG4gICAgcmV0dXJuIF91c2VIVFRQUztcclxufVxyXG5cclxuLyoqXHJcbiAqIGFkZCBjcmVkZW50aWFscyB0byBvYmplY3QgcHJvdmlkZWRcclxuICAqIEBpZ25vcmVcclxuICogIEBhbGlhcyBobTphZGRDcmVkZW50aWFsc1xyXG4gKiBAcGFyYW0gIHsuLi5vYmplY3RzfSBsaXN0IG9mIGBvYmplY3RzYCBcclxuICogQHJldHVybiB7b2JqZWN0fSBvYmplY3Qgd2l0aCBhbGwgaW5wdXQgb2JqZWN0Y29uY2F0ZW5hdGVkLCBhbmQgYXBwX2lkL2FwcF9jb2RlIGluc2VydGVkXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDcmVkZW50aWFscyguLi5vYmopIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICBhcHBfaWQ6IEFQUF9JRCxcclxuICAgICAgICBhcHBfY29kZTogQVBQX0NPREVcclxuICAgIH0sIC4uLm9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBidWlsZCBIRVJFIFJFU1QgZnVsbCB1cmwsIHRha2luZyBpbiBhY2NvdW50IHByb3RvY29sIGFuZCBjaXQuIGZvciBpbnN0YW5jZSAgY20uYnVpbGRVcmwoXCJnZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvZ2VvY29kZS5qc29uXCJcclxuICogQGlnbm9yZVxyXG4gKiBAYWxpYXMgaG06YnVpbGRVcmxcclxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgLSBiYXNlIG5hbWVcclxuICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50IC0gZW5kIHBvaW50XHJcbiAqIEByZXR1cm4ge3N0cmluZ30gZnVsbCB1cmxcclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkVXJsKGJhc2UsIGVuZHBvaW50KSB7XHJcbiAgICByZXR1cm4gUFJPVE9DT0wgKyBcIi8vXCIgKyBiYXNlICsgQ0lUICsgXCIuXCIgKyBlbmRwb2ludDtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRvZXMgZ2V0L3Bvc3QgcmVxdWVzdCB0byBIRVJFIFJFU0RUIGJhY2tlbmQgYW5kIG1hbmFnZSBtYWluIGVycm9yc1xyXG4gKiBAaWdub3JlXHJcbiAqIEBhbGlhcyBobTpoZXJlUmVzdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsICAtIHVybCB0byBjYWxsICwgZm9yIGluc3RhbmNlIGZyb20gYnVpbGRVcmxcclxuICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIC0gc2V0dGluZ3MgdG8gYWRkIGluIHJlcXVlc3RcclxuICogQHBhcmFtICB7c3RyaW5nfSBtb2RlPWdldCAtIG1vZGUgXCJnZXRcIiBvciBcInBvc3RcIlxyXG4gKiBAcmV0dXJuIHtwcm9taXNlfSAtIHByb21pc2UgdG8gcmVzb2x2ZS9yZWplY3RcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGhlcmVSZXN0KHVybCwgc2V0dGluZ3MsIG1vZGUgPSBcImdldFwiKSB7XHJcblxyXG4gICAgbGV0IHAgPSByZXF1ZXN0LmdldCh1cmwpO1xyXG4gICAgaWYgKG1vZGUgPT0gXCJwb3N0XCIpXHJcbiAgICAgICAgcCA9IHJlcXVlc3QucG9zdCh1cmwpO1xyXG5cclxuICAgIHJldHVybiBwXHJcbiAgICAgICAgLnF1ZXJ5KHNldHRpbmdzKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIC8vIHJlcy5ib2R5LCByZXMuaGVhZGVycywgcmVzLnN0YXR1c1xyXG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPSBcIjIwMFwiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkVycm9yIFwiICsgcmVzLnN0YXR1cyArIFwiOlwiICsgcmVzLmJvZHkpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHRocm93IChlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmICghcmVzLmJvZHkuUmVzcG9uc2UgJiYgIXJlcy5ib2R5LnJlc3BvbnNlKSB7IC8vIG9uZSBvZiB0aGUgdHdvIHNob3VsZCBiZSBpbiB0aGUgYW5zd2VyXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlcy5ib2R5KTtcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUXVlcnkgZXJyb3I6XCIgKyByZXMuYm9keSk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLmJvZHkucmVzcG9uc2UgJiYgcmVzLmJvZHkucmVzcG9uc2UudHlwZSA9PSBcIkFwcGxpY2F0aW9uRXJyb3JcIikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuYm9keSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkVycm9yXCIgKyByZXMuYm9keS5yZXNwb25zZS5kZXRhaWxzKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29uZmlnOiBjb25maWcsXHJcbiAgICBidWlsZFVybDogYnVpbGRVcmwsXHJcbiAgICBnZXRBcHBJZDogZ2V0QXBwSWQsXHJcbiAgICBnZXRBcHBDb2RlOiBnZXRBcHBDb2RlLFxyXG4gICAgZ2V0Q0lUOiBnZXRDSVQsXHJcbiAgICBnZXRQcm90b2NvbDogZ2V0UHJvdG9jb2wsXHJcbiAgICBnZXRIb21lOiBnZXRIb21lLFxyXG4gICAgdXNlSFRUUFM6IHVzZUhUVFBTLFxyXG4gICAgYWRkQ3JlZGVudGlhbHM6IGFkZENyZWRlbnRpYWxzLFxyXG4gICAgaGVyZVJlc3Q6IGhlcmVSZXN0XHJcbn07IiwiLyoqXHJcbiAqIEBmaWxlIEdlb2NvZGluZyBmdW5jdGlvbnMgOiBhZGRyZXNzZXMgPC0tPiBbbGF0LGxuZ11cclxuICogQGF1dGhvciBEZXZiYWIgXHJcbiAqL1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmNvbnN0IGNtID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xyXG5cclxuLyoqXHJcbiAqIGdlb2NvZGUgYW4gYWRkcmVzc1xyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmdlb2NvZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBhZGRyZXNzIGFzIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSByZXR1cm5zICB7Y29vcmQsYm9keX0uIGNvb3JkIGlzIGdlb2NvZGUgYXMgXFxbbGF0LGxuZ1xcXS4gYm9keSBpcyBmdWxsIGpzb24gYW5zd2VyXHJcbiAqIFxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBjb25zdCByZXMgPSBhd2FpdCBobS5nZW9jb2RlKFwiYXZlbnVlIGRlcyBjaGFwcyBlbHlzZWVzLCBwYXJpc1wiKTtcclxuICogY29uc29sZS5sb2cgKHJlcy5jb29yZCk7XHJcbiAqIGBgYFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZ2VvY29kZShhZGRyZXNzKSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgc2VhcmNoVGV4dDogYWRkcmVzc1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJnZW9jb2RlclwiLCBcImFwaS5oZXJlLmNvbS82LjIvZ2VvY29kZS5qc29uXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgc2V0dGluZ3MpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXMuYm9keS5SZXNwb25zZS5WaWV3Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIkdlb2NvZGUgQWRkcmVzcyBub3QgZm91bmQ6IFwiICsgYWRkcmVzcyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuYm9keS5SZXNwb25zZS5WaWV3WzBdLlJlc3VsdFswXS5Mb2NhdGlvbjtcclxuICAgICAgICAgICAgdmFyIGNvb3JkID0gW2xvY2F0aW9uLk5hdmlnYXRpb25Qb3NpdGlvblswXS5MYXRpdHVkZSwgbG9jYXRpb24uTmF2aWdhdGlvblBvc2l0aW9uWzBdLkxvbmdpdHVkZV07XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNvb3JkOiBjb29yZCwgYm9keTogcmVzLmJvZHkgfTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiByZXZlcnNlIGdlb2NvZGUgYSBjb29yZGluYXRlXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06cmV2ZXJzZUdlb2NvZGVcclxuICogQHBhcmFtIHtDb29yZH0gY29vcmQgLSBjb29yZCBcXFtsYXQsbG5nXFxdIHRvIHJldmVyc2UgZ2VvY29kZVxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSByZXR1cm5zIHsgbG9jYXRpb246b2JqZWN0LCBhZGRyZXNzOm9iamVjdCwgYm9keTpvYmplY3R9LiBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJldmVyc2VHZW9jb2RlKGNvb3JkKSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBjbS5hZGRDcmVkZW50aWFscyh7XHJcbiAgICAgICAgbW9kZTogXCJyZXRyaWV2ZUFkZHJlc3Nlc1wiLFxyXG4gICAgICAgIHByb3g6IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXJsID0gY20uYnVpbGRVcmwoXCJyZXZlcnNlLmdlb2NvZGVyXCIsIFwiYXBpLmhlcmUuY29tLzYuMi9yZXZlcnNlZ2VvY29kZS5qc29uXCIpO1xyXG5cclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHNldHRpbmdzKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIC8vIHJlcy5ib2R5LCByZXMuaGVhZGVycywgcmVzLnN0YXR1c1xyXG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSByZXMuYm9keS5SZXNwb25zZS5WaWV3WzBdLlJlc3VsdFswXS5Mb2NhdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuICh7IGxvY2F0aW9uOiBsb2NhdGlvbiwgYWRkcmVzczogbG9jYXRpb24uQWRkcmVzcywgYm9keTogcmVzLmJvZHkgfSk7XHJcbiAgICAgICAgfSk7XHJcbn1cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGdlb2NvZGU6IGdlb2NvZGUsXHJcbiAgICByZXZlcnNlR2VvY29kZTogcmV2ZXJzZUdlb2NvZGVcclxufTtcclxuXHJcbiIsIi8qIGdsb2JhbCBILCBmZXRjaCwgZG9jdW1lbnQsIG5hdmlnYXRvciwgbWFwc2pzLCB3aW5kb3cgQVBQX0lEX0pBUEFOLEFQUF9DT0RFX0pBUEFOLEFQUF9JRF9LT1JFQSxBUFBfQ09ERV9LT1JFQSovXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuY29uc3QgY20gPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XHJcblxyXG5sZXQgX3BsYXRmb3JtID0gbnVsbDtcclxubGV0IF9wcm92aWRlciA9IG51bGw7XHJcbmxldCBfZGVmYXVsdExheWVycyA9IG51bGw7XHJcbmxldCBfdWkgPSBudWxsO1xyXG5sZXQgX21hcCA9IG51bGw7XHJcbmxldCBncm91cCA9IG51bGw7XHJcbmxldCBfbGF5ZXJzID0gW107IC8vIGxpc3QgYWxsIGxheWVyc1xyXG5sZXQgX2tleSA9IHt9OyAgICAgLy8ga2V5cyAgXHJcbmxldCBfYnViYmxlTWFya2VyID0gbnVsbDsgICAgIC8vIGJ1YmJsZSBkZSBtYW1ya2VyXHJcbmxldCBfc2NoZW1lID0gXCJub3JtYWwuZGF5LmdyZXlcIjtcclxubGV0IF9sb2NhdGVNZSA9IG51bGw7ICAgICAgICAgLy8gaWQgd2hlbiBsb2NhdGUgaXMgYWN0aXZlXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGNvb3JkTzJBKG9iaikge1xyXG4gICAgcmV0dXJuIFtvYmoubGF0LCBvYmoubG5nXTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29vcmRBMk8oYXJyKSB7XHJcbiAgICByZXR1cm4geyBsYXQ6IGFyclswXSwgbG5nOiBhcnJbMV0gfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjcmVhdGUgYSBtYXAgYXJlYSB3aXRoaW4gdGhlIHNwZWNpZmllZCBpdGVtXHJcbiAgKiBAYWxpYXMgaG06bWFwXHJcblxyXG4gKiBAcGFyYW0gaHRtbEl0ZW0ge3N0cmluZ30gIC0gaWRlbnRpZmllciBvZiBodG1sIGRpdiBpdGVtIG9uIHdoaWNoIHRvIGluc2VydCBtYXBcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSAgLSBvcHRpb25zXHJcbiAqIEBwYXJhbSBbb3B0Lnpvb209MTBdIHtudW1iZXJ9ICAtIHpvb20gZmFjdG9yXHJcbiAqIEBwYXJhbSBbb3B0LmNlbnRlcj1bNDguODYsIDIuM11dIHtDb29yZH0gIC0gQ29vcmQgb2YgdGhlIGNlbnRlclxyXG4gKiBAcGFyYW0gW29wdC5zY2hlbWU9bm9ybWFsLmRheS5ncmV5XSB7c3RyaW5nfSAgLSBhbnkgc2NoZW1lIGRlZmluZWQgYnkgSEVSRSwgcGx1cyBcImphcGFuXCIsIFwia29yZWFcIiwgXCJibGFja1wiLCBcIndoaXRlXCIsIFwidHJhbnNwYXJlbnRcIi4gRm9yIGphcGFuL2tvcmVhLCBvbmUgbmVlZHMgc3BlY2lhbCBjcmVkZW50aWFscyBhcyBBUFBfW0lEfENPREVdX0pBUEFOIEFQUF9bSUR8Q09ERV1fS09SRUFcclxuICogQHBhcmFtIFtvcHQuY2xpY2s9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrOiBjYWxsYmFjayhjb29yZCxidXR0b24sa2V5KVxyXG4gKiBAcGFyYW0gW29wdC5kYkNsaWNrPW51bGxdIHtmdW5jdGlvbigpfSAgLSBjYWxsYmFjayBvbiBtb3VzZSBkb3VibGUgY2xpY2s6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrTGVmdD1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIGxlZnQ6IGNhbGxiYWNrKGNvb3JkLGJ1dHRvbixrZXkpXHJcbiAqIEBwYXJhbSBbb3B0LmNsaWNrUmlnaHQ9bnVsbF0ge2Z1bmN0aW9uKCl9ICAtIGNhbGxiYWNrIG9uIG1vdXNlIGNsaWNrIHJpZ2h0LjogY2FsbGJhY2soY29vcmQsYnV0dG9uLGtleSlcclxuICogQHBhcmFtIFtvcHQua2V5RG93bj1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIG9uIGtleSBkb3duIDogY2FsbGJhY2soa2V5KVxyXG4gKiBAcGFyYW0gW29wdC52aWV3Q2hhbmdlPW51bGxdIHtmdW5jdGlvbn0gIC0gY2FsbGJhY2sgaWYgbWFwIGlzIHBhbm5lZCBvciB6b29tZWQgOiBjYWxsYmFjayh6b29tLGNvb3JkQ2VudGVyKVxyXG4gKiBAcGFyYW0gW29wdC5sb2FkVGlsZT1udWxsXSB7ZnVuY3Rpb259ICAtIGNhbGxiYWNrIHdoZW4gYSB0aWxlIGlzIGxvYWRlZCA6IGNhbGxiYWNrKHoseCx5LHVybClcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgaG0gPSB3aW5kb3cuaGVyZW1hcDtcclxuICogXHJcbiAqIGhtLmNvbmZpZyh7XHJcbiAqICAgIGFwcF9pZDogXCJZT1VSIEFQUF9JRFwiLFxyXG4gKiAgICBhcHBfY29kZTogXCJZT1VSIEFQUF9DT0RFXCIsXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBobS5tYXAoXCJtYXBcIiwge1xyXG4gKiAgICB6b29tOjUsXHJcbiAqICAgIGNlbnRlcjogWzQ4LjgsMi4zXSxcclxuICogICAgY2xpY2s6IGZ1bmN0aW9uKGNvb3JkLGJ1dHRvbixrZXkpIHtjb25zb2xlLmxvZyhcImNsaWNrZWQgb25cIixjb29yZCxcIndpdGggYnV0dG9uXCIsYnV0dG9uKTt9XHJcbiAqIH0pO1xyXG4qICBgYGBcclxuKi9cclxuZnVuY3Rpb24gbWFwKGh0bWxJdGVtLCBvcHQpIHtcclxuXHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgem9vbTogMTAsXHJcbiAgICAgICAgY2VudGVyOiBbNDguODYsIDIuM10sXHJcbiAgICAgICAgY2xpY2tMZWZ0OiBudWxsLFxyXG4gICAgICAgIGNsaWNrUmlnaHQ6IG51bGwsXHJcbiAgICAgICAga2V5RG93bjogbnVsbCwgIC8vIGtleWJvYXJkIGV2ZW50XHJcbiAgICAgICAgY2xpY2s6IG51bGwsXHJcbiAgICAgICAgZGJDbGljazogbnVsbCxcclxuICAgICAgICB2aWV3Q2hhbmdlOiBudWxsLCAvLyAoem9vbSxjb29yZClcclxuICAgICAgICBsb2FkVGlsZTogbnVsbCAvLyBxdWFuZCB1bmUgdGlsZSBlc3QgYWZmaWNow6llXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBtcHMgPSAxO1xyXG5cclxuICAgIGxldCBhcHBfaWQgPSBjbS5nZXRBcHBJZCgpO1xyXG4gICAgbGV0IGFwcF9jb2RlID0gY20uZ2V0QXBwQ29kZSgpO1xyXG5cclxuICAgIGlmICghYXBwX2lkIHx8ICFhcHBfY29kZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiYXBwX2lkL2FwcF9jb2RlIG5vdCBpbml0aWFsaXNlZFwiKTtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sSXRlbSkuaW5uZXJIVE1MID0gXCJhcHBfaWQvYXBwX2NvZGUgbm90IGluaXRpYWxpc2VkXCI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIF9wbGF0Zm9ybSA9IG5ldyBILnNlcnZpY2UuUGxhdGZvcm0oe1xyXG4gICAgICAgIGFwcF9pZDogYXBwX2lkLFxyXG4gICAgICAgIGFwcF9jb2RlOiBhcHBfY29kZSxcclxuICAgICAgICB1c2VDSVQ6IGNtLmdldENJVCgpLFxyXG4gICAgICAgIHVzZUhUVFBTOiBjbS51c2VIVFRQUygpXHJcbiAgICB9KTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG4gICAgaWYgKHNldHRpbmdzLnNjaGVtZSkgX3NjaGVtZSA9IHNldHRpbmdzLnNjaGVtZTsgLy8gc3RvcmUgc2NoZW1lIGlmIGRlZmluZWRcclxuXHJcbiAgICBfZGVmYXVsdExheWVycyA9IF9wbGF0Zm9ybS5jcmVhdGVEZWZhdWx0TGF5ZXJzKCk7XHJcbiAgICBjb25zb2xlLmxvZyhfZGVmYXVsdExheWVycyk7XHJcblxyXG4gICAgLy8gaHR0cDovL2hlcmVtYXBzLmdpdGh1Yi5pby9leGFtcGxlcy9leHBsb3Jlci5odG1sI21hcC10aWxlc19fYmFzZS1tYXAtc3R5bGVzLWFuZC1tb2Rlc1xyXG4gICAgX3Byb3ZpZGVyID0gbmV3IEgubWFwLnByb3ZpZGVyLkltYWdlVGlsZVByb3ZpZGVyKHtcclxuICAgICAgICBsYWJlbDogXCJCYXNlIFByb3ZpZGVyXCIsXHJcbiAgICAgICAgZGVzY3I6IFwiXCIsXHJcbiAgICAgICAgbWluOiAwLFxyXG4gICAgICAgIG1heDogMjAsXHJcbiAgICAgICAgY3Jvc3NPcmlnaW46IFwiYW5vbnltb3VzXCIsXHJcbiAgICAgICAgZ2V0VVJMOiBmdW5jdGlvbiAoY29sLCByb3csIGxldmVsKSB7XHJcbiAgICAgICAgICAgIG1wcysrOyBpZiAobXBzID4gNCkgbXBzID0gMTtcclxuICAgICAgICAgICAgbGV0IHVybCA9IFtjbS5nZXRQcm90b2NvbCgpLCBcIi8vXCIsIG1wcywgXCIuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlLmNvbS9tYXB0aWxlL1wiLCBcIjIuMVwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwibWFwdGlsZVwiLCBcIi9cIiwgXCJuZXdlc3RcIiwgXCIvXCIsXHJcbiAgICAgICAgICAgICAgICBfc2NoZW1lLCBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgXCIvXCIsIFwicG5nXCIsIFwiP2xnPVwiLCBcIkZSRVwiLFxyXG4gICAgICAgICAgICAgICAgXCImYXBwX2NvZGU9XCIsIGFwcF9jb2RlLCBcIiZhcHBfaWQ9XCIsXHJcbiAgICAgICAgICAgICAgICBhcHBfaWRdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3NjaGVtZSA9PSBcImphcGFuXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIm0ubGJzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5qcC92MS9tYXA/YXBwX2lkPVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIEFQUF9JRF9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfQ09ERV9KQVBBTixcclxuICAgICAgICAgICAgICAgICAgICBcIiZ0aWxlbWF0cml4PUVQU0c6OTAwOTEzOlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVjb2w9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiJnRpbGVyb3c9XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93XS5qb2luKFwiXCIpO1xyXG5cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NjaGVtZSA9PSBcImtvcmVhXCIpXHJcbiAgICAgICAgICAgICAgICB1cmwgPSBbY20uZ2V0UHJvdG9jb2woKSwgXCIvL1wiLCBcIjMuYmFzZS5tYXBzXCIgKyBjbS5nZXRDSVQoKSArIFwiLmFwaS5oZXJlbWFwcy5rci9tYXB0aWxlLzIuMS9tYXB0aWxlLzM0NDM5MzQ4YzMvbm9ybWFsLmRheS9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIi9cIiwgbGV2ZWwsIFwiL1wiLCBjb2wsIFwiL1wiLCByb3csIFwiL1wiLCBcIjI1NlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiL1wiLCBcInBuZ1wiLCBcIj9sZz1cIiwgXCJGUkVcIixcclxuICAgICAgICAgICAgICAgICAgICBcIiZhcHBfY29kZT1cIiwgQVBQX0NPREVfS09SRUEsIFwiJmFwcF9pZD1cIixcclxuICAgICAgICAgICAgICAgICAgICBBUFBfSURfS09SRUFdLmpvaW4oXCJcIik7XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwiYmxhY2tcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL2JsYWNrLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwid2hpdGVcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3doaXRlLnBuZ1wiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChfc2NoZW1lID09IFwidHJhbnNwYXJlbnRcIilcclxuICAgICAgICAgICAgICAgIHVybCA9IGNtLmdldEhvbWUoKSArIFwicG5nL3RyYW5zcGFyZW50LnBuZ1wiO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2FkVGlsZSlcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmxvYWRUaWxlKGxldmVsLCBjb2wsIHJvdywgdXJsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgX19sYXllciA9IG5ldyBILm1hcC5sYXllci5UaWxlTGF5ZXIoX3Byb3ZpZGVyKTtcclxuXHJcbiAgICAvL2NvbnNvbGUubG9nKFwibm9ybWFsIG1hcFwiKTtcclxuICAgIC8vU3RlcCAyOiBpbml0aWFsaXplIGEgSEVSRU1hcCBcclxuICAgIF9tYXAgPSBuZXcgSC5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEl0ZW0pLFxyXG4gICAgICAgIF9fbGF5ZXIsIHtcclxuICAgICAgICAgICAgY2VudGVyOiBjb29yZEEyTyhzZXR0aW5ncy5jZW50ZXIpLFxyXG4gICAgICAgICAgICB6b29tOiBzZXR0aW5ncy56b29tXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGV0IGJlaGF2aW9yID0gbmV3IEgubWFwZXZlbnRzLkJlaGF2aW9yKG5ldyBILm1hcGV2ZW50cy5NYXBFdmVudHMoX21hcCkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSB0aGUgZGVmYXVsdCBVSSBjb21wb25lbnRzXHJcbiAgICBfdWkgPSBILnVpLlVJLmNyZWF0ZURlZmF1bHQoX21hcCwgX2RlZmF1bHRMYXllcnMpO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGxheWVyXHJcbiAgICBsYXllckNyZWF0ZShcImRlZmF1bHRcIik7XHJcblxyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiXCIsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIGlmIGNhbGxiYWNrIG9uIHpvb20gQ2hhbmdlXHJcbiAgICBpZiAoc2V0dGluZ3Mudmlld0NoYW5nZSkge1xyXG4gICAgICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1hcHZpZXdjaGFuZ2VlbmRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsZXQgYm91bmQgPSBfbWFwLmdldFZpZXdCb3VuZHMoKTtcclxuICAgICAgICAgICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICAgICAgICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpZXdDaGFuZ2UgY2VudGVyIFwiICsgbGF0ICsgXCIgXCIgKyBsbmcpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy52aWV3Q2hhbmdlKF9tYXAuZ2V0Wm9vbSgpLCBbbGF0LCBsbmddKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKiogICAgICAgICAgIHRvIGhhbmRsZSBrZXlib2FyZCB3aGlsZSBtb3VzZSBpbiBtYXAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgbGV0IGt1cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfa2V5LmN0cmwgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LnNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgX2tleS5hbHQgPSBmYWxzZTtcclxuICAgICAgICBfa2V5LmtleSA9IFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIGxldCBrZG93biA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgX2tleS5jdHJsID0gKChlLmtleSA9PSBcIkNvbnRyb2xcIikgfHwgKGUua2V5SWRlbnRpZmllciA9PSBcIkNvbnRyb2xcIikgfHwgKGUuY3RybEtleSA9PSB0cnVlKSk7XHJcbiAgICAgICAgX2tleS5zaGlmdCA9ICgoZS5rZXkgPT0gXCJTaGlmdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiU2hpZnRcIikgfHwgKGUuc2hpZnRLZXkgPT0gdHJ1ZSkpO1xyXG4gICAgICAgIF9rZXkuYWx0ID0gKChlLmtleSA9PSBcIkFsdFwiKSB8fCAoZS5rZXlJZGVudGlmaWVyID09IFwiQWx0XCIpIHx8IChlLnNoaWZ0S2V5ID09IHRydWUpKTtcclxuICAgICAgICBfa2V5LmtleSA9IGUua2V5O1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5rZXlEb3duKSBzZXR0aW5ncy5rZXlEb3duKF9rZXkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1hcCBtb3VzZSBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJtYXAgcG9pbnRlciBlbnRlclwiKTtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZG93bik7XHJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGt1cCk7XHJcbiAgICB9KTtcclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwibWFwIG1vdXNlIGxlYXZlXCIpO1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtkb3duKTtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwga3VwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiAgICAgICAgICAgdG8gaGFuZGxlIGRvdWJsZSBjbGljayAgICAgICAgICoqKioqKioqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZGJsdGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikgcmV0dXJuOyAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBjbGljayBvbiBtYXJrZXJcclxuXHJcbiAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IGV2LmN1cnJlbnRQb2ludGVyLmJ1dHRvbjtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuZGJDbGljayAhPSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHNldHRpbmdzLmRiQ2xpY2soY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHNldHRpbmdzLmRiQ2xpY2soY29vcmRPMkEoY29vcmQpLCBcInJpZ2h0XCIsIF9rZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqICAgICAgICAgICB0byBoYW5kbGUgc2ltcGxlIGNsaWNrICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICBsZXQgYnV0dG9uID0gZXYuY3VycmVudFBvaW50ZXIuYnV0dG9uO1xyXG5cclxuICAgICAgICBpZiAoKGJ1dHRvbiA9PSAwKSAmJiAoc2V0dGluZ3MuY2xpY2tMZWZ0KSlcclxuICAgICAgICAgICAgc2V0dGluZ3MuY2xpY2tMZWZ0KGNvb3JkTzJBKGNvb3JkKSwgXCJsZWZ0XCIsIF9rZXkpO1xyXG4gICAgICAgIGlmICgoYnV0dG9uID09IDIpICYmIChzZXR0aW5ncy5jbGlja1JpZ2h0KSlcclxuICAgICAgICAgICAgc2V0dGluZ3MuY2xpY2tSaWdodChjb29yZE8yQShjb29yZCksIFwicmlnaHRcIiwgX2tleSk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmNsaWNrICE9IFwiXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogc2V0dGluZ3MuY2xpY2soY29vcmRPMkEoY29vcmQpLCBcImxlZnRcIiwgX2tleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHNldHRpbmdzLmNsaWNrKGNvb3JkTzJBKGNvb3JkKSwgXCJyaWdodFwiLCBfa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKioqKioqKiogIGRpc2FibGUgdGhlIGRlZmF1bHQgZHJhZ2dhYmlsaXR5IG9mIHRoZSB1bmRlcmx5aW5nIG1hcCB3aGVuIHN0YXJ0aW5nIHRvIGRyYWcgYSBtYXJrZXIgb2JqZWN0ICoqKioqKioqKioqKioqKioqL1xyXG4gICAgX21hcC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEgubWFwLk1hcmtlcikge1xyXG4gICAgICAgICAgICBiZWhhdmlvci5kaXNhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuICAgIC8qKioqKioqKioqKiogICByZSAtIGVuYWJsZSB0aGUgZGVmYXVsdCBkcmFnZ2FiaWxpdHkgb2YgdGhlIHVuZGVybHlpbmcgbWFwIHdoZW4gZHJhZ2dpbmcgaGFzIGNvbXBsZXRlZCAqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIF9tYXAuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbmRcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgbWFwc2pzLm1hcC5NYXJrZXIpIHtcclxuICAgICAgICAgICAgYmVoYXZpb3IuZW5hYmxlKCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0LmRyYWdnZWQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICAgICAgKHRhcmdldC5kcmFnZ2VkKSh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqICBMaXN0ZW4gdG8gdGhlIGRyYWcgZXZlbnQgYW5kIG1vdmUgdGhlIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgYXMgbmVjZXNzYXJ5ICoqKioqKioqKioqKioqKioqKiovXHJcbiAgICBfbWFwLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQsXHJcbiAgICAgICAgICAgIHBvaW50ZXIgPSBldi5jdXJyZW50UG9pbnRlcjtcclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgbWFwc2pzLm1hcC5NYXJrZXIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uKF9tYXAuc2NyZWVuVG9HZW8ocG9pbnRlci52aWV3cG9ydFgsIHBvaW50ZXIudmlld3BvcnRZKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZmFsc2UpO1xyXG5cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKiAgZGV0ZWN0IG1hcCByZXNpemUgYW5kIGFkanVzdCBhY2NvcmlkbmdseSAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX21hcC5nZXRWaWV3UG9ydCgpLnJlc2l6ZSgpO1xyXG5cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogbGlzdCBvZiBhbGwgYXZhaWxhYmxlIG1hcCBzdHlsZXMgbm9ybWFsLmRheSwgbmlnaHQuLi4uIFxyXG4gKiBAYWxpYXMgaG06Z2V0QXZhaWxhYmxlTWFwU3R5bGVcclxuICogQHJldHVybiB7anNvbn0gbGlzdCBvZiBtYXAgc3R5bGVzIGFzIGpzb25cclxuICovXHJcbmZ1bmN0aW9uIGdldEF2YWlsYWJsZU1hcFN0eWxlKCkge1xyXG4gICAgLy8gaHR0cHM6Ly8xLmJhc2UubWFwcy5hcGkuaGVyZS5jb20vbWFwdGlsZS8yLjEvaW5mbz94bmxwPUNMX0pTTXYzLjAuMTcuMCZhcHBfaWQ9bk9TaDIxMjE0SkZNU0VQUWtxbm8mYXBwX2NvZGU9clhfbDdZdkFMdE5rcVUyYng1RldFQSZvdXRwdXQ9anNvblxyXG5cclxuICAgIGNvbnN0IHNldHRpbmdzID0gY20uYWRkQ3JlZGVudGlhbHMoe1xyXG4gICAgICAgIG91dHB1dDogXCJqc29uXCJcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiMS5iYXNlLm1hcHNcIiwgXCJhcGkuaGVyZS5jb20vbWFwdGlsZS8yLjEvaW5mb1wiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHNldHRpbmdzKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMuYm9keS5yZXNwb25zZTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGRlZmluZSB0aGUgc2NoZW1lLiBMaXN0IG9mIHNjaGVtZSBjYW4gYmUgb2J0YWluZWQgZnJvbSB7aG0uZ2V0QXZhaWxhYmxlTWFwU3R5bGUoKX1cclxuICogQGFsaWFzIGhtOnNldFNjaGVtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1lIHNjaGVtZSBuYW1lXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTY2hlbWUoc2NoZW1lKSB7XHJcbiAgICBfc2NoZW1lID0gc2NoZW1lO1xyXG59XHJcblxyXG4vKipcclxuICogY3JlYXRlIGEgbGF5ZXJcclxuICogQGFsaWFzIGhtOmxheWVyQ3JlYXRlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAtIG5hbWUgb2YgbGF5ZXJcclxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlICAtIGluaXRpYWwgc3RhdHVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLmxheWVyQ3JlYXRlKFwibGF5ZXIxXCIpO1xyXG4gKiAgYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckNyZWF0ZShuYW1lLCB2aXNpYmxlKSB7XHJcbiAgICBncm91cCA9IG5ldyBILm1hcC5Hcm91cCgpO1xyXG4gICAgZ3JvdXAubmFtZSA9IG5hbWU7XHJcbiAgICBfbWFwLmFkZE9iamVjdChncm91cCk7XHJcblxyXG4gICAgLy8gcHVzaCBpbnRvIGxpc3Qgb2YgbGF5ZXJzXHJcbiAgICBfbGF5ZXJzLnB1c2goZ3JvdXApO1xyXG5cclxuICAgIC8vIGNhbiBiZSB2aXNpYmxlIG9yIGhpZGRlblxyXG4gICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9IFwidW5kZWZpbmVkXCIpXHJcbiAgICAgICAgZ3JvdXAuc2V0VmlzaWJpbGl0eSh2aXNpYmxlKTtcclxuXHJcbiAgICByZXR1cm4gZ3JvdXA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBkZWxldGUgYSBsYXllclxyXG4gKiBAYWxpYXMgaG06bGF5ZXJEZWxldGVcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiBsYXllclxyXG4gKi9cclxuZnVuY3Rpb24gbGF5ZXJEZWxldGUobmFtZSkge1xyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKG5hbWUpO1xyXG4gICAgaWYgKCFsYXllcilcclxuICAgICAgICByZXR1cm47XHJcblxyXG4gICAgbGF5ZXIubmFtZSA9IG51bGw7XHJcbiAgICBfbWFwLnJlbW92ZU9iamVjdChsYXllcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbXB0eSBhIGxheWVyLCBhY3R1YWxseSBkZWxldGVzIGl0IGFuZCByZWNyZWF0ZSBpdFxyXG4gKiBAYWxpYXMgaG06bGF5ZXJFbXB0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgXHJcbiAqL1xyXG5mdW5jdGlvbiBsYXllckVtcHR5KG5hbWUpIHtcclxuICAgIGxheWVyRGVsZXRlKG5hbWUpO1xyXG4gICAgbGF5ZXJDcmVhdGUobmFtZSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogZmluZCBsYXllciBieSBpdHMgbmFtZSBvciByZXR1cm4gbnVsbCBcclxuICogQGFsaWFzIGhtOmxheWVyRmluZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcclxuICovXHJcbmZ1bmN0aW9uIGxheWVyRmluZChuYW1lKSB7XHJcbiAgICBsZXQgbCA9IF9sYXllcnMuZmluZChsYXllciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyLm5hbWUgPT0gbmFtZTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHR5cGVvZiBsID09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGw7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogc2V0IGNlbnRlciBvZiB0aGUgbWFwXHJcbiogQGFsaWFzIGhtOnNldENlbnRlclxyXG4gKiBAcGFyYW0ge0FycmF5fSAtIGNvb3JkIGFzIFtsYXQsbG5nXVxyXG4gKiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGhtLnNldENlbnRlcihbNDguOCwyLjNdKTtcclxuICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q2VudGVyKGNvb3JkKSB7XHJcbiAgICBfbWFwLnNldENlbnRlcihjb29yZEEyTyhjb29yZCkpO1xyXG59XHJcblxyXG4vKipcclxuICogcmV0dXJuIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwXHJcbiAqIEBhbGlhcyBobTpnZXRDZW50ZXJcclxuICogQHJldHVybnMge2Nvb3JkfSBjb29yZCBvZiB0aGUgY2VudGVyIGFzIFxcW2xhdCxsbmdcXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldENlbnRlcigpIHtcclxuICAgIGxldCBib3VuZCA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG4gICAgLy9fSE0ubG9nKFwidmlld2JvdW5kXCIsYm91bmQpO1xyXG5cclxuICAgIGxldCBsbmcgPSAoYm91bmQuZ2EgKyBib3VuZC5oYSkgLyAyO1xyXG4gICAgbGV0IGxhdCA9IChib3VuZC5rYSArIGJvdW5kLmphKSAvIDI7XHJcbiAgICByZXR1cm4gW2xhdCwgbG5nXTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiByZXR1cm4gYm91bmRpbmcgYm94IG9mIHZpc2libGUgcGFydCBvZiBtYXBcclxuICogQGFsaWFzIGhtOmdldFZpZXdCQlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBib3VkaW5nIGJveCBvZiB2aXNpYmxlIHBhcnQgb2YgdGhlIG1hcCwgYXMgXFxbbGF0bSxsYXRNLGxvbmdtLGxuZ01cXF1cclxuICovXHJcbmZ1bmN0aW9uIGdldFZpZXdCQigpIHtcclxuICAgIGxldCBiYiA9IF9tYXAuZ2V0Vmlld0JvdW5kcygpO1xyXG5cclxuICAgIGxldCBiYjIgPSB7XHJcbiAgICAgICAgbGF0bTogYmIuamEsXHJcbiAgICAgICAgbGF0TTogYmIua2EsXHJcbiAgICAgICAgbG5nbTogYmIuZ2EsXHJcbiAgICAgICAgbG5nTTogYmIuaGFcclxuICAgIH07XHJcbiAgICByZXR1cm4gYmIyO1xyXG59XHJcblxyXG4vKipcclxuICogc2V0cyBib3VkaW5nIGJveCB0byBiZSBkaXNwbGF5ZWRcclxuICogQGFsaWFzIGhtOnNldFZpZXdCQlxyXG4gKiBAcGFyYW0gb3B0IHtPYmplY3R8IHN0cmluZ30gIGVpdGhlciBhbiBvYmplY3Qgc3BlY2lmeWluZyBob3cgdG8gc2V0IGJvdW5kaW5nIGJveCwgb3IgIGEgU3RyaW5nIGJlaW5nIHRoZSBuYW1lIG9mIGEgbGF5ZXJcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtzdHJpbmd9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBvYmplY3RzIG9mIHRoZSBsYXllclxyXG4gKiBAcGFyYW0gW29wdC5wb2lzXSB7YXJyYXl9IGJvdWRpbmcgYm94IGFyb3VkIGFsbCBjb29yZHMgZGVmaW5lZCBhcyBcXFtjb29yZCxjb29yZC4uLlxcXVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gICogaG0uc2V0Vmlld0JCKFwibGF5ZXIxXCIpO1xyXG4gKlxyXG4gKiBobS5zZXRWaWV3QkIoe1xyXG4gICAgKiAgICBwb2lzOiBjb29yZHNcclxuICAgICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHNldFZpZXdCQihvcHQpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9wdCA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgIG9wdCA9IHsgbGF5ZXI6IG9wdCB9O1xyXG5cclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogbnVsbCxcclxuICAgICAgICBwb2lzOiBudWxsIC8vIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGJib3g7XHJcblxyXG4gICAgLy9zZXQgQkIgYmFzZWQgb24gbGF5ZXJcclxuICAgIGlmIChzZXR0aW5ncy5sYXllcikge1xyXG4gICAgICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBnZXQgdmlldyBib3VuZCBhbmQgYWRkIGEgYml0IGFyb3VuZCwgbGlrZSAxLzVcclxuICAgICAgICBsZXQgYmIgPSBsYXllci5nZXRCb3VuZHMoKTtcclxuICAgICAgICBpZiAoIWJiKSAvLyBhcyBpZiBub3RoaW5nIGluIGxheWVyXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBiYi5sYXRtID0gYmIuamE7XHJcbiAgICAgICAgYmIubGF0TSA9IGJiLmthO1xyXG4gICAgICAgIGJiLmxuZ20gPSBiYi5nYTtcclxuICAgICAgICBiYi5sbmdNID0gYmIuaGE7XHJcbiAgICAgICAgbGV0IGR4ID0gYmIubG5nTSAtIGJiLmxuZ207XHJcbiAgICAgICAgbGV0IGR5ID0gYmIubGF0TSAtIGJiLmxhdG07XHJcbiAgICAgICAgZHggPSBkeCAvIDU7XHJcbiAgICAgICAgZHkgPSBkeSAvIDU7XHJcbiAgICAgICAgYmIubGF0TSArPSBkeTtcclxuICAgICAgICBiYi5sbmdtIC09IGR4O1xyXG4gICAgICAgIGJiLmxhdG0gLT0gZHk7XHJcbiAgICAgICAgYmIubG5nTSArPSBkeDtcclxuICAgICAgICBiYm94ID0gbmV3IEguZ2VvLlJlY3QoYmIubGF0TSwgYmIubG5nbSwgYmIubGF0bSwgYmIubG5nTSk7XHJcbiAgICAgICAgX21hcC5zZXRWaWV3Qm91bmRzKGJib3gsIHRydWUpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChzZXR0aW5ncy5wb2lzKSB7XHJcbiAgICAgICAgbGV0IGJiID0ge1xyXG4gICAgICAgICAgICBsYXRNOiAwLFxyXG4gICAgICAgICAgICBsbmdtOiAxODAsXHJcbiAgICAgICAgICAgIGxhdG06IDkwLFxyXG4gICAgICAgICAgICBsbmdNOiAtMTgwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGFyciA9IHNldHRpbmdzLnBvaXM7XHJcbiAgICAgICAgYXJyLmZvckVhY2goKHBvaSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAocG9pWzBdID4gYmIubGF0TSkgYmIubGF0TSA9IHBvaVswXTtcclxuICAgICAgICAgICAgaWYgKHBvaVsxXSA+IGJiLmxuZ00pIGJiLmxuZ00gPSBwb2lbMV07XHJcbiAgICAgICAgICAgIGlmIChwb2lbMF0gPCBiYi5sYXRtKSBiYi5sYXRtID0gcG9pWzBdO1xyXG4gICAgICAgICAgICBpZiAocG9pWzFdIDwgYmIubG5nbSkgYmIubG5nbSA9IHBvaVsxXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYm94ID0gbmV3IEguZ2VvLlJlY3QoYmIubGF0TSwgYmIubG5nbSwgYmIubGF0bSwgYmIubG5nTSk7XHJcbiAgICAgICAgX21hcC5zZXRWaWV3Qm91bmRzKGJib3gsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIHJldHVybiB6b29tIHZhbHVlXHJcbiAqIEBhbGlhcyBobTpnZXRab29tXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbGV2ZWxcclxuICovXHJcbmZ1bmN0aW9uIGdldFpvb20oKSB7XHJcbiAgICByZXR1cm4gX21hcC5nZXRab29tKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzZXQgem9vbSBsZXZlbFxyXG4gKiBAYWxpYXMgaGVyZW1hcDpzZXRab29tXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Wm9vbSh6b29tKSB7XHJcbiAgICBfbWFwLnNldFpvb20oem9vbSk7XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGNyZWF0ZSBhbiBpY29uLCB0byBiZSB1c2VkIGZvciBhIG1hcmtlclxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgdG8gc3BlY2lmeSB0aGUgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5pbWddIHtzdHJpbmd9ICB1c2UgYSBwbmcvanBnIGltYWdlLiBTcGVjaWZ5IHRoZSB1cmwgXHJcbiAqIEBwYXJhbSBbb3B0LnN2Z10ge3N0cmluZ30gIHVybCBhIHN2Zy4gVGhpcyBjYW4gYmUgYW4gaW5saW5lIHN2ZywgYSB1cmwsIG9yIGEgc3ZnIGZyb20gaGVyZW1hcFxyXG4gKiBAcGFyYW0gW29wdC5vcHRdIHtvYmplY3R9ICAgc3R5bGUgb2JqZWN0XHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5zaXplXSB7bnVtYmVyfHN0cmluZ30gICBzaXplIG9mIGljb24sIGFzIDI0IG9yIDI0eDMyXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5yYXRpb10ge251bWJlcn0gICBmb3Igc3ZnIGZpbGVzLCByYXRpbyBvZiBzaXplLiAwLjUgPSBoYWxmXHJcbiAqIEBwYXJhbSBbb3B0Lm9wdC5hbmNob3JdIHtudW1iZXJ8c3RyaW5nfSAgIGFuY2hvciBvZiBpY29uLCBhcyAyNCBvciAyNHgzMi4gQnkgZGVmYXVsdCwgYm90dG9tLWNlbnRlclxyXG4gKiBAcGFyYW0gW29wdC5vcHQudGFnXSB7c3RyaW5nfSAgIGZvciBzdmcsIGFueSB0YWcgbGlrZXt0YWd9LiB3aWxsIGJlIHJlcGxhY2VkIGJ5IGFzc29jaWF0ZWQgdmFsdWVcclxuICogQHJldHVybiB7SC5tYXAuSWNvbn0gdGhlIGNyZWF0ZWQgaWNvblxyXG4gKiBAZXhhbXBsZSBcclxuICogYGBganNcclxuICogaG0uYnVpbGRJY29uKHtcclxuICogICAgaW1nOiBcImh0dHA6Ly93aGF0ZXZlci5jb20vaW1hZ2UucG5nXCIsXHJcbiAqICAgIG9wdDoge3NpemU6MjR9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0uYnVpbGRJY29uKHtcclxuICogICAgc3ZnOiBcImh0dHA6Ly93aGF0ZXZlci5jb20vaW1hZ2Uuc3ZnXCIsXHJcbiAqICAgIG9wdDoge1xyXG4gKiAgICAgICBzaXplOjI0LFxyXG4gKiAgICAgICBhbmNob3I6MjR4MzJcclxuICogICAgfVxyXG4gKiB9KTtcclxuICogIFxyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IFwic3ZnL2NsdXN0ZXIuc3ZnXCIsXHJcbiAqICAgIG9wdDoge1xyXG4gKiAgICAgICBzaXplOjI0LFxyXG4gKiAgICAgICBjb2xvcjpcInJlZFwiXHJcbiAqICAgIH1cclxuICogfSk7XHJcbiAqIFxyXG4gKiBjb25zdCBzdmcgPSBgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+IDxlbGxpcHNlIHN0cm9rZT1cIm51bGxcIiByeT1cIjhcIiByeD1cIjcuNjE4ODk2XCIgaWQ9XCJzdmdfMVwiIGN5PVwiOFwiIGN4PVwiNy44Mzc0MjdcIiBmaWxsPVwie2NvbG9yfVwiIGZpbGwtb3BhY2l0eT1cIjAuOVwiLz48L3N2Zz5gO1xyXG4gKiBobS5idWlsZEljb24oe1xyXG4gKiAgICBzdmc6IHN2ZyxcclxuICogICAgb3B0OiB7XHJcbiAqICAgICAgIHNpemU6MjQsXHJcbiAqICAgICAgIGNvbG9yOlwicmVkXCJcclxuICogICAgfSBcclxuICogfSk7XHJcbiAqICBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkSWNvbihvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBpbWc6IG51bGwsICAgICAgICAgICAgIC8vICAgcG5nLCBqcGcuIGlmIG5vdCBodHRwIGluIHRoZSBiZWdpbm5pbmcsIGxvb2sgbG9jYWxseVxyXG4gICAgICAgIHN2ZzogbnVsbCwgICAgICAgICAgICAgLy8gc3ZnIGZpbGU6ICBpcyBhIHVybCBvciBhIHN0cmluZ1xyXG4gICAgICAgIG9wdDogbnVsbCwgICAgICAgICAgICAgIC8vIHNpemUsIGNvbG9yLCBhbmNob3IsIHRleHQuLi5zXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5pbWcgJiYgIXNldHRpbmdzLnN2Zykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpY29uLCBpY29uU3JjO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5pbWcpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInNldHRpbmdzLmltZ1wiLCBzZXR0aW5ncy5pbWcpO1xyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuaW1nLnN1YnN0cigwLCA0KSA9PSBcImh0dHBcIikgLy8gdXJsXHJcbiAgICAgICAgICAgIGljb25TcmMgPSBzZXR0aW5ncy5pbWc7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBpY29uU3JjID0gY20uZ2V0UHJvdG9jb2woKSArIHNldHRpbmdzLmltZzsgLy8gbG9jYWwgZmlsZVxyXG5cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNldHRpbmdzLnN2Zykge1xyXG5cclxuICAgICAgICBsZXQgdXJsID0gbnVsbDtcclxuICAgICAgICBpY29uU3JjID0gc2V0dGluZ3Muc3ZnO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5zdmcuc3Vic3RyKDAsIDQpID09IFwiaHR0cFwiKSAvLyB1cmxcclxuICAgICAgICAgICAgdXJsID0gc2V0dGluZ3Muc3ZnO1xyXG4gICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLnN2Zy5zdWJzdHIoMCwgNCkgPT0gXCI8c3ZnXCIpIC8vIHVybFxyXG4gICAgICAgICAgICB1cmwgPSBudWxsO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdXJsID0gY20uZ2V0SG9tZSgpICsgc2V0dGluZ3Muc3ZnOyAvL21pc3NpbmcgcHJvdG9jb2wsIG5vdCBhbiBlbWJlZGRlZCBzdHJpbmcsIGxvb2sgaW4gbG9jYWwgaGVyZW1hcCBtb2R1bGVcclxuXHJcbiAgICAgICAgaWYgKHVybCkgLy8gYW4gdXJsIHRvIGRvd25sb2FkXHJcbiAgICAgICAgICAgIGljb25TcmMgPSBhd2FpdCBmZXRjaCh1cmwpXHJcbiAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzICE9IDIwMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgaWNvbk9wdCA9IHsgY3Jvc3NPcmlnaW46IHRydWUgfTsgLy8gdG8gYXZvaWQgaXNzdWVkIHdpdGggY2FwdHVyZVxyXG4gICAgaWYgKHNldHRpbmdzLm9wdCAmJiBzZXR0aW5ncy5vcHQuc2l6ZSkge1xyXG4gICAgICAgIGxldCB3LCBoO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub3B0LnNpemUgPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgdyA9IGggPSBzZXR0aW5ncy5vcHQuc2l6ZTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIFt3LCBoXSA9IHNldHRpbmdzLm9wdC5zaXplLnNwbGl0KFwieFwiKTtcclxuXHJcbiAgICAgICAgaWNvbk9wdC5zaXplID0geyB3OiB3LCBoOiBoIH07XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dGluZ3Muc3ZnICYmIHNldHRpbmdzLm9wdCAmJiBzZXR0aW5ncy5vcHQucmF0aW8pIHtcclxuICAgICAgICBsZXQgdyA9IG51bGwsIGggPSBudWxsLCBtYXRjaCA9IG51bGw7XHJcblxyXG4gICAgICAgIGxldCByID0gL3dpZHRoPVwiKFxcZCspXCIvO1xyXG4gICAgICAgIG1hdGNoID0gaWNvblNyYy5tYXRjaChyKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHcgPSBtYXRjaFsxXTtcclxuXHJcbiAgICAgICAgciA9IC9oZWlnaHQ9XCIoXFxkKylcIi87XHJcbiAgICAgICAgbWF0Y2ggPSBpY29uU3JjLm1hdGNoKHIpO1xyXG4gICAgICAgIGlmIChtYXRjaCkgaCA9IG1hdGNoWzFdO1xyXG4gICAgICAgIGljb25PcHQuc2l6ZSA9IHsgdzogTWF0aC5mbG9vcih3ICogc2V0dGluZ3Mub3B0LnJhdGlvKSwgaDogTWF0aC5mbG9vcihoICogc2V0dGluZ3Mub3B0LnJhdGlvKSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXR0aW5ncy5vcHQgJiYgc2V0dGluZ3Mub3B0LmFuY2hvcikge1xyXG4gICAgICAgIGxldCB3LCBoO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub3B0LmFuY2hvciA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICB3ID0gaCA9IHNldHRpbmdzLm9wdC5hbmNob3I7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBbdywgaF0gPSBzZXR0aW5ncy5vcHQuYW5jaG9yLnNwbGl0KFwieFwiKTtcclxuICAgICAgICBpY29uT3B0LmFuY2hvciA9IG5ldyBILm1hdGguUG9pbnQodywgaCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWxsIG90aGVyIGZpZWxkcyBhcmUgdHJlYXRlZCBhcyBncmFwaGljIGVuaGFuY2VlbnRcclxuICAgIGlmIChzZXR0aW5ncy5vcHQpIHtcclxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNldHRpbmdzLm9wdCkge1xyXG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImZpbGVcIiB8fCBuYW1lID09IFwic2l6ZVwiIHx8IG5hbWUgPT0gXCJhbmNob3JcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCByZSA9IG5ldyBSZWdFeHAoXCJ7XCIgKyBuYW1lICsgXCJ9XCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgaWNvblNyYyA9IGljb25TcmMucmVwbGFjZShyZSwgc2V0dGluZ3Mub3B0W25hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uU3JjXCIsIGljb25TcmMpO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJpY29uT3B0XCIsIGljb25PcHQpO1xyXG4gICAgaWNvbiA9IG5ldyBILm1hcC5JY29uKGljb25TcmMsIGljb25PcHQpO1xyXG5cclxuICAgIHJldHVybiBpY29uO1xyXG5cclxufSAvL2VuZCBvZiBpY29uXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIGFkZCBhIG1hcmtlciBpbiBhIGxheWVyXHJcbiAqIHN2ZyBmaWxlcyBjYW4gYmUgY3JlYXRlZCB3aXRoIGh0dHBzOi8vZWRpdG9yLm1ldGhvZC5hYy8gXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bWFya2VyXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gb3B0aW9ucyB0byBjcmVhdGUgdGhlIG1hcmtlclxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge3N0cmluZ30gICBsYXllciBuYW1lXHJcbiAqIEBwYXJhbSBbb3B0LmNvb3JkXSB7Y29vcmR9ICAgY29vcmQgb2YgdGhlIG1hcmtlciBhcyBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBbb3B0Lmljb25dIHtzdHJpbmd9ICAgY3JlYXRlZCBmcm9tIGhtLmJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gW29wdC5zdmddIHtzdHJpbmd9ICAgc2VlIGhtLmJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gW29wdC5vcHRdIHtPYmplY3R9ICAgc2VlIGhtLmJ1aWxkSWNvblxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQucG9pbnRlcmVudGVyICBpZiBlbnRlciwgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2KVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHQucG9pbnRlckNsaWNrICBpZiBjbGljaywgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2KVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0LmRhdGEgIG9wdGlvbmFsIGRhdGFcclxuICogQHBhcmFtIHtib29sZWFufSBvcHQuYnViYmxlICBpZiB0cnVlLCBzaG93IGJ1YmxlIG9uIGNsaWNrIHdpdGggZGF0YVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdC5kcmFnZ2FibGUgIGRyYWdnYWJsZSBtYXJrZXJcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0LmRyYWdnZWQgIGlmIGRyYWdnZWQsIGNhbGxiYWNrKHRhcmdldCxjb29yZClcclxuICogQGV4YW1wbGUgXHJcbiAqIGBgYGpzXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdLFxyXG4gKiB9KTtcclxuICogXHJcbiAqIGhtLm1hcmtlcih7XHJcbiAgICAqICAgc3ZnOiBcInN2Zy9tYXJrZXIuc3ZnXCIsXHJcbiAgICAqICAgY29sb3I6XCJyZWRcIixcclxuICAgICogICBzaXplOjE2XHJcbiAgICAqIH0pO1xyXG4gICAgKiBcclxuICogaG0ubWFya2VyKHtcclxuICogICAgaW1nOiBcImh0dHA6Ly93aGF0ZXZlci5jb20vaW1hZ2UucG5nXCIsXHJcbiAqICAgIGNvb3JkOiBbNDguOCwyLjNdXHJcbiAqIH0pO1xyXG4gKiBcclxuICogaG0ubWFya2VyKHtcclxuICogICAgY29vcmQ6IFs0OC44LDIuM10sXHJcbiAqICAgIGRhdGE6XCJIZWxsbyB3b3JsZFwiLFxyXG4gKiAgICBidWJibGU6IHRydWVcclxuICogfSk7XHJcbiAqIFxyXG4gKiBobS5tYXJrZXIoe1xyXG4gKiAgICBjb29yZDogWzQ4LjgsMi4zXSxcclxuICogICAgZHJhZ2dhYmxlOnRydWUsXHJcbiAqICAgIGRyYWdnZWQ6IGZ1bmN0aW9uKHRhcmdldCxjb29yZCkge2NvbnNvbGUubG9nKFwiZHJhZ2dlZCB0b1wiLGNvb3JkKTt9XHJcbiAqIH0pO1xyXG4qICBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIG1hcmtlcihvcHQpIHtcclxuICAgIGxldCBzZXR0aW5ncyA9IHtcclxuICAgICAgICBsYXllcjogXCJkZWZhdWx0XCIsICAgICAgIC8vICBsYXllciBpbiB3aGljaCB0byBhZGQgbWFya2VyXHJcbiAgICAgICAgY29vcmQ6IG51bGwsICAgICAgICAgICAgLy8gIGNvb3JkIG9mIHRoZSBtYXJrZXJcclxuICAgICAgICBpbWc6IG51bGwsICAgICAgICAgICAgIC8vICBpbWFnZSBjYW4gYmUgdXJsLCBwbmcsIGpwZy4uXHJcbiAgICAgICAgc3ZnOiBudWxsLCAgICAgICAgICAgICAvLyBzdmcgZmlsZVxyXG4gICAgICAgIGljb246IG51bGwsICAgICAgICAgICAgICAvLyBpY29uIHByZXZpb3VzbHkgY3JlYXRlZFxyXG4gICAgICAgIG9wdDoge30sICAgICAgICAgICAgICAgLy8gb3B0IGZvciBpY29uXHJcbiAgICAgICAgcG9pbnRlckVudGVyOiBudWxsLCAgICAgLy8gIGNhbGxiYWNrKHRhcmdldCxjb29yZCxldilcclxuICAgICAgICBwb2ludGVyQ2xpY2s6IG51bGwsICAgICAvLyAgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2KVxyXG4gICAgICAgIGRhdGE6IG51bGwsICAgICAgICAgICAgIC8vICB1c2VyIGRhdGFcclxuICAgICAgICBidWJibGU6IGZhbHNlLCAgICAgICAgICAvLyAgc2hvdyBhIGJ1YmJsZSB3aXRoIHVzZXIgZGF0YVxyXG4gICAgICAgIGRyYWdnYWJsZTogZmFsc2UsICAgICAgIC8vICBpY29uIGlzIGRyYWdnYWxiZVxyXG4gICAgICAgIGRyYWdnZWQ6IG51bGwgICAgICAgICAgIC8vICBjYWxsYmFjayh0YXJnZXQsY29vcmQpXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHRpbmdzLmNvb3JkID0geyBsYXQ6IHNldHRpbmdzLmNvb3JkWzBdLCBsbmc6IHNldHRpbmdzLmNvb3JkWzFdIH07XHJcblxyXG4gICAgLy8gdGhlc2UgcGFyYW1ldGVycyBjYW4gYmUgaW4gb3B0Lm9wdCBvciBkaXJlY3RseSBpbiBvcHRcclxuICAgIGlmIChzZXR0aW5ncy5jb2xvcikgc2V0dGluZ3Mub3B0LmNvbG9yID0gc2V0dGluZ3MuY29sb3I7XHJcbiAgICBpZiAoc2V0dGluZ3Muc2l6ZSkgc2V0dGluZ3Mub3B0LnNpemUgPSBzZXR0aW5ncy5zaXplO1xyXG4gICAgaWYgKHNldHRpbmdzLnJhdGlvKSBzZXR0aW5ncy5vcHQucmF0aW8gPSBzZXR0aW5ncy5yYXRpbztcclxuICAgIGlmIChzZXR0aW5ncy5hbmNob3IpIHNldHRpbmdzLm9wdC5zaXplID0gc2V0dGluZ3MuYW5jaG9yO1xyXG5cclxuICAgIGxldCBtYXJrZXJPcHQgPSBudWxsO1xyXG4gICAgaWYgKHNldHRpbmdzLmltZyB8fCBzZXR0aW5ncy5zdmcpIHtcclxuICAgICAgICBsZXQgaWNvbiA9IGF3YWl0IGJ1aWxkSWNvbihzZXR0aW5ncyk7XHJcbiAgICAgICAgbWFya2VyT3B0ID0geyBpY29uOiBpY29uIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzZXR0aW5ncy5pY29uKSB7XHJcbiAgICAgICAgbWFya2VyT3B0ID0geyBpY29uOiBzZXR0aW5ncy5pY29uIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy9jb25zb2xlLmxvZyhcIm1hcmtlciBzZXR0aW5ncy5jb29yZFwiLCBzZXR0aW5ncy5jb29yZCk7XHJcbiAgICBsZXQgbWFya2VyID0gbmV3IEgubWFwLk1hcmtlcihzZXR0aW5ncy5jb29yZCwgbWFya2VyT3B0KTtcclxuXHJcbiAgICBtYXJrZXIuZHJhZ2dhYmxlID0gc2V0dGluZ3MuZHJhZ2dhYmxlO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kcmFnZ2VkKSBtYXJrZXIuZHJhZ2dlZCA9IHNldHRpbmdzLmRyYWdnZWQ7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmRhdGEpXHJcbiAgICAgICAgbWFya2VyLnNldERhdGEoc2V0dGluZ3MuZGF0YSk7XHJcblxyXG4gICAgLy8gZ2V0IGNsaWNrIGZyb20gbW91c2VcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyRW50ZXIpIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKiAgY2FsbGJhY2sgd2hlbiBjbGljayBvbiBtYXJrZXIgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKSB7XHJcbiAgICAgICAgbWFya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0YXBcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyQ2xpY2sodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqKioqKioqKioqKiAgc2hvdyBhIGJ1YmJsZSB3aGVuIGNsaWNraW5nIG9uIG1hcmtlciAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuICAgIGlmIChzZXR0aW5ncy5idWJibGUpIHtcclxuICAgICAgICBtYXJrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gdGFyZ2V0LmdldERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcblxyXG4gICAgICAgICAgICBidWJibGVVbmlxdWUoY29vcmRPMkEoY29vcmQpLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QobWFya2VyKTtcclxuICAgIHJldHVybiBtYXJrZXI7XHJcblxyXG59IC8vZW5kIG9mIG1hcmtlclxyXG5cclxuLyoqXHJcbiAqIGRpc3BsYXkgYSB1bmlxdWUgYnViYmxlLiBBc3NvY2lhdGVkIENTUyBzdHlsZSBpcyAuSF9pYl9ib2R5XHJcbiAqIEBhbGlhcyBobTpidWJibGVVbmlxdWVcclxuICogQHBhcmFtIHtBcnJheX0gY29vcmQgb2YgdGhlIGJ1YmJsZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHh0IGh0bWwgdGV4dCB0byBkaXNwbGF5XHJcbiAqL1xyXG5mdW5jdGlvbiBidWJibGVVbmlxdWUoY29vcmQsIHR4dCkge1xyXG5cclxuICAgIGlmICghX2J1YmJsZU1hcmtlcikge1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIgPSBuZXcgSC51aS5JbmZvQnViYmxlKFxyXG4gICAgICAgICAgICBjb29yZEEyTyhjb29yZCksIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHR4dFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3VpLmFkZEJ1YmJsZShfYnViYmxlTWFya2VyKTtcclxuICAgICAgICBfYnViYmxlTWFya2VyLmFkZENsYXNzKFwiYnViYmxlVW5pcXVlXCIpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgX2J1YmJsZU1hcmtlci5zZXRQb3NpdGlvbihjb29yZEEyTyhjb29yZCkpO1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIuc2V0Q29udGVudCh0eHQpO1xyXG4gICAgICAgIF9idWJibGVNYXJrZXIub3BlbigpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBoaWRlIGEgdW5pcXVlIGJ1YmJsZVxyXG4gKiBAYWxpYXMgaG06YnViYmxlVW5pcXVlSGlkZVxyXG4gKi9cclxuZnVuY3Rpb24gYnViYmxlVW5pcXVlSGlkZSgpIHtcclxuICAgIGlmICghX2J1YmJsZU1hcmtlcilcclxuICAgICAgICByZXR1cm47XHJcbiAgICBfYnViYmxlTWFya2VyLmNsb3NlKCk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEcmF3IGEgcG9seWxpbmUuIFxyXG4gKiBAYWxpYXMgaG06cG9seWxpbmVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSAgIG9wdGlvbnMgdG8gZHJhdyBwb2x5bGluZVxyXG4gKiBAcGFyYW0gW29wdC5sYXllcl0ge1N0cmluZ30gb3B0aW9uYWwgbGF5ZXIgdG8gdXNlIFxyXG4gKiBAcGFyYW0gW29wdC5jb29yZHNdIHthcnJheX0gYXJyYXkgb2YgY29vcmRzLCBhcyBcXFtcXFs0OC44LDIuM1xcXSxcXFs0OC44NSwyLjRcXF0sLi4uIFxcXVxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZV0ge29iamVjdH0gb3B0aW9uYWwgZ3JhcGhpYyBzdHlsZVxyXG4gKiBAcGFyYW0gW29wdC5saW5lV2lkdGg9NF0ge251bWJlcn0gbGluZSB3aWR0aFxyXG4gKiBAcGFyYW0gW29wdC5zdHlsZS5zdHJva2VDb2xvcj1yZ2JhKDAsIDEyOCwgMjU1LCAwLjcpXSB7c3RyaW5nfSBsaW5lIGNvbG9yXHJcbiAqIEBwYXJhbSBbb3B0LmFycm93c10ge29iamVjdH0gb3B0aW9uYWwgYXJyb3dcclxuICogQHBhcmFtIFtvcHQuZGF0YV0ge1N0cmluZ30gb3B0aW9uYWwgdXNlciBkYXRhXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJDbGlja10ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBjbGljayBvbiBsaW5lLiBmb3JtYXQgY2FsbGJhY2sodGFyZ2V0LGNvb3JkLGV2ZW50KVxyXG4gKiBAcGFyYW0gW29wdC5wb2ludGVyZW50ZXJdIHtmdW5jdGlvbn0gb3B0aW9uYWwgY2FsbGJhY2sgaWYgbW91c2UgZW50ZXJzIG9uIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnBvaW50ZXJMZWF2ZV0ge2Z1bmN0aW9ufSBvcHRpb25hbCBjYWxsYmFjayBpZiBtb3VzZSBsZWF2ZXMgdGhlIGxpbmUuIGZvcm1hdCBjYWxsYmFjayh0YXJnZXQsY29vcmQsZXZlbnQpXHJcbiAqIEBwYXJhbSBbb3B0LnpdIHtudW1iZXJ9IG9wdGlvbmFsIHogbGV2ZWxcclxuKiBgYGBqc1xyXG4qIGhtLnBvbHlsaW5lKHtcclxuICAgICogICAgY29vcmRzOiBbWzQ4LjgsMi4zXSxbNDguODUsMi40XSxbNDguOSwyLjZdXSxcclxuICAgICogICAgbGF5ZXI6XCJsYXllcjFcIlxyXG4gICAgKiB9KTtcclxuICAgICogXHJcbiAgICAqIGhtLnBvbHlsaW5lKHtcclxuICAgICogICAgY29vcmRzOiBjb29yZHMsXHJcbiAgICAqICAgIHN0eWxlOiB7XHJcbiAgICAqICAgICAgICBsaW5lV2lkdGg6IDQsXHJcbiAgICAqICAgICAgICBzdHJva2VDb2xvcjogXCJyZWRcIlxyXG4gICAgKiAgICB9LFxyXG4gICAgKiB9KTtcclxuICAgICogXHJcbiAgICAqIGhtLnBvbHlsaW5lKHtcclxuICAgICAgICAqICAgIGNvb3JkczogY29vcmRzLFxyXG4gICAgICAgICogICAgZGF0YTpcIkhlbGxvIFdvcmxkXCIsXHJcbiAgICAgICAgKiB9KTtcclxuICAgICogIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWxpbmUob3B0KSB7XHJcbiAgICBsZXQgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbGF5ZXI6IFwiZGVmYXVsdFwiLFxyXG4gICAgICAgIGNvb3JkczogbnVsbCwgLy8gY29vcmRzIGlzIGxpc3Qgb2YgYXJyYXkgb2YgW2xhdCxsbmddIG9yIGFycmF5IG9mIG9iamVjdCB3aXRoIHtsYXQ6LGxuZzp9XHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgbGluZVdpZHRoOiA0LFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMjU1LCAwLjcpXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFycm93czogbnVsbCxcclxuICAgICAgICBkYXRhOiBudWxsLCAgICAgICAgIC8vIG9wdGlvbmFsIHVzZXIgZGF0YSBcclxuICAgICAgICB6OiBudWxsLFxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgLy8gY2xpY2tcclxuICAgICAgICBwb2ludGVyRW50ZXI6IG51bGwsIC8vIGNhbGwgYmFja1xyXG4gICAgICAgIHBvaW50ZXJMZWF2ZTogbnVsbCAvLyBjYWxsIGJhY2tcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBsZXQgbGF5ZXIgPSBsYXllckZpbmQoc2V0dGluZ3MubGF5ZXIpO1xyXG4gICAgaWYgKCFsYXllcikge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwibGF5ZXIgbm90IGZvdW5kOlwiICsgc2V0dGluZ3MubGF5ZXIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5jb29yZHMpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcIlBvbHlsaW5lOiBjb29yZHMgbm90IGZvdW5kOlwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzdHJpcCA9IG5ldyBILmdlby5TdHJpcCgpO1xyXG5cclxuICAgIHNldHRpbmdzLmNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHN0cmlwLnB1c2hMYXRMbmdBbHQocG9pbnRbMF0sIHBvaW50WzFdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBwb2x5bGluZSA9IG5ldyBILm1hcC5Qb2x5bGluZShzdHJpcCwge1xyXG4gICAgICAgIHN0eWxlOiBzZXR0aW5ncy5zdHlsZSxcclxuICAgICAgICBkYXRhOiBzZXR0aW5ncy5kYXRhLFxyXG4gICAgICAgIGFycm93czogc2V0dGluZ3MuYXJyb3dzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBaIGluZGV4XHJcbiAgICBpZiAoc2V0dGluZ3MueikgcG9seWxpbmUuc2V0WkluZGV4KHNldHRpbmdzLnopO1xyXG4gICAgLy8gdXNlciBkYXRhXHJcbiAgICBpZiAoc2V0dGluZ3MuZGF0YSkgcG9seWxpbmUuc2V0RGF0YShzZXR0aW5ncy5kYXRhKTtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckVudGVyKVxyXG4gICAgICAgIHBvbHlsaW5lLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgIGxldCBjb29yZCA9IF9tYXAuc2NyZWVuVG9HZW8oZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRYLCBldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFkpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5wb2ludGVyRW50ZXIodGFyZ2V0LCBjb29yZE8yQShjb29yZCksIGV2KTtcclxuICAgICAgICB9KTtcclxuICAgIGlmIChzZXR0aW5ncy5wb2ludGVyTGVhdmUpXHJcbiAgICAgICAgcG9seWxpbmUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gX21hcC5zY3JlZW5Ub0dlbyhldi5jdXJyZW50UG9pbnRlci52aWV3cG9ydFgsIGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WSk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnBvaW50ZXJMZWF2ZSh0YXJnZXQsIGNvb3JkTzJBKGNvb3JkKSwgZXYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgaWYgKHNldHRpbmdzLnBvaW50ZXJDbGljaylcclxuICAgICAgICBwb2x5bGluZS5hZGRFdmVudExpc3RlbmVyKFwidGFwXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KHBvbHlsaW5lKTtcclxuXHJcbiAgICByZXR1cm4gcG9seWxpbmU7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogRHJhdyBhIHBvbHlnb25cclxuICogQGFsaWFzIGhtOnBvbHlnb25cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdCAgb3B0aW9ucyB0byBkcmF3IGEgcG9seWdvbi4gU2FtZSBvcHRpb25zIGFzIGhtLnBvbHlsaW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5Z29uKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZHM6IFwiXCIsIC8vIGNvb3JkcyBpcyBhcnJheSBvZiBbbGF0LGxuZ10gb3IgYXJyYXkgb2Yge2xhdDosbG5nOn1cclxuICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDQsXHJcbiAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBcInJnYmEoMCwgMTI4LCAyNTUsIDAuNylcIixcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAyNTUsIDAuNylcIlxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3R5bGVIb3ZlcjogbnVsbCwgLy8gc3R5bGUgc2kgbW91c2Ugb3ZlclxyXG4gICAgICAgIGFycm93czogbnVsbCxcclxuICAgICAgICBkYXRhOiBudWxsLCAvLyBhZGRpdGlvbmFsIGRhdGEgdG8gY2FycnlcclxuICAgICAgICB6OiBudWxsLFxyXG4gICAgICAgIHBvaW50ZXJDbGljazogbnVsbCwgLy8gY2xpY2tcclxuICAgICAgICBwb2ludGVyRW50ZXI6IG51bGwsIC8vIGNhbGwgYmFja1xyXG4gICAgICAgIHBvaW50ZXJMZWF2ZTogbnVsbCAvLyBjYWxsIGJhY2tcclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGxldCBsYXllciA9IGxheWVyRmluZChzZXR0aW5ncy5sYXllcik7XHJcbiAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJsYXllciBub3QgZm91bmQ6XCIgKyBzZXR0aW5ncy5sYXllcik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNvb3Jkcykge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiUG9seWxpbmU6IGNvb3JkcyBub3QgZm91bmQ6XCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0cmlwID0gbmV3IEguZ2VvLlN0cmlwKCk7XHJcbiAgICBzZXR0aW5ncy5jb29yZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICBzdHJpcC5wdXNoTGF0TG5nQWx0KHBvaW50WzBdLCBwb2ludFsxXSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgcG9seWdvbiA9IG5ldyBILm1hcC5Qb2x5Z29uKHN0cmlwLCB7XHJcbiAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlLFxyXG4gICAgICAgIGRhdGE6IHNldHRpbmdzLmRhdGEsXHJcbiAgICAgICAgYXJyb3dzOiBzZXR0aW5ncy5hcnJvd3NcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSBwb2x5Z29uLnNldERhdGEoc2V0dGluZ3MuZGF0YSk7XHJcbiAgICAvLyBaIGluZGV4XHJcbiAgICBpZiAoc2V0dGluZ3MueikgcG9seWxpbmUuc2V0WkluZGV4KHNldHRpbmdzLnopO1xyXG5cclxuICAgIC8vIHNpIHVuIHN0eWxlIGRlIGhvdmVyXHJcbiAgICBpZiAoc2V0dGluZ3Muc3R5bGVIb3Zlcikge1xyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldFN0eWxlKHNldHRpbmdzLnN0eWxlSG92ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgdGFyZ2V0LnNldFN0eWxlKHNldHRpbmdzLnN0eWxlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckVudGVyKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckVudGVyKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckxlYXZlKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckxlYXZlKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpZiAoc2V0dGluZ3MucG9pbnRlckNsaWNrKVxyXG4gICAgICAgIHBvbHlnb24uYWRkRXZlbnRMaXN0ZW5lcihcInRhcFwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSB0YXJnZXQuZ2V0RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgY29vcmQgPSBfbWFwLnNjcmVlblRvR2VvKGV2LmN1cnJlbnRQb2ludGVyLnZpZXdwb3J0WCwgZXYuY3VycmVudFBvaW50ZXIudmlld3BvcnRZKTtcclxuICAgICAgICAgICAgc2V0dGluZ3MucG9pbnRlckNsaWNrKHRhcmdldCwgY29vcmRPMkEoY29vcmQpLCBldiwgZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgbGF5ZXIuYWRkT2JqZWN0KHBvbHlnb24pO1xyXG5cclxuICAgIHJldHVybiBwb2x5Z29uO1xyXG59IC8vIGVuZCBvZiBwb2x5Z29uXHJcblxyXG4vKipcclxuICogZHJhdyBhIGNpcmNsZVxyXG4gKiBAYWxpYXMgaG06Y2lyY2xlXHJcbiAqIEBwYXJhbSBvcHQgeyp9ICAgb3B0aW9uIGZvciBjaXJjbGVcclxuICogQHBhcmFtIFtvcHQubGF5ZXJdIHtTdHJpbmd9IG9wdGlvbmFsIGxheWVyIHRvIHVzZSBcclxuICogQHBhcmFtIFtvcHQuY29vcmRdIHthcnJheX0gY2VudGVyIG9mIHRoZSBjaXJjbGUsIGFzIFxcWzQ4LjgsMi4zXFxdXHJcbiAqIEBwYXJhbSBbb3B0LnJhZGl1c10ge251bWJlcn0gcmFkaXVzIGluIG1ldGVyXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlXSB7b2JqZWN0fSBvcHRpb25hbCBncmFwaGljIHN0eWxlXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLnN0cm9rZUNvbG9yXSB7c3RyaW5nfSBjb2xvciBvZiBwZXJpbWV0ZXJcclxuICogQHBhcmFtIFtvcHQuc3R5bGUubGluZVdpZHRoXSB7bnVtYmVyfSBsaW5lIHdpZHRoXHJcbiAqIEBwYXJhbSBbb3B0LnN0eWxlLmZpbGxDb2xvcl0ge3N0cmluZ30gZmlsbCBjb2xvclxyXG4gKi9cclxuZnVuY3Rpb24gY2lyY2xlKG9wdCkge1xyXG4gICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgIGxheWVyOiBcImRlZmF1bHRcIixcclxuICAgICAgICBjb29yZDogbnVsbCxcclxuICAgICAgICByYWRpdXM6IDEwMCwgLy8gbWV0ZXJzXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IFwicmdiYSg1NSwgODUsIDE3MCwgMC4yKVwiLCAvLyBDb2xvciBvZiB0aGUgcGVyaW1ldGVyXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgICAgICAgZmlsbENvbG9yOiBcInJnYmEoMCwgMTI4LCAwLCAwLjEpXCIgIC8vIENvbG9yIG9mIHRoZSBjaXJjbGVcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgbGV0IGxheWVyID0gbGF5ZXJGaW5kKHNldHRpbmdzLmxheWVyKTtcclxuICAgIGlmICghbGF5ZXIpIHtcclxuICAgICAgICBsZXQgZSA9IG5ldyBFcnJvcihcImxheWVyIG5vdCBmb3VuZDpcIiArIHNldHRpbmdzLmxheWVyKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNpcmNsZSA9IG5ldyBILm1hcC5DaXJjbGUoXHJcbiAgICAgICAgLy8gVGhlIGNlbnRyYWwgcG9pbnQgb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgIGNvb3JkQTJPKHNldHRpbmdzLmNvb3JkKSxcclxuICAgICAgICAvLyBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUgaW4gbWV0ZXJzXHJcbiAgICAgICAgc2V0dGluZ3MucmFkaXVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLnN0eWxlXHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBsYXllci5hZGRPYmplY3QoY2lyY2xlKTtcclxuICAgIHJldHVybiBjaXJjbGU7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiB3YXRjaCBwb3NpdGlvbiBvbiBIVE1MNSBwb3NpdGlvbi4gcmVxdWlyZXMgSFRUUFNcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpsb2NhdGVNZVxyXG4gKiBAcGFyYW0gY2FsbGJhY2sge2Z1bmN0aW9ufSAgY2FsbGJhY2sgd2hlbiBjb29yZCBjaGFuZ2VzLiBGb3JtYXQ6IGNhbGxiYWNrKGNvb3JkLGFjY3VyYWN5KSBcclxuICogQHBhcmFtIG9wdCB7T2JqZWN0fSBvcHRpb25hbCBncmFwaGljIG9wdGlvbnNcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb25dIHtvYmplY3R9ICBncmFwaGljIG9wdGlvbnMgZm9yIGNlbnRlci4gU2VlIGJ1aWxkSWNvblxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5zdmddIHtzdHJpbmd9ICBzdmcgZmlsZVxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5jb2xvcl0ge3N0cmluZ30gIGNvbG9yIGZvciAge2NvbG9yfSB0YWdcclxuICogQHBhcmFtIFtvcHQucG9zaXRpb24uc2l6ZV0ge251bWJlcn0gIHNpemUgb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5wb3NpdGlvbi5hbmNob3JdIHtudW1iZXJ9ICBhbmNob3Igb2YgaWNvblxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeV0ge29iamVjdH0gIGdyYXBoaWMgb3B0aW9ucyBmb3IgYWNjdXJhY3kgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIFtvcHQuYWNjdXJhY3kuc3Ryb2tlQ29sb3JdIHtTdHJpbmd9ICBjb2xvciBvZiBjaXJjbGUgbGluZSByZXByZXNlbnRpbmcgYWNjdXJhY3kgYXJlYVxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeS5saW5lV2lkdGhdIHtudW1iZXJ9ICB3aWR0aCBvZiBsaW5lIG9mIGNpcmNsZVxyXG4gKiBAcGFyYW0gW29wdC5hY2N1cmFjeS5maWxsQ29sb3JdIHtTdHJpbmd9ICBmaWxsIGNvbG9yIG9mIGNpcmNsZSByZXByZXNlbnRpbmcgYWNjdXJhY3kgYXJlYVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbG9jYXRlTWUoY2FsbGJhY2ssIG9wdCkge1xyXG5cclxuICAgIC8vIGlmIG5vIGNhbGxiYWNrLCByZW1vdmUgdGhlIHdhdGNoXHJcbiAgICBpZiAobmF2aWdhdG9yLmdlb2xvY2F0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBfbG9jYXRlTWUpIHtcclxuICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmNsZWFyV2F0Y2goX2xvY2F0ZU1lKTtcclxuICAgICAgICAgICAgX2xvY2F0ZU1lID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgc3ZnOiBcInN2Zy9jcm9zc2hhaXIuc3ZnXCIsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJibGFja1wiLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMjQsXHJcbiAgICAgICAgICAgICAgICBhbmNob3I6IDEyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjY3VyYWN5OiB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogXCJyZ2JhKDAsIDEyOCwgMCwgMC44KVwiLCAvLyBDb2xvciBvZiB0aGUgcGVyaW1ldGVyXHJcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFwicmdiYSgwLCAxMjgsIDAsIDAuNClcIiAgLy8gQ29sb3Igb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgICAgICBsZXQgaWNvbkNyb3NzSGFpciA9IGF3YWl0IGJ1aWxkSWNvbih7XHJcbiAgICAgICAgICAgIHN2Zzogc2V0dGluZ3MucG9zaXRpb24uc3ZnLFxyXG4gICAgICAgICAgICBpbWc6IHNldHRpbmdzLnBvc2l0aW9uLmltZyxcclxuICAgICAgICAgICAgb3B0OiBzZXR0aW5ncy5wb3NpdGlvblxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy9uYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKGZ1bmN0aW9uIHBvcyhwb3NpdGlvbikge1xyXG4gICAgICAgIF9sb2NhdGVNZSA9IG5hdmlnYXRvci5nZW9sb2NhdGlvbi53YXRjaFBvc2l0aW9uKChwb3NpdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZ3BzID0gW3Bvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZV07XHJcblxyXG4gICAgICAgICAgICBsYXllckVtcHR5KFwiX2dwc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNpcmNsZSBzaG93aW5nIHRoZSBhY2N1cmFjeSByYWRpdXMqL1xyXG4gICAgICAgICAgICBjaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXI6IFwiX2dwc1wiLFxyXG4gICAgICAgICAgICAgICAgY29vcmQ6IGdwcyxcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5LFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHNldHRpbmdzLmFjY3VyYWN5XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbWFya2VyKHtcclxuICAgICAgICAgICAgICAgIGxheWVyOiBcIl9ncHNcIixcclxuICAgICAgICAgICAgICAgIGNvb3JkOiBncHMsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBpY29uQ3Jvc3NIYWlyXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2soZ3BzLCBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kpO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gXCJcIjtcclxuICAgICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlBFUk1JU1NJT05fREVOSUVEOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIlVzZXIgZGVuaWVkIHRoZSByZXF1ZXN0IGZvciBHZW9sb2NhdGlvbi5cIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZXJyb3IuUE9TSVRJT05fVU5BVkFJTEFCTEU6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiTG9jYXRpb24gaW5mb3JtYXRpb24gaXMgdW5hdmFpbGFibGUuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGVycm9yLlRJTUVPVVQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwidGltZWQgb3V0LlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBlcnJvci5VTktOT1dOX0VSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJIVE1MNSBsb2NhdGlvbiBlcnJvcjpcIiArIG1zZyk7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJubyBIVE1MNSBnZW9sb2NhdGlvbiBjYXBhYmlsaXRpZXNcIik7IC8vIGUubWVzc2FnZVxyXG4gICAgICAgIHRocm93IChlKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBwZXJmb3JtIGEgc2NyZWVuc2hvdCBvZiB0aGUgbWFwIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIHRoZSBkYXRhXHJcbiAqIEBhc3luY1xyXG4gKiBAYWxpYXMgaG06bG9jYXRlTWVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb25zIGZvciBzY3JlZW5zaG90XHJcbiAqIEBwYXJhbSBbb3B0Lm5hbWVdIHtzdHJpbmd9IGZpbGVuYW1lIGZvciBkb3dubG9hZFxyXG4gKiBAcGFyYW0gW29wdC51aV0ge2Jvb2xlYW59IHRydWUgdG8gc2F2ZSB1aSAoc2NhbGUsIGV0Yy4uKVxyXG4gKiBAcGFyYW0gb3B0IHtvYmplY3R9IG9wdGlvbnMgZm9yIHNjcmVlbnNob3RcclxuICogXHJcbiAqIEByZXR1cm5zIHtkYXRhfSBiaW5hcnkgZGF0YSBvZiBpbWFnZVxyXG4gKiBcclxuICovXHJcbmZ1bmN0aW9uIHNjcmVlbnNob3Qob3B0KSB7XHJcbiAgICBsZXQgcGFyYSA9IG51bGw7XHJcbiAgICBpZiAob3B0ICYmIG9wdC51aSlcclxuICAgICAgICBwYXJhID0gW191aV07XHJcblxyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKFxyXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgX21hcC5jYXB0dXJlKGZ1bmN0aW9uIChjYW52YXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY2FudmFzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJNYXAgc2NyZWVuc2hvdCBub3Qgc3VwcG9ydGVkXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcHQgJiYgb3B0Lm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmhyZWYgPSBkYXRhVVJMO1xyXG4gICAgICAgICAgICAgICAgICAgIGEudGFyZ2V0ID0gJ19ibGFuayc7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5kb3dubG9hZCA9IG9wdC5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhVVJMKTtcclxuXHJcblxyXG4gICAgICAgICAgICB9LCBwYXJhKTtcclxuICAgICAgICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGdldE1hcCgpIHtcclxuICAgIHJldHVybiBfbWFwO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRVSSgpIHtcclxuICAgIHJldHVybiBfdWk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY29vcmRPMkE6IGNvb3JkTzJBLFxyXG4gICAgY29vcmRBMk86IGNvb3JkQTJPLFxyXG4gICAgZ2V0TWFwOiBnZXRNYXAsXHJcbiAgICBnZXRVSTogZ2V0VUksXHJcbiAgICBtYXA6IG1hcCxcclxuICAgIGdldEF2YWlsYWJsZU1hcFN0eWxlOiBnZXRBdmFpbGFibGVNYXBTdHlsZSxcclxuICAgIHNldFNjaGVtZTogc2V0U2NoZW1lLFxyXG4gICAgbGF5ZXJDcmVhdGU6IGxheWVyQ3JlYXRlLFxyXG4gICAgbGF5ZXJGaW5kOiBsYXllckZpbmQsXHJcbiAgICBsYXllckRlbGV0ZTogbGF5ZXJEZWxldGUsXHJcbiAgICBsYXllckVtcHR5OiBsYXllckVtcHR5LFxyXG4gICAgYnVpbGRJY29uOiBidWlsZEljb24sXHJcbiAgICBidWJibGVVbmlxdWU6IGJ1YmJsZVVuaXF1ZSxcclxuICAgIGJ1YmJsZVVuaXF1ZUhpZGU6IGJ1YmJsZVVuaXF1ZUhpZGUsXHJcbiAgICBtYXJrZXI6IG1hcmtlcixcclxuICAgIGNpcmNsZTogY2lyY2xlLFxyXG4gICAgcG9seWxpbmU6IHBvbHlsaW5lLFxyXG4gICAgcG9seWdvbjogcG9seWdvbixcclxuICAgIGdldENlbnRlcjogZ2V0Q2VudGVyLFxyXG4gICAgc2V0Q2VudGVyOiBzZXRDZW50ZXIsXHJcbiAgICBnZXRab29tOiBnZXRab29tLFxyXG4gICAgc2V0Wm9vbTogc2V0Wm9vbSxcclxuICAgIGdldHZpZXdCQjogZ2V0Vmlld0JCLFxyXG4gICAgc2V0Vmlld0JCOiBzZXRWaWV3QkIsXHJcbiAgICBsb2NhdGVNZTogbG9jYXRlTWUsXHJcbiAgICBzY3JlZW5zaG90OiBzY3JlZW5zaG90XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5jb25zdCBjbSA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgcm91dGUgd2l0aCBvcHRpb25hbCB3YXlwb29pbnRzLiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiAgQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpyb3V0ZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlIC0gc291cmNlIGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIHtvYmplY3R9IGRlc3QgLSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdIHRvIGRlZmluZSB3YXlwb2ludHNcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSByb3V0ZSBvcHRpb25zIFxyXG4gKiBAcGFyYW0gW29wdC5tb2RlPWZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRdIHtzdHJpbmd9ICByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQucm91dGVhdHRyaWJ1dGVzPXdheXBvaW50cyxzdW1tYXJ5LHNoYXBlXSB7c3RyaW5nfSAgcm91dGUgYXR0cmlidXRlc1xyXG4gKiBAcGFyYW0gW29wdC5tYW5ldXZlcmF0dHJpYnV0ZXM9ZGlyZWN0aW9uLGFjdGlvbl0ge3N0cmluZ30gIG1hbm9ldXZlciBhdHRyaWJ1dGVzXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IHJldHVybnMgeyBzdW1tYXJ5OiBvYmplY3QsIGNvb3JkczphcnJheSxyb3V0ZTogb2JqZWN0LCBib2R5Om9iamVjdH0uIGNvb3JkcyBpcyBhcnJheSBvZiBjb29yZCwgdG8gYmUgdXNlZCB3aXRoIGhtLnBvbHlsaW5lLiBcclxuICpcclxuICogQGV4YW1wbGVcclxuICAqIGBgYGpzXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLFs0OC43LDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTtcclxuICAqIFxyXG4gICogY29uc3QgcmVzID0gYXdhaXQgaG0ucm91dGUoW1s0OC44LDIuM10sWzQ4LjksMi43XV0sIFs0OS4zLDIuNV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5yb3V0ZSk7IFxyXG4gICogXHJcbiAgKiBjb25zdCByZXMgPSBhd2FpdCBobS5yb3V0ZShbNDguOCwyLjNdLCBbWzQ4LjksMi43XSwgWzQ5LjMsMi41XV0pO1xyXG4gICogY29uc29sZS5sb2cgKHJlcy5zdW1tYXJ5KTsgXHJcbiAgKiBgYGBcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHJvdXRlKHNvdXJjZSwgZGVzdCwgb3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIsXHJcbiAgICAgICAgcmVwcmVzZW50YXRpb246IFwibGlua1BhZ2luZ1wiLFxyXG4gICAgICAgIHJvdXRlYXR0cmlidXRlczogXCJ3YXlwb2ludHMsc3VtbWFyeSxzaGFwZVwiLFxyXG4gICAgICAgIG1hbmV1dmVyYXR0cmlidXRlczogXCJkaXJlY3Rpb24sYWN0aW9uXCJcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGFyYW1zID0gY20uYWRkQ3JlZGVudGlhbHMoc2V0dGluZ3MsIG9wdCk7XHJcblxyXG4gICAgLy8gMSBzZXVsIHNvdXJjZSBvdSBhcnJheSBkZSBzb3VyY2UgP1xyXG4gICAgbGV0IGlkID0gMDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVswXSkpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBjb29yZFswXSArIFwiLFwiICsgY29vcmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICAgIHBhcmFtc1tcIndheXBvaW50XCIgKyBpZCsrXSA9IHNvdXJjZVswXSArIFwiLFwiICsgc291cmNlWzFdO1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RbMF0pKVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNvb3JkID0gZGVzdFtpXTtcclxuICAgICAgICAgICAgcGFyYW1zW1wid2F5cG9pbnRcIiArIGlkKytdID0gY29vcmRbMF0gKyBcIixcIiArIGNvb3JkWzFdO1xyXG4gICAgICAgIH1cclxuICAgIGVsc2VcclxuICAgICAgICBwYXJhbXNbXCJ3YXlwb2ludFwiICsgaWQrK10gPSBkZXN0WzBdICsgXCIsXCIgKyBkZXN0WzFdO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwicm91dGVcIiwgXCJhcGkuaGVyZS5jb20vcm91dGluZy83LjIvY2FsY3VsYXRlcm91dGUuanNvblwiKTtcclxuICAgIHJldHVybiBjbS5oZXJlUmVzdCh1cmwsIHBhcmFtcywgXCJwb3N0XCIpXHJcbiAgICAgICAgLnRoZW4ocmVzID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcmVzLmJvZHkucmVzcG9uc2Uucm91dGVbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSByb3V0ZS5zdW1tYXJ5O1xyXG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSByb3V0ZS5zaGFwZS5tYXAoKGxhdGxuZyA9PiBsYXRsbmcuc3BsaXQoXCIsXCIpKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBzdW1tYXJ5OiBzdW1tYXJ5LCBjb29yZHM6IGNvb3Jkcywgcm91dGU6IHJvdXRlLCBib2R5OiByZXMuYm9keSB9O1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogY29tcHV0ZSBhbiBpc29saW5lLiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiBAYXN5bmNcclxuICogQGFsaWFzIGhtOmlzb2xpbmVcclxuICogQHBhcmFtIG9wdCB7b2JqZWN0fSBvcHRpb24gZm9yIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuc3RhcnRdIHtjb29yZH0gY29vcmQgZm9yIHN0YXJ0aW5nIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQuZGVzdGluYXRpb25dIHtjb29yZH0gY29vcmQgZm9yIGRlc3RpbmF0aW9uIHBvaW50IG9mIGlzb2xpbmVcclxuICogQHBhcmFtIFtvcHQucmFuZ2VUeXBlPVwidGltZVwiXSB7c3RyaW5nfSB0aW1lIG9yIGRpc3RhbmNlXHJcbiAqIEBwYXJhbSBbb3B0LnJhbmdlXSB7bnVtYmVyfSByYW5nZSBpbiBzZWNvbmRzIG9yIGluIG1ldGVyc1xyXG4gKiBAcGFyYW0gW29wdC5tb2RlPVwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiXSB7U3RyaW5nfSByb3V0aW5nIG1vZGVcclxuICogQHBhcmFtIFtvcHQubGlua2F0dHJpYnV0ZXM9c2hdIHtTdHJpbmd9IGF0dHJpYnV0ZXMgdG8gYmUgcmV0dXJuZWRcclxuICogXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9ICByZXR1cm5zIHsgcG9seTphcnJheSwgYm9keTpvYmplY3QgfS4gUG9seSBpcyBhcnJheSBvZiBjb29yZHMsIGJvZHkgaXMgZnVsbCBhbnN3ZXJcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlzb2xpbmUob3B0KSB7XHJcblxyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgICAgICAgc3RhcnQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBkaXJlY3QgaXNvbGluZVxyXG4gICAgICAgIGRlc3RpbmF0aW9uOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcmV2ZXJzZSBpc29saW5lXHJcbiAgICAgICAgcmFuZ2VUeXBlOiBcInRpbWVcIiwgICAgICAgICAgICAgICAgICAgICAgLy8gdGltZSBvciBkaXN0YW5jZVxyXG4gICAgICAgIHJhbmdlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBzZWNvbmRzIG9yIG1ldGVyc1xyXG4gICAgICAgIGxpbmthdHRyaWJ1dGVzOiBcInNoXCIsICAgICAgICAgICAgICAgICAgIC8vIHRvIGdldCB0aGUgc2hhcGVcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZGlzYWJsZWRcIiwgICAvL3Nob3J0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkIFxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhcmFtcyA9IGNtLmFkZENyZWRlbnRpYWxzKHNldHRpbmdzLCBvcHQpO1xyXG5cclxuICAgIGlmIChwYXJhbXMuc3RhcnQpXHJcbiAgICAgICAgcGFyYW1zLnN0YXJ0ID0gXCJnZW8hXCIgKyBwYXJhbXMuc3RhcnRbMF0gKyBcIixcIiArIHBhcmFtcy5zdGFydFsxXTtcclxuICAgIGlmIChwYXJhbXMuZGVzdGluYXRpb24pXHJcbiAgICAgICAgcGFyYW1zLmRlc3RpbmF0aW9uID0gXCJnZW8hXCIgKyBwYXJhbXMuZGVzdGluYXRpb25bMF0gKyBcIixcIiArIHBhcmFtcy5kZXN0aW5hdGlvblsxXTtcclxuXHJcbiAgICBpZiAoIXBhcmFtcy5zdGFydCAmJiAhcGFyYW1zLmRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGUgPSBuZXcgRXJyb3IoXCJJc29saW5lIHJvdXRpbmcgOiBtaXNzaW5nIHN0YXJ0IG9yIGRlc3RpbmF0aW9uXCIpOyAvLyBlLm1lc3NhZ2VcclxuICAgICAgICB0aHJvdyAoZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmFtcy5yYW5nZSkge1xyXG4gICAgICAgIGxldCBlID0gbmV3IEVycm9yKFwiSXNvbGluZSByb3V0aW5nIDogbWlzc2luZyByYW5nZVwiKTsgLy8gZS5tZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwiaXNvbGluZS5yb3V0ZVwiLCBcImFwaS5oZXJlLmNvbS9yb3V0aW5nLzcuMi9jYWxjdWxhdGVpc29saW5lLmpzb25cIik7XHJcbiAgICByZXR1cm4gY20uaGVyZVJlc3QodXJsLCBwYXJhbXMsIFwicG9zdFwiKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBhcnJheSBvZiBsYXQsbG5nLCB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIGFycmF5IG9mIFtsYXQsbG5nXVxyXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHJlcy5ib2R5LnJlc3BvbnNlLmlzb2xpbmVbMF0uY29tcG9uZW50WzBdLnNoYXBlO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gc2hhcGUubWFwKHBvaW50ID0+IHBvaW50LnNwbGl0KFwiLFwiKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBwb2x5OiBwb2x5LCBib2R5OiByZXMuYm9keSB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBjb21wdXRlIGEgbWF0cml4LiBbc2VlIG1vcmUgaW5mbyBvbiBvcHRpb25hbCBwYXJhbWV0ZXJzXSAoaHR0cDovL2RvY3VtZW50YXRpb24uZGV2ZWxvcGVyLmhlcmUuY29tL3BkZi9yb3V0aW5nX2hscC83LjIuMTAwL1JvdXRpbmclMjBBUEklMjB2Ny4yLjEwMCUyMERldmVsb3BlcidzJTIwR3VpZGUucGRmKVxyXG4gKiBcclxuICogTWF0cml4IHNpemUgaXMgbGltaXRlZCB0byAxeDEwMCwxMDBYMSBvciAxNSpOXHJcbiAqICBAYXN5bmNcclxuICogQGFsaWFzIGhtOm1hdHJpeFxyXG4gKiBAcGFyYW0gc291cmNlIHtvYmplY3R9IHNvdXJjZSBhcyBcXFtsYXQsbG5nXFxdLiBDYW4gYmUgYXJyYXkgb2YgXFxbbGF0LGxuZ1xcXVxyXG4gKiBAcGFyYW0gZGVzdCB7b2JqZWN0fSBkZXN0IGFzIFxcW2xhdCxsbmdcXF0uIENhbiBiZSBhcnJheSBvZiBcXFtsYXQsbG5nXFxdXHJcbiAqIEBwYXJhbSBvcHQge29iamVjdH0gYWRkaXRpb25hbCBvcHRpb25hbCBwYXJhbWV0ZXJzIGxpa2UgIG1vZGUsIHN1bW1hcnlBdHRyaWJ1dGVzXHJcbiAqIEBwYXJhbSBbb3B0Lm1vZGU9XCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmVuYWJsZWRcIl0ge3N0cmluZ30gcm91dGluZyBtb2RlIHRvIGNvbXB1dGUgbWF0cml4XHJcbiAqIEBwYXJhbSBbb3B0LnN1bW1hcnlBdHRyaWJ1dGVzPVwidHQsZGlcIl0ge3N0cmluZ30gYXR0cmlidXRlcyBpbiB0aGUgYW5zd2VyXHJcbiAqIFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7IGVudHJpZXM6IG9iamVjdCwgYm9keTpvYmplY3QgfS4gZW50cmllcyBpcyB0aGUgYXJyYXkgb2Yge3N0YXJ0LHN0b3B9IGluZm9ybWF0aW9uLiBib2R5IGlzIGZ1bGwganNvbiBhbnN3ZXJcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogY29uc3QgcmVzID0gYXdhaXQgaG0ubWF0cml4KHtcclxuICogICAgICBzb3VyY2U6WzQ4LjgsMi4zXVxyXG4gKiAgICAgIGRlc3Q6W1s0OC43LDIuNV0sWzQ4LjEsMi4wXSxbNDQuMiwyLjNdXVxyXG4gKiB9KTtcclxuICogY29uc29sZS5sb2cgKHJlcy5lbnRyaWVzKTsgXHJcbiAqIGBgYFxyXG4gKi9cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIG1hdHJpeChzb3VyY2UsIGRlc3QsIG9wdCkge1xyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IHtcclxuICAgICAgICBtb2RlOiBcImZhc3Rlc3Q7Y2FyO3RyYWZmaWM6ZW5hYmxlZFwiLFxyXG4gICAgICAgIHN1bW1hcnlBdHRyaWJ1dGVzOiBcInR0LGRpXCJcclxuICAgIH07XHJcbiAgICBjb25zdCBwYXJhbXMgPSBjbS5hZGRDcmVkZW50aWFscyhzZXR0aW5ncywgb3B0KTtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlWzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcclxuICAgIHNvdXJjZS5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcInN0YXJ0XCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShkZXN0WzBdKSkgLy8gaWYgb25seSBvbmUgY29vcmRcclxuICAgICAgICBkZXN0ID0gW2Rlc3RdO1xyXG4gICAgZGVzdC5mb3JFYWNoKChjb29yZCwgaSkgPT4ge1xyXG4gICAgICAgIHBhcmFtc1tcImRlc3RpbmF0aW9uXCIgKyBpXSA9IGNvb3JkWzBdICsgXCIsXCIgKyBjb29yZFsxXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVybCA9IGNtLmJ1aWxkVXJsKFwibWF0cml4LnJvdXRlXCIsIFwiYXBpLmhlcmUuY29tL3JvdXRpbmcvNy4yL2NhbGN1bGF0ZW1hdHJpeC5qc29uXCIpO1xyXG4gICAgcmV0dXJuIGNtLmhlcmVSZXN0KHVybCwgcGFyYW1zLCBcInBvc3RcIilcclxuICAgICAgICAudGhlbihyZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4geyBlbnRyaWVzOiByZXMuYm9keS5yZXNwb25zZS5tYXRyaXhFbnRyeSwgYm9keTogcmVzLmJvZHkgfTtcclxuICAgICAgICB9KTtcclxuXHJcblxyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBkZXRvdXIgZm9yIGVhY2ggd2F5cG9pbnQgcHJvdmlkZWQsIGNvbXBhcmVkIHRvIG5vcm1hbCByb3V0ZSBmcm9tIEEgdG8gQlxyXG4gKiBcclxuICogQGFzeW5jXHJcbiAqIEBhbGlhcyBobTpkZXRvdXJcclxuICogQHBhcmFtIHN0YXJ0IHtjb29yZH0gIHN0YXJ0aW5nIHBvaW50IGZvciByb3V0ZVxyXG4gKiBAcGFyYW0gc3RvcCB7Y29vcmR9ICAgZGVzdGluYXRpb24gcG9pbnQgb2Ygcm91dGVcclxuICogQHBhcmFtIHdheXBvaW50cyB7YXJyYXl9ICBsaXN0IG9mIHdhdHlwb2ludHMgdG8gdGVzdCBcclxuICogQHJldHVybnMge29iamVjdH0gcmV0dXJucyB7cmVmZXJlbmNlLHdheXBvaW50czpbIHtjb29yZCxkaXN0QSx0aW1lQSxkaXN0Qix0aW1lQn1dfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGV0b3VyKHN0YXJ0LCBzdG9wLCB3YXlwb2ludHMpIHtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgIG5vLXVuZGVmXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvL2xldCB0U3RhcnQgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFzdGFydCkgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgc3RhcnQgcG9pbnRcIik7XHJcbiAgICAgICAgICAgIGlmICghc3RvcCkgcmV0dXJuIHJlamVjdChcIm1pc3Npbmcgc3RvcCBwb2ludFwiKTtcclxuICAgICAgICAgICAgaWYgKCF3YXlwb2ludHMpIHJldHVybiByZWplY3QoXCJtaXNzaW5nIHdheXBvaW50c1wiKTtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KSByZXR1cm4gcmVqZWN0KFwid2F5cG9pbnRzIHNob3VsZCBiZSBhbiBhcnJheVwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXNlIGxlIHJlc3VsdGF0IFxyXG4gICAgICAgICAgICBsZXQgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiB7fSxcclxuICAgICAgICAgICAgICAgIHdheXBvaW50czogW11cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bCBsZXMgY29vcmRzIG5vblBvc3RHcmVzLCBjcmVlciBsJ2FycmF5IGRlIGNvb3JkIGRlcyB3YXlwb2ludHMuXHJcbiAgICAgICAgICAgIGxldCBkZXN0ID0gW3N0b3BdOyAvLyBzbyB3ZSBoYXZlIGEgZGlzdGFuY2UvdGltZSByZWZlcmVuY2UsIG5vdCBzYW1lIGFzIGZyb20gcm91dGluZyAxOjFcclxuICAgICAgICAgICAgd2F5cG9pbnRzLmZvckVhY2god2F5cG9pbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgZGVzdC5wdXNoKHdheXBvaW50KTtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICB7IGNvb3JkOiB3YXlwb2ludCB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gaW5zcGVjdChkZXN0LCBcImRlc3QgZnJvbSBkZXRvdXJcIilcclxuXHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgc3RhcnQgdG8gYWxsIHdheXBvaW50LCAxc3Qgd2F5cG9pbnQgaXMgc3RvcCB0byBnZXQgYSByZWZlcmVuY2VcclxuICAgICAgICAgICAgbGV0IHAxID0gbWF0cml4KHN0YXJ0LCBkZXN0LCB7IG1vZGU6IFwiZmFzdGVzdDtjYXI7dHJhZmZpYzpkaXNhYmxlZFwiIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBmcm9tIGFsbCB3YXlwb2ludCB0byBzdG9wLCAxc3Qgd2F5cG9pbnQgaXMgc3RhcnQgdG8gZ2V0IGFub3RoZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgIGRlc3RbMF0gPSBzdGFydDtcclxuICAgICAgICAgICAgbGV0IHAyID0gbWF0cml4KGRlc3QsIHN0b3AsIHsgbW9kZTogXCJmYXN0ZXN0O2Nhcjt0cmFmZmljOmRpc2FibGVkXCIgfSk7XHJcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGJvdGggbWF0cml4IHRvIGNvbXBsZXRlXHJcblxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgICBuby11bmRlZlxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLmFsbChbcDEsIHAyXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIGZpcnN0IHBhcnQ6IHN0YXJ0ID0+IE4gd2F5cG9pbnRzXHJcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gcmVzdWx0WzBdLmVudHJpZXM7XHJcbiAgICAgICAgICAgIC8vIGZpcnN0IGVudHJ5IGlzIHN0YXJ0IHN0b3BcclxuICAgICAgICAgICAgbGV0IGRpc3QgPSBlbnRyaWVzWzBdLnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lID0gZW50cmllc1swXS5zdW1tYXJ5LnRyYXZlbFRpbWU7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2Uuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5zdG9wID0gc3RvcDtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS5kaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgIHJlcy5yZWZlcmVuY2UudGltZSA9IHRpbWU7IC8vIHRoZSByZWZlcmVuY2Ugc2FucyB3YXlwb2ludFxyXG5cclxuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgcmV0dXJuOyAvLyBza2lwIHRoZSBmaXJzdCB3aGljaCBpcyBzdGFydCBzdG9wXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXR1cyA9PSBcImZhaWxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlbnRyeSwgXCJlcnJvciBvbiBtYXRyaXhBXCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHN0YXJ0LCBcImFzc29jaWF0ZWQgc3RhcnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkZXN0W2ldLCBcImFzc29jaWF0ZWQgZGVzdFwiICsgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpZCA9IGVudHJ5LmRlc3RpbmF0aW9uSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IGVudHJ5LnN1bW1hcnkuZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZSA9IGVudHJ5LnN1bW1hcnkudHJhdmVsVGltZTtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS5kaXN0QSA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICByZXMud2F5cG9pbnRzW2lkIC0gMV0udGltZUEgPSB0aW1lO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHNlY29uZCBwYXJ0OiBOIHdheXBvaW50cyA9PiBzdG9wXHJcbiAgICAgICAgICAgIGVudHJpZXMgPSByZXN1bHRbMV0uZW50cmllcztcclxuICAgICAgICAgICAgLy9pbnNwZWN0KGVudHJpZXNbMF0sIFwibWF0cml4QjBcIik7XHJcblxyXG4gICAgICAgICAgICByZXMucmVmZXJlbmNlLmRpc3RhbmNlMiA9IGVudHJpZXNbMF0uc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgcmVzLnJlZmVyZW5jZS50aW1lMiA9IGVudHJpZXNbMF0uc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG5cclxuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkgcmV0dXJuOyAvLyBza2lwIHRoZSBmaXJzdCB3aGljaCBpcyBzdGFydCBzdG9wXHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXR1cyA9PSBcImZhaWxlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlbnRyeSwgXCJlcnJvciBvbiBtYXRyaXhCXCIgKyBpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVudHJ5LCBcImFzc29jaWF0ZWQgc3RhcnRcIiArIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RvcCwgXCJhc3NvY2lhdGVkIHN0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gZW50cnkuc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gZW50cnkuc3VtbWFyeS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lID0gZW50cnkuc3VtbWFyeS50cmF2ZWxUaW1lO1xyXG4gICAgICAgICAgICAgICAgcmVzLndheXBvaW50c1tpZCAtIDFdLmRpc3RCID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHJlcy53YXlwb2ludHNbaWQgLSAxXS50aW1lQiA9IHRpbWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgbWF0cml4OiBtYXRyaXgsXHJcbiAgICByb3V0ZTogcm91dGUsXHJcbiAgICBpc29saW5lOiBpc29saW5lLFxyXG4gICAgZGV0b3VyOiBkZXRvdXJcclxufTtcclxuXHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLypcclxuICogQG1vZHVsZSBIRVJFTUFQXHJcbiAqIEB0eXBpY2FsbmFtZSBobVxyXG4gKi9cclxuXHJcbmxldCBtb2R1bGVzID0ge307XHJcbk9iamVjdC5hc3NpZ24obW9kdWxlcywgcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9yb3V0aW5nLmpzXCIpKTtcclxuT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9nZW9jb2RpbmcuanNcIikpO1xyXG5cclxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9tYXAuanNcIikpO1xyXG4gICAgT2JqZWN0LmFzc2lnbihtb2R1bGVzLCByZXF1aXJlKFwiLi9jbHVzdGVyLmpzXCIpKTtcclxufVxyXG4vLyBleHBvcnQgYWxsIHRoZSBhYm92ZVxyXG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZXM7XHJcblxyXG4vL2NvbnNvbGUubG9nKFwibW9kdWxlLmV4cG9ydHNcIiwgbW9kdWxlLmV4cG9ydHMpO1xyXG4vL2NvbnNvbGUubG9nKFwicHJvY2Vzcy5icm93c2VyXCIsIHByb2Nlc3MuYnJvd3Nlcik7Il19
